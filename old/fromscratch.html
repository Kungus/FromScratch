<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic 3D Editor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(45, 45, 45, 0.95);
            border-radius: 8px;
            color: #fff;
            min-width: 220px;
            max-width: 280px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            overflow-x: hidden;
        }

        .panel-header {
            background: rgba(35, 35, 35, 0.95);
            padding: 12px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel-title {
            margin: 0;
            color: #fff;
            font-size: 16px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .tab-bar {
            display: flex;
            background: rgba(35, 35, 35, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            flex: 1;
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            border-radius: 0;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
        }

        .tab.active {
            background: rgba(124, 58, 237, 0.3);
            color: #a78bfa;
            border-bottom: 2px solid #7c3aed;
        }

        .tab-content {
            padding: 20px;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #controls h3 {
            margin: 0 0 15px 0;
            color: #a78bfa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        button {
            background: #4a5568;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #5a6578;
        }
        
        button.active {
            background: #7c3aed;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(45, 45, 45, 0.95);
            padding: 15px;
            border-radius: 8px;
            color: #999;
            font-size: 12px;
            max-width: 250px;
        }
        
        .info div {
            margin-bottom: 5px;
        }

        .vertex-label {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
            z-index: 1000;
            border: 1px solid #fff;
        }

        #axis-indicator {
            position: absolute;
            right: 20px;
            bottom: 20px;
            background: rgba(35, 35, 35, 0.95);
            padding: 10px 14px 12px;
            border-radius: 8px;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            z-index: 110;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        #axis-indicator .axis-title {
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: #cccccc;
        }

        #axis-indicator svg {
            width: 90px;
            height: 90px;
        }

        #axis-indicator text {
            font-size: 12px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            fill: #ffffff;
            font-weight: 600;
        }

        #axis-indicator .axis-caption {
            display: flex;
            gap: 10px;
            font-size: 11px;
        }

        #axis-indicator .axis-caption span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #axis-indicator .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        #extrusion-panel {
            position: absolute;
            top: 20px;
            left: 640px;
            right: auto;
            bottom: auto;
            background: rgba(45, 45, 45, 0.95);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            min-width: 300px;
            max-width: 400px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            display: none;
            z-index: 100;
        }

        #extrusion-panel h3 {
            margin: 0 0 15px 0;
            color: #a78bfa;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #bevel-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(45, 45, 45, 0.95);
            padding: 20px;
            border-radius: 8px;
            color: #fff;
            min-width: 300px;
            max-width: 400px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            display: none;
            z-index: 100;
        }

        #bevel-panel h3 {
            margin: 0 0 15px 0;
            color: #fb923c;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-group {
            margin-bottom: 15px;
        }

        .radio-group {
            margin-bottom: 20px;
        }

        .radio-group label {
            display: block;
            font-size: 12px;
            color: #999;
            margin-bottom: 8px;
        }

        .radio-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .radio-option {
            flex: 1;
            min-width: 80px;
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option label {
            display: block;
            padding: 8px 12px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            color: #999;
        }

        .radio-option input[type="radio"]:checked + label {
            background: #7c3aed;
            border-color: #a78bfa;
            color: #fff;
        }

        .radio-option label:hover {
            border-color: #7c3aed;
        }

        .color-picker-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .color-picker-group label {
            font-size: 12px;
            color: #999;
            margin: 0;
        }

        .color-picker-group input[type="color"] {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-preview {
            width: 60px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .checkbox-group label {
            font-size: 12px;
            color: #999;
            margin: 0;
            cursor: pointer;
        }

        .slider-group label {
            display: block;
            font-size: 12px;
            color: #999;
            margin-bottom: 5px;
        }

        .slider-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .slider-value {
            font-size: 12px;
            color: #7c3aed;
            font-weight: bold;
        }

        .extrusion-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .extrusion-buttons button {
            flex: 1;
        }

        .selection-info {
            position: absolute;
            top: 20px;
            left: 310px;
            background: rgba(45, 45, 45, 0.95);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            min-width: 200px;
            max-width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .selection-info h3 {
            margin: 0 0 10px 0;
            color: #a78bfa;
            font-size: 14px;
        }
        
        .selection-info .no-selection {
            color: #666;
            font-style: italic;
        }
        
        .face-selected {
            color: #4ade80;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <!-- Tab Bar -->
        <div class="tab-bar">
            <button class="tab active" data-tab="edit-tab">Edit</button>
        </div>

        <!-- Edit Tab Content -->
        <div id="edit-tab" class="tab-content active">
        <!-- Selection Mode removed - now using smart selection -->
        <!--
        <h3>Selection Mode</h3>
        <div class="control-group">
            <div class="button-group">
                <button id="object-mode-btn" class="active">Object</button>
                <button id="face-mode-btn">Face</button>
                <button id="edge-mode-btn">Edge</button>
                <button id="vertex-mode-btn">Vertex</button>
            </div>
        </div>
        -->
        
        <!-- Transform Mode removed - use control cube instead -->
        <!--
        <h3>Transform Mode</h3>
        <div class="control-group">
            <div class="button-group">
                <button id="select-btn">Select</button>
                <button id="translate-btn" class="active">Move</button>
                <button id="rotate-btn">Rotate</button>
                <button id="scale-btn">Scale</button>
            </div>
        </div>
        -->

        <div style="background: rgba(124, 58, 237, 0.1); padding: 10px; border-radius: 4px; margin: 10px 0;">
            <h4 style="margin: 0 0 5px 0; color: #a78bfa;">Smart Selection</h4>
            <div style="font-size: 11px; color: #bbb; line-height: 1.4;">
                â€¢ Click near vertex/edge/face to select<br>
                â€¢ Double-click to select entire object<br>
                â€¢ Use control cube faces to switch modes:<br>
                &nbsp;&nbsp;R=Rotate, S=Scale, T=Translate, N=Normal toggle, E=Extrude
            </div>
        </div>

        <h3>Grid Snapping</h3>
        <div class="control-group">
            <label>
                <input type="checkbox" id="grid-snap-checkbox">
                Enable Grid Snap
            </label>
            <div style="margin-top: 8px;">
                <label>Grid Size: <span id="grid-size-value">0.1</span></label>
                <div style="font-size: 10px; color: #666; margin-top: 4px;">
                    <button id="grid-01" style="padding: 2px 6px; font-size: 10px;">0.1</button>
                    <button id="grid-025" style="padding: 2px 6px; font-size: 10px;">0.25</button>
                    <button id="grid-05" style="padding: 2px 6px; font-size: 10px;">0.5</button>
                    <button id="grid-1" style="padding: 2px 6px; font-size: 10px;">1.0</button>
                </div>
            </div>
        </div>

        <h3>Face Operations</h3>
        <div class="control-group">
            <button id="extrude-btn" style="width: 100%; background: #7c3aed;">Extrude Face</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Select a face first
            </div>
        </div>

        <!-- Bevel edge removed - not working properly -->

        <!-- Symmetry mode removed -->

        <div class="control-group">
            <button id="mirror-btn" style="width: 100%; background: #0ea5e9;">Mirror Across Face</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Select a face to use as mirror plane
            </div>
        </div>

        <div class="control-group">
            <label>Objects</label>
            <div class="button-group">
                <button id="add-cube-btn">+ Cube</button>
                <button id="add-cylinder-btn">+ Cylinder</button>
                <button id="add-cone-btn">+ Cone</button>
                <button id="delete-btn">Delete</button>
            </div>
            <div style="margin-top: 8px;">
                <label style="font-size: 10px; color: #999;">Sides for Cylinder/Cone:</label>
                <input type="number" id="primitive-sides" min="3" max="64" value="8" style="width: 60px; padding: 4px;">
            </div>
        </div>
        
        <div class="control-group">
            <label>View</label>
            <div class="button-group">
                <button id="front-btn">Front</button>
                <button id="side-btn">Side</button>
                <button id="top-btn">Top</button>
                <button id="3d-btn" class="active">3D</button>
            </div>
            <div class="button-group" style="margin-top: 5px;">
                <button id="ortho-btn">O (Ortho)</button>
                <button id="persp-btn" class="active">P (Persp)</button>
            </div>
        </div>

        <div class="control-group">
            <button id="center-object-btn" style="width: 100%; background: #0ea5e9;">Center Object</button>
        </div>

        <div class="control-group">
            <button id="cut-tool-btn" style="width: 100%; background: #f59e0b;">Cut Tool</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Select an edge first, then activate
            </div>
            <div id="cut-distance-slider-group" style="display: none; margin-top: 10px;">
                <label style="font-size: 11px;">Cut Distance: <span id="cut-distance-value">0.00</span></label>
                <input type="range" id="cut-distance-slider" min="-1" max="1" step="0.01" value="0" style="width: 100%;">
                <button id="flip-cut-side-btn" style="width: 100%; margin-top: 8px; background: #8b5cf6;">
                    â†” Flip Keep Side (TAB)
                </button>
                <div style="font-size: 10px; color: #999; margin-top: 4px; text-align: center;">
                    Yellow arrow = keep side
                </div>
            </div>
        </div>

        <div class="control-group">
            <button id="reset-btn" style="width: 100%;">Reset Selection</button>
        </div>

        <h3>Debug Tools</h3>
        <div class="control-group">
            <button id="export-geo-btn" style="width: 100%; background: #059669;">Export Debug</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Copy geometry debug data to clipboard
            </div>
        </div>
        <div class="control-group">
            <button id="export-vicvector-btn" style="width: 100%; background: #10b981;">Export to vicVECTOR</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Export full 3D geometry to gameData.js format
            </div>
        </div>
        <div class="control-group">
            <button id="export-stl-btn" style="width: 100%; background: #7c3aed;">Export as STL</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Export geometry as .stl file for 3D printing or import
            </div>
        </div>
        <div class="control-group">
            <input type="file" id="import-stl-input" accept=".stl" style="display: none;">
            <button id="import-stl-btn" style="width: 100%; background: #0891b2;">Import STL File</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Load .stl file to edit or modify
            </div>
        </div>
        <div class="control-group">
            <button id="show-all-points-btn" style="width: 100%; background: #dc2626;">Show All Points</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Visualize all vertices with labels
            </div>
        </div>
        <div class="control-group">
            <button id="hide-points-btn" style="width: 100%; background: #854d0e;">Hide Points</button>
            <div style="font-size: 10px; color: #666; margin-top: 4px;">
                Remove vertex visualization
            </div>
        </div>
        </div>
        <!-- End Edit Tab -->


    <div class="selection-info">
        <h3>Selection</h3>
        <div id="selection-status" class="no-selection">Nothing selected</div>
    </div>

    <div id="axis-indicator">
        <div class="axis-title">SCENE AXIS (XY-Plane)</div>
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <marker id="arrow-head-x" orient="auto" markerWidth="6" markerHeight="6" refX="4" refY="3">
                    <path d="M0,0 L6,3 L0,6 Z" fill="#ff0000" />
                </marker>
                <marker id="arrow-head-y" orient="auto" markerWidth="6" markerHeight="6" refX="4" refY="3">
                    <path d="M0,0 L6,3 L0,6 Z" fill="#00ff00" />
                </marker>
                <marker id="arrow-head-z" orient="auto" markerWidth="6" markerHeight="6" refX="4" refY="3">
                    <path d="M0,0 L6,3 L0,6 Z" fill="#0000ff" />
                </marker>
            </defs>
            <circle cx="50" cy="50" r="42" stroke="rgba(255,255,255,0.08)" stroke-width="1" fill="rgba(0,0,0,0.15)" />
            <!-- X axis (Red) = Right/East -->
            <line x1="50" y1="50" x2="88" y2="50" stroke="#ff0000" stroke-width="3" marker-end="url(#arrow-head-x)" />
            <!-- Y axis (Green) = Up/North -->
            <line x1="50" y1="50" x2="50" y2="14" stroke="#00ff00" stroke-width="3" marker-end="url(#arrow-head-y)" />
            <!-- Z axis (Blue) = Toward camera/Depth (shown as small circle) -->
            <circle cx="50" cy="50" r="8" stroke="#0000ff" stroke-width="3" fill="none" />
            <circle cx="50" cy="50" r="2" fill="#0000ff" />
            <text x="90" y="55" fill="#ff0000" font-size="14" font-weight="bold">+X (East)</text>
            <text x="54" y="12" fill="#00ff00" font-size="14" font-weight="bold">+Y (North)</text>
            <text x="50" y="70" fill="#0000ff" font-size="10" text-anchor="middle">+Z (Up)</text>
        </svg>
        <div class="axis-caption">
            <span><span class="legend-dot" style="background:#ff0000;"></span>X=East</span>
            <span><span class="legend-dot" style="background:#00ff00;"></span>Y=North</span>
            <span><span class="legend-dot" style="background:#0000ff;"></span>Z=Depth</span>
        </div>
    </div>

    <div id="extrusion-panel">
        <h3>Face Extrusion</h3>

        <div class="slider-group">
            <label>Depth <span class="slider-value" id="depth-value">0.50</span></label>
            <input type="range" id="depth-slider" min="-2" max="2" step="0.01" value="0.5">
            <div style="font-size: 10px; color: #666;">Negative = inward/punch-through</div>
        </div>

        <div class="slider-group">
            <label>Scale (Taper) <span class="slider-value" id="scale-value">1.00</span></label>
            <input type="range" id="scale-slider" min="0.1" max="2" step="0.01" value="1">
            <div style="font-size: 10px; color: #666;">< 1.0 = narrowing, > 1.0 = widening</div>
        </div>

        <div class="slider-group">
            <label>Rotation <span class="slider-value" id="rotation-value">0Ã‚Â°</span></label>
            <input type="range" id="rotation-slider" min="-180" max="180" step="1" value="0">
            <div style="font-size: 10px; color: #666;">Twist the extrusion</div>
        </div>

        <div class="extrusion-buttons">
            <button id="apply-extrusion-btn" style="background: #059669;">Apply</button>
            <button id="cancel-extrusion-btn" style="background: #dc2626;">Cancel</button>
        </div>
    </div>

    <!-- Bevel panel removed -->

    <div class="info" style="left: auto; right: 20px; bottom: 20px;">
        <div><strong>Controls:</strong></div>
        <div>â€¢ Double Click: Select object</div>
        <div>â€¢ Single Click: Smart select</div>
        <div>â€¢ Left Drag: Orbit</div>
        <div>â€¢ Right Drag: Pan</div>
        <div>â€¢ Scroll: Zoom</div>
        <div>â€¢ E: Extrude face</div>
        <div>â€¢ ESC: Deselect</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { Line2 } from 'three/addons/lines/Line2.js';
        import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
        import { LineGeometry } from 'three/addons/lines/LineGeometry.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { MeshEditSession, applyEdgeBevelByVertices, createIndexedGeometryFromTriangles } from './meshTopology.js';

        let scene, camera, renderer, objects = [], controls, transformGizmo;
        let raycaster, mouse;
        let selectedObject = null;
        let selectedFace = null;
        let selectedEdge = null;
        let selectedVertex = null;
        let selectedVertices = []; // Array for multi-selection (shift+click)
        let selectedFaces = []; // Array for multi-face selection (box select)
        let isDraggingGizmo = false;
        let draggedAxis = null;
        let dragStartPos = new THREE.Vector3();
        let objectStartPos = new THREE.Vector3();
        let lastClickTime = 0; // For double-click detection
        const DOUBLE_CLICK_TIME = 300; // ms
        let accumulatedMovement = new THREE.Vector3();
        let transformMode = 'translate';
        let selectionMode = 'object'; // object, face, edge, vertex
        let useNormalAlignment = false; // Toggle between world and normal-aligned gizmo

        // Box selection state
        let boxSelectActive = false; // True while B key is held
        let boxSelectStart = null; // { x, y } screen coordinates
        let boxSelectCurrent = null; // { x, y } screen coordinates
        let boxSelectionCanvas = null; // Canvas overlay for drawing selection box

        // Symmetry mode
        let symmetryEnabled = false;
        let symmetryAxis = 'x'; // x, y, or z
        let symmetryPlane = null; // Visual plane indicator

        // Extrusion state
        let isExtruding = false;
        let extrusionData = null; // Stores data during active extrusion

        // Undo/Redo history
        let undoHistory = [];
        let redoHistory = [];
        const MAX_HISTORY = 50;

        // Camera mode
        let isOrthographic = false;
        let extrusionPreviewMesh = null; // Preview mesh for real-time extrusion
        let extrusionPreviewLines = null; // Wireframe lines for extrusion preview
        let extrusionPreviewPoints = null; // Vertex markers for extrusion preview

        // Grid size (no longer using slider)
        let currentGridSize = 0.1;

        // Saved camera state for 3D view
        let saved3DView = {
            theta: 0,
            phi: Math.PI / 4,
            radius: 5,
            target: new THREE.Vector3(0, 0, 0)
        };

        // Cut tool state
        let cutToolActive = false;
        let cutDistance = 0; // Distance offset from the edge
        let cutPlaneHelper = null;
        let cutKeepSide = 1; // 1 = positive side, -1 = negative side

        let bevelData = null; // Stores data during active bevel
        let bevelPreviewMesh = null; // Preview mesh for real-time bevel

        // Visual helpers for selection
        let faceHighlight = null;
        let edgeHighlight = null;

        const AXIS_COLOR_HEX = {
            x: '#ff0000',
            y: '#00ff00',
            z: '#0000ff'
        };

        const GIZMO_AXIS_BASE_VECTORS = {
            x: new THREE.Vector3(1, 0, 0),
            y: new THREE.Vector3(0, 1, 0),
            z: new THREE.Vector3(0, 0, 1)
        };

        // Offset distance for gizmo positioning (along face normal)
        // Very small offset to keep gizmo close to selection
        const GIZMO_FACE_OFFSET = 0.2;

        // Grid snapping function
        function snapToGrid(value, gridSize) {
            return Math.round(value / gridSize) * gridSize;
        }

        function applyGridSnap(movement) {
            const gridSnapEnabled = document.getElementById('grid-snap-checkbox').checked;
            if (!gridSnapEnabled) return movement;

            const gridSize = currentGridSize;
            return new THREE.Vector3(
                snapToGrid(movement.x, gridSize),
                snapToGrid(movement.y, gridSize),
                snapToGrid(movement.z, gridSize)
            );
        }
        let vertexHighlight = null;
        let vertexHelpers = []; // Array to store vertex visualization cubes

        // ==================== BOX SELECTION FUNCTIONS ====================

        function clearBoxSelectionCanvas() {
            if (!boxSelectionCanvas) return;
            const ctx = boxSelectionCanvas.getContext('2d');
            ctx.clearRect(0, 0, boxSelectionCanvas.width, boxSelectionCanvas.height);
        }

        function drawBoxSelection() {
            if (!boxSelectStart || !boxSelectCurrent) return;

            const ctx = boxSelectionCanvas.getContext('2d');
            ctx.clearRect(0, 0, boxSelectionCanvas.width, boxSelectionCanvas.height);

            const x = Math.min(boxSelectStart.x, boxSelectCurrent.x);
            const y = Math.min(boxSelectStart.y, boxSelectCurrent.y);
            const width = Math.abs(boxSelectCurrent.x - boxSelectStart.x);
            const height = Math.abs(boxSelectCurrent.y - boxSelectStart.y);

            // Draw selection rectangle
            ctx.strokeStyle = 'rgba(102, 126, 234, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(x, y, width, height);

            // Fill with semi-transparent color
            ctx.fillStyle = 'rgba(102, 126, 234, 0.1)';
            ctx.fillRect(x, y, width, height);
        }

        function performBoxSelection() {
            if (!boxSelectStart || !boxSelectCurrent || !selectedObject) return;

            const minX = Math.min(boxSelectStart.x, boxSelectCurrent.x);
            const maxX = Math.max(boxSelectStart.x, boxSelectCurrent.x);
            const minY = Math.min(boxSelectStart.y, boxSelectCurrent.y);
            const maxY = Math.max(boxSelectStart.y, boxSelectCurrent.y);

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            if (selectionMode === 'face' && geometry.index) {
                // Box select faces - clear both single and multi selection
                selectedFace = null;
                selectedFaces = [];
                const indexArray = geometry.index.array;

                for (let i = 0; i < indexArray.length; i += 3) {
                    const v1 = indexArray[i];
                    const v2 = indexArray[i + 1];
                    const v3 = indexArray[i + 2];

                    // Get world positions of all 3 vertices
                    const pos1 = new THREE.Vector3().fromBufferAttribute(positionAttr, v1);
                    const pos2 = new THREE.Vector3().fromBufferAttribute(positionAttr, v2);
                    const pos3 = new THREE.Vector3().fromBufferAttribute(positionAttr, v3);

                    selectedObject.localToWorld(pos1);
                    selectedObject.localToWorld(pos2);
                    selectedObject.localToWorld(pos3);

                    // Project to screen coordinates
                    const screen1 = pos1.project(camera);
                    const screen2 = pos2.project(camera);
                    const screen3 = pos3.project(camera);

                    const sx1 = (screen1.x + 1) / 2 * window.innerWidth;
                    const sy1 = (1 - screen1.y) / 2 * window.innerHeight;
                    const sx2 = (screen2.x + 1) / 2 * window.innerWidth;
                    const sy2 = (1 - screen2.y) / 2 * window.innerHeight;
                    const sx3 = (screen3.x + 1) / 2 * window.innerWidth;
                    const sy3 = (1 - screen3.y) / 2 * window.innerHeight;

                    // Check if ALL 3 vertices are inside the box
                    const inside = (sx, sy) => sx >= minX && sx <= maxX && sy >= minY && sy <= maxY;

                    if (inside(sx1, sy1) && inside(sx2, sy2) && inside(sx3, sy3)) {
                        selectedFaces.push({ indices: [v1, v2, v3], faceIndex: i / 3 });
                    }
                }

                console.log(`ðŸ“¦ Selected ${selectedFaces.length} faces`);
                updateFaceHighlights();

            } else if (selectionMode === 'vertex') {
                // Box select vertices - clear both single and multi selection
                selectedVertex = null;
                selectedVertices = [];

                for (let i = 0; i < positionAttr.count; i++) {
                    const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                    selectedObject.localToWorld(pos);

                    // Project to screen
                    const screen = pos.project(camera);
                    const sx = (screen.x + 1) / 2 * window.innerWidth;
                    const sy = (1 - screen.y) / 2 * window.innerHeight;

                    if (sx >= minX && sx <= maxX && sy >= minY && sy <= maxY) {
                        selectedVertices.push({ index: i, worldPos: pos.clone() });
                    }
                }

                console.log(`ðŸ“¦ Selected ${selectedVertices.length} vertices`);
                updateVertexHighlights();
            }
        }

        // Preview box selection with RED highlighting during drag
        let boxSelectPreviewFaces = [];
        let boxSelectPreviewVertices = [];

        function previewBoxSelection() {
            if (!boxSelectStart || !boxSelectCurrent || !selectedObject) {
                console.log('âš ï¸ Preview check failed:', {
                    hasStart: !!boxSelectStart,
                    hasCurrent: !!boxSelectCurrent,
                    hasObject: !!selectedObject
                });
                return;
            }

            const minX = Math.min(boxSelectStart.x, boxSelectCurrent.x);
            const maxX = Math.max(boxSelectStart.x, boxSelectCurrent.x);
            const minY = Math.min(boxSelectStart.y, boxSelectCurrent.y);
            const maxY = Math.max(boxSelectStart.y, boxSelectCurrent.y);

            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            console.log('ðŸ“¦ Box dimensions:', { minX, maxX, minY, maxY, width: boxWidth, height: boxHeight });

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            // Clear previous preview
            boxSelectPreviewFaces = [];
            boxSelectPreviewVertices = [];

            // ALWAYS select vertices first (vertex-centric workflow)
            console.log('ðŸ” Checking vertices in box');
            const selectedVertexSet = new Set();

            for (let i = 0; i < positionAttr.count; i++) {
                const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                selectedObject.localToWorld(pos);

                const screen = pos.project(camera);
                const sx = (screen.x + 1) / 2 * window.innerWidth;
                const sy = (1 - screen.y) / 2 * window.innerHeight;

                if (sx >= minX && sx <= maxX && sy >= minY && sy <= maxY) {
                    boxSelectPreviewVertices.push(i);
                    selectedVertexSet.add(i);
                }
            }

            console.log(`âœ… Found ${boxSelectPreviewVertices.length} vertices inside box`);

            // Auto-select faces where ALL vertices are selected
            // Group coplanar triangles into quad faces
            if (geometry.index && selectedVertexSet.size > 0) {
                const indexArray = geometry.index.array;
                const trianglesWithAllVertices = [];

                // First, find all triangles where all vertices are selected
                for (let i = 0; i < indexArray.length; i += 3) {
                    const v1 = indexArray[i];
                    const v2 = indexArray[i + 1];
                    const v3 = indexArray[i + 2];

                    if (selectedVertexSet.has(v1) && selectedVertexSet.has(v2) && selectedVertexSet.has(v3)) {
                        // Calculate triangle normal
                        const p1 = new THREE.Vector3().fromBufferAttribute(positionAttr, v1);
                        const p2 = new THREE.Vector3().fromBufferAttribute(positionAttr, v2);
                        const p3 = new THREE.Vector3().fromBufferAttribute(positionAttr, v3);

                        const edge1 = new THREE.Vector3().subVectors(p2, p1);
                        const edge2 = new THREE.Vector3().subVectors(p3, p1);
                        const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                        trianglesWithAllVertices.push({
                            indices: [v1, v2, v3],
                            faceIndex: i / 3,
                            normal: normal,
                            processed: false
                        });
                    }
                }

                // Group coplanar triangles that share vertices
                const quadFaces = [];
                const normalThreshold = 0.99; // Triangles must be nearly coplanar

                for (let i = 0; i < trianglesWithAllVertices.length; i++) {
                    if (trianglesWithAllVertices[i].processed) continue;

                    const tri1 = trianglesWithAllVertices[i];
                    tri1.processed = true;

                    // Start a new quad face with this triangle
                    let quadVertices = new Set(tri1.indices);
                    const faceTriangles = [tri1];

                    // Find other coplanar triangles that share vertices
                    for (let j = i + 1; j < trianglesWithAllVertices.length; j++) {
                        if (trianglesWithAllVertices[j].processed) continue;

                        const tri2 = trianglesWithAllVertices[j];

                        // Check if triangles are coplanar
                        const dotProduct = Math.abs(tri1.normal.dot(tri2.normal));
                        if (dotProduct < normalThreshold) continue;

                        // Check if triangles share vertices
                        const sharedVertices = tri2.indices.filter(idx => quadVertices.has(idx));
                        if (sharedVertices.length >= 2) { // Share an edge
                            tri2.processed = true;
                            faceTriangles.push(tri2);
                            tri2.indices.forEach(idx => quadVertices.add(idx));
                        }
                    }

                    // Create a face from all grouped triangles
                    const allVertexIndices = Array.from(quadVertices);
                    boxSelectPreviewFaces.push({
                        vertexIndices: allVertexIndices,
                        indices: allVertexIndices,  // Keep for backwards compatibility
                        faceIndex: tri1.faceIndex,
                        triangleCount: faceTriangles.length,
                        normal: tri1.normal
                    });
                }

                console.log(`âœ… Auto-selected ${boxSelectPreviewFaces.length} quad faces from ${trianglesWithAllVertices.length} triangles`);
            }

            // Update preview visuals
            updateVertexPreviewColors();
            if (boxSelectPreviewFaces.length > 0) {
                updateBoxSelectionPreview();
            }
        }

        // Multi-face highlight meshes (for box selection)
        let multiFaceHighlights = [];
        let boxPreviewHighlights = [];

        function updateFaceHighlights() {
            // Clear existing multi-face highlights
            multiFaceHighlights.forEach(highlight => {
                scene.remove(highlight);
                highlight.geometry?.dispose();
                highlight.material?.dispose();
            });
            multiFaceHighlights = [];

            if (selectedFaces.length === 0) {
                return;
            }

            // Create a highlight for each selected face
            selectedFaces.forEach(faceData => {
                const { indices } = faceData;
                if (indices.length < 3) return;

                const positionAttr = selectedObject.geometry.attributes.position;
                const vertices = indices.map(idx =>
                    new THREE.Vector3().fromBufferAttribute(positionAttr, idx)
                );

                // Create triangle geometry
                const highlightGeom = new THREE.BufferGeometry();
                const positions = [];
                vertices.forEach(v => positions.push(v.x, v.y, v.z));
                highlightGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                highlightGeom.setIndex([0, 1, 2]);

                const highlightMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000, // Red for selected faces
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const highlightMesh = new THREE.Mesh(highlightGeom, highlightMat);
                highlightMesh.renderOrder = 999;

                // Copy the object's transformation
                highlightMesh.position.copy(selectedObject.position);
                highlightMesh.rotation.copy(selectedObject.rotation);
                highlightMesh.scale.copy(selectedObject.scale);

                scene.add(highlightMesh);
                multiFaceHighlights.push(highlightMesh);
            });

            console.log(`âœ… Created ${multiFaceHighlights.length} face highlights`);
        }

        function updateVertexHighlights() {
            // Update vertex helper colors: RED for selected, YELLOW for unselected
            console.log('ðŸŽ¨ updateVertexHighlights called');
            console.log('selectedVertices:', selectedVertices);
            const selectedIndices = selectedVertices.map(v => v.index);
            console.log('selectedIndices:', selectedIndices);

            let redCount = 0;
            let yellowCount = 0;
            vertexHelpers.forEach(helper => {
                // Check if ANY of the indices at this position are selected
                const helperIndices = helper.userData.vertexIndices || [helper.userData.vertexIndex];
                const isSelected = helperIndices.some(idx => selectedIndices.includes(idx));
                helper.material.color.setHex(isSelected ? 0xff0000 : 0xffff00);
                if (isSelected) redCount++;
                else yellowCount++;
            });
            console.log(`âœ… Set ${redCount} vertices to RED, ${yellowCount} to YELLOW`);
        }

        // Preview highlighting functions for box selection drag
        function updateBoxSelectionPreview() {
            // Clear existing preview highlights
            boxPreviewHighlights.forEach(highlight => {
                scene.remove(highlight);
                highlight.geometry?.dispose();
                highlight.material?.dispose();
            });
            boxPreviewHighlights = [];

            if (boxSelectPreviewFaces.length === 0) {
                console.log('âš ï¸ No preview faces to highlight');
                return;
            }

            console.log('ðŸŽ¨ Creating preview highlights for', boxSelectPreviewFaces.length, 'faces');

            // Create RED preview highlights for faces in the box
            boxSelectPreviewFaces.forEach(faceData => {
                const { indices } = faceData;
                if (indices.length < 3) return;

                const positionAttr = selectedObject.geometry.attributes.position;
                const vertices = indices.map(idx =>
                    new THREE.Vector3().fromBufferAttribute(positionAttr, idx)
                );

                const highlightGeom = new THREE.BufferGeometry();
                const positions = [];
                vertices.forEach(v => positions.push(v.x, v.y, v.z));
                highlightGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                highlightGeom.setIndex([0, 1, 2]);

                const highlightMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000, // RED for preview
                    transparent: true,
                    opacity: 0.6,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                const highlightMesh = new THREE.Mesh(highlightGeom, highlightMat);
                highlightMesh.renderOrder = 999;

                highlightMesh.position.copy(selectedObject.position);
                highlightMesh.rotation.copy(selectedObject.rotation);
                highlightMesh.scale.copy(selectedObject.scale);

                scene.add(highlightMesh);
                boxPreviewHighlights.push(highlightMesh);
            });
        }

        function updateVertexPreviewColors() {
            // Update vertex helper colors: RED for preview, YELLOW for others
            vertexHelpers.forEach(helper => {
                // Check if ANY of the indices at this position are in preview
                const helperIndices = helper.userData.vertexIndices || [helper.userData.vertexIndex];
                const isInPreview = helperIndices.some(idx => boxSelectPreviewVertices.includes(idx));
                helper.material.color.setHex(isInPreview ? 0xff0000 : 0xffff00);
            });
        }

        function clearBoxSelectionPreview() {
            // Clear preview highlights
            boxPreviewHighlights.forEach(highlight => {
                scene.remove(highlight);
                highlight.geometry?.dispose();
                highlight.material?.dispose();
            });
            boxPreviewHighlights = [];
            boxSelectPreviewFaces = [];
            boxSelectPreviewVertices = [];

            // Don't reset vertex colors here - let updateVertexHighlights() handle final colors
        }

        // ==================== END BOX SELECTION FUNCTIONS ====================

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);

            // ===================================================================
            // Camera setup - MATCHES GAME COORDINATE SYSTEM
            // See DEVELOPMENT_NOTES.md "Game Camera System" for full documentation
            // XY-plane at Z=0, camera at positive Z looking down
            // +Y = North (screen up), +X = East (screen right), +Z = depth
            // ===================================================================
            const frustumSize = 28;
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2, frustumSize * aspect / 2,
                frustumSize / 2, frustumSize / -2, 0.1, 1000
            );
            camera.position.set(0, 0, 10); // Above the XY plane
            camera.lookAt(0, 0, 0); // Looking at origin
            camera.up.set(0, 1, 0); // +Y is screen up (North), +X is screen right (East)
            // Note: Camera tilt removed for clearer orthographic view
            camera.userData.frustumSize = frustumSize; // Store for zoom operations
            isOrthographic = true; // Start in orthographic mode

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Box selection canvas overlay
            boxSelectionCanvas = document.createElement('canvas');
            boxSelectionCanvas.style.position = 'absolute';
            boxSelectionCanvas.style.top = '0';
            boxSelectionCanvas.style.left = '0';
            boxSelectionCanvas.style.pointerEvents = 'none'; // Don't block mouse events
            boxSelectionCanvas.style.zIndex = '1000';
            boxSelectionCanvas.width = window.innerWidth;
            boxSelectionCanvas.height = window.innerHeight;
            document.getElementById('canvas-container').appendChild(boxSelectionCanvas);

            // Grid helper on XY plane (matches game coordinate system)
            const gridHelper = new THREE.GridHelper(10, 100, 0x00ff00, 0x004400);
            gridHelper.rotation.x = Math.PI / 2; // Rotate to lay flat on XY plane
            scene.add(gridHelper);

            // Axes helper (Red=+X/East, Green=+Y/North, Blue=+Z/Up)
            // No rotation - shows true XYZ axes aligned with XY plane grid
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Create initial cube
            createCube(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            // Orbit Controls
            setupOrbitControls();
            
            // Transform Gizmo
            createTransformGizmo();
            
            // Raycaster for selection
            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 0.1; // Make it easier to select edges
            mouse = new THREE.Vector2();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('mousedown', onCanvasMouseDown);
            renderer.domElement.addEventListener('mousemove', onCanvasMouseMove);
            renderer.domElement.addEventListener('mouseup', onCanvasMouseUp);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Selection mode buttons removed - now using smart selection
            // document.getElementById('object-mode-btn').addEventListener('click', () => setSelectionMode('object'));
            // document.getElementById('face-mode-btn').addEventListener('click', () => setSelectionMode('face'));
            // document.getElementById('edge-mode-btn').addEventListener('click', () => setSelectionMode('edge'));
            // document.getElementById('vertex-mode-btn').addEventListener('click', () => setSelectionMode('vertex'));
            // Transform mode buttons removed - use control cube instead
            // document.getElementById('select-btn').addEventListener('click', () => setTransformMode('select'));
            // document.getElementById('translate-btn').addEventListener('click', () => setTransformMode('translate'));
            // document.getElementById('rotate-btn').addEventListener('click', () => setTransformMode('rotate'));
            // document.getElementById('scale-btn').addEventListener('click', () => setTransformMode('scale'));
            document.getElementById('add-cube-btn').addEventListener('click', addCube);
            document.getElementById('add-cylinder-btn').addEventListener('click', addCylinder);
            document.getElementById('add-cone-btn').addEventListener('click', addCone);
            document.getElementById('delete-btn').addEventListener('click', deleteSelected);
            document.getElementById('front-btn').addEventListener('click', () => setCameraView('front'));
            document.getElementById('side-btn').addEventListener('click', () => setCameraView('side'));
            document.getElementById('top-btn').addEventListener('click', () => setCameraView('top'));
            document.getElementById('3d-btn').addEventListener('click', () => setCameraView('3d'));
            document.getElementById('ortho-btn').addEventListener('click', () => {
                toggleCameraMode('orthographic');
                document.getElementById('ortho-btn').classList.add('active');
                document.getElementById('persp-btn').classList.remove('active');
            });
            document.getElementById('persp-btn').addEventListener('click', () => {
                toggleCameraMode('perspective');
                document.getElementById('persp-btn').classList.add('active');
                document.getElementById('ortho-btn').classList.remove('active');
            });
            document.getElementById('center-object-btn').addEventListener('click', centerSelectedObject);
            document.getElementById('cut-tool-btn').addEventListener('click', toggleCutTool);

            // Cut distance slider
            const cutDistanceSlider = document.getElementById('cut-distance-slider');
            const cutDistanceValue = document.getElementById('cut-distance-value');
            cutDistanceSlider.addEventListener('input', () => {
                cutDistance = parseFloat(cutDistanceSlider.value);
                cutDistanceValue.textContent = cutDistance.toFixed(2);
                if (cutToolActive) {
                    updateCutPlanePreview();
                }
            });

            // Flip cut side button
            document.getElementById('flip-cut-side-btn').addEventListener('click', () => {
                if (cutToolActive) {
                    cutKeepSide *= -1;
                    console.log('Cut side flipped to:', cutKeepSide === 1 ? 'Positive' : 'Negative');
                    updateCutPlanePreview();
                }
            });
            document.getElementById('reset-btn').addEventListener('click', deselectAll);
            document.getElementById('extrude-btn').addEventListener('click', startFaceExtrusion);
            // Bevel removed - not working properly
            document.getElementById('mirror-btn').addEventListener('click', mirrorAcrossFace);

            // Symmetry mode event listeners - REMOVED (UI elements were removed)
            // Disable symmetry functionality since UI was removed
            symmetryEnabled = false;

            document.getElementById('export-geo-btn').addEventListener('click', exportGeometry);
            document.getElementById('export-vicvector-btn').addEventListener('click', exportToVicVector);
            document.getElementById('export-stl-btn').addEventListener('click', exportSTL);
            document.getElementById('import-stl-btn').addEventListener('click', importSTL);
            document.getElementById('show-all-points-btn').addEventListener('click', showAllPoints);
            document.getElementById('hide-points-btn').addEventListener('click', hideAllPoints);

            // Grid snapping controls
            document.getElementById('grid-01').addEventListener('click', () => {
                currentGridSize = 0.1;
                document.getElementById('grid-size-value').textContent = '0.10';
            });
            document.getElementById('grid-025').addEventListener('click', () => {
                currentGridSize = 0.25;
                document.getElementById('grid-size-value').textContent = '0.25';
            });
            document.getElementById('grid-05').addEventListener('click', () => {
                currentGridSize = 0.5;
                document.getElementById('grid-size-value').textContent = '0.50';
            });
            document.getElementById('grid-1').addEventListener('click', () => {
                currentGridSize = 1.0;
                document.getElementById('grid-size-value').textContent = '1.00';
            });

            // Extrusion panel controls
            document.getElementById('depth-slider').addEventListener('input', () => {
                updateSliderValues();
                createExtrusionPreview();
            });
            document.getElementById('scale-slider').addEventListener('input', () => {
                updateSliderValues();
                createExtrusionPreview();
            });
            document.getElementById('rotation-slider').addEventListener('input', () => {
                updateSliderValues();
                createExtrusionPreview();
            });
            document.getElementById('apply-extrusion-btn').addEventListener('click', applyExtrusion);
            document.getElementById('cancel-extrusion-btn').addEventListener('click', cancelExtrusion);

            // Bevel panel controls
            // Bevel event listeners removed

            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const targetTab = tab.dataset.tab;

                    // Update tab buttons
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Update tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(targetTab).classList.add('active');

                    // Handle preview/edit mode transitions
                    if (targetTab === 'preview-tab') {
                        // Entering preview mode
                        transformGizmo.visible = false;
                        updateGizmoAxisLabels();
                        // Hide edge highlight in preview mode
                        if (edgeHighlight) {
                            edgeHighlight.userData.wasVisibleBeforePreview = edgeHighlight.visible;
                            edgeHighlight.visible = false;
                        }
                        if (selectedObject) {
                            applyPreviewSettings();
                        }
                    } else if (targetTab === 'edit-tab') {
                        // Returning to edit mode - restore original material
                        if (selectedObject) {
                            restoreEditMaterial();
                            transformGizmo.visible = true;
                            alignTransformGizmo();
                        }
                        // Restore edge highlight visibility
                        if (edgeHighlight && edgeHighlight.userData.wasVisibleBeforePreview) {
                            edgeHighlight.visible = true;
                        }
                        updateGizmoAxisLabels();
                    }
                });
            });

            // Preview controls - COMMENTED OUT (Preview tab removed)
            // document.querySelectorAll('input[name="render-mode"]').forEach(radio => {
            //     radio.addEventListener('change', updatePreviewVisibility);
            // });
            // ... (all preview event listeners removed)

            // Create visual helpers
            createSelectionHelpers();
            
            animate();
        }
        
        // New: Store face and edge selection helpers
        let faceSelectionHelpers = [];
        let edgeSelectionHelpers = [];

        function createSelectionHelpers() {
            // Face highlight (semi-transparent plane)
            // We offset it slightly from the face to avoid z-fighting (coplanar flickering)
            const faceGeom = new THREE.PlaneGeometry(1, 1);
            const faceMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false // Prevents z-fighting
            });
            faceHighlight = new THREE.Mesh(faceGeom, faceMat);
            faceHighlight.renderOrder = 999; // Render on top
            faceHighlight.visible = false;
            scene.add(faceHighlight);
            
            // Edge highlight - TWO CUBES at the edge endpoints (matching vertex helper style)
            edgeHighlight = new THREE.Group();

            const cubeGeom = new THREE.BoxGeometry(0.06, 0.06, 0.06); // Small cubes like vertex helpers
            const cubeMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, // Red when selected
                depthTest: false, // Always visible
                transparent: true,
                opacity: 0.9
            });

            const cube1 = new THREE.Mesh(cubeGeom, cubeMat);
            const cube2 = new THREE.Mesh(cubeGeom.clone(), cubeMat.clone());

            cube1.renderOrder = 1000;
            cube2.renderOrder = 1000;

            edgeHighlight.add(cube1);
            edgeHighlight.add(cube2);
            edgeHighlight.userData.sphere1 = cube1; // Keep property name for compatibility
            edgeHighlight.userData.sphere2 = cube2;
            edgeHighlight.visible = false;
            scene.add(edgeHighlight);
            
            // Vertex highlight (cube - matching vertex helper style)
            const vertexHighlightGeom = new THREE.BoxGeometry(0.06, 0.06, 0.06);
            const vertexHighlightMat = new THREE.MeshBasicMaterial({
                color: 0xff0000, // Red when selected
                depthTest: false,
                transparent: true,
                opacity: 0.9
            });
            vertexHighlight = new THREE.Mesh(vertexHighlightGeom, vertexHighlightMat);
            vertexHighlight.renderOrder = 1000;
            vertexHighlight.visible = false;
            scene.add(vertexHighlight);
            
            console.log('Selection helpers created - edges now show TWO SPHERES at endpoints');
        }

        // New: Update face and edge selection helpers (yellow squares)
        function updateFaceEdgeSelectionHelpers(object) {
            // Clear existing helpers
            faceSelectionHelpers.forEach(helper => {
                scene.remove(helper);
                helper.geometry.dispose();
                helper.material.dispose();
            });
            faceSelectionHelpers = [];

            edgeSelectionHelpers.forEach(helper => {
                scene.remove(helper);
                helper.geometry.dispose();
                helper.material.dispose();
            });
            edgeSelectionHelpers = [];

            if (!object || !object.geometry || selectionMode === 'object') return;

            const geometry = object.geometry;
            const positions = geometry.attributes.position;

            // Create helpers based on selection mode
            if (selectionMode === 'face') {
                // Create yellow squares at face centers
                const faceHelperGeom = new THREE.BoxGeometry(0.1, 0.1, 0.01);
                const faceHelperMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false
                });

                // Process faces
                const faceCount = geometry.index ? geometry.index.count / 3 : positions.count / 3;

                for (let i = 0; i < faceCount; i++) {
                    let a, b, c;

                    if (geometry.index) {
                        const indices = geometry.index.array;
                        a = indices[i * 3];
                        b = indices[i * 3 + 1];
                        c = indices[i * 3 + 2];
                    } else {
                        a = i * 3;
                        b = i * 3 + 1;
                        c = i * 3 + 2;
                    }

                    // Get vertices
                    const v1 = new THREE.Vector3().fromBufferAttribute(positions, a);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positions, b);
                    const v3 = new THREE.Vector3().fromBufferAttribute(positions, c);

                    // Calculate face center
                    const center = new THREE.Vector3()
                        .addVectors(v1, v2)
                        .add(v3)
                        .divideScalar(3);

                    // Transform to world space
                    center.applyMatrix4(object.matrixWorld);

                    // Calculate face normal for orientation
                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                    const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                    normal.transformDirection(object.matrixWorld);

                    // Create helper square
                    const helper = new THREE.Mesh(faceHelperGeom, faceHelperMat.clone());
                    helper.position.copy(center);

                    // Align with face normal
                    helper.lookAt(center.clone().add(normal));

                    // Store face index for selection
                    helper.userData.faceIndex = i;
                    helper.userData.parentObject = object;
                    helper.userData.isSelectionHelper = true;
                    helper.userData.type = 'face';

                    helper.renderOrder = 1001;
                    scene.add(helper);
                    faceSelectionHelpers.push(helper);
                }
            } else if (selectionMode === 'edge') {
                // Create yellow squares at edge midpoints
                const edgeHelperGeom = new THREE.BoxGeometry(0.08, 0.08, 0.01);
                const edgeHelperMat = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false
                });

                // Track unique edges
                const edgeMap = new Map();
                const faceCount = geometry.index ? geometry.index.count / 3 : positions.count / 3;

                for (let i = 0; i < faceCount; i++) {
                    let a, b, c;

                    if (geometry.index) {
                        const indices = geometry.index.array;
                        a = indices[i * 3];
                        b = indices[i * 3 + 1];
                        c = indices[i * 3 + 2];
                    } else {
                        a = i * 3;
                        b = i * 3 + 1;
                        c = i * 3 + 2;
                    }

                    // Process each edge of the triangle
                    const edges = [[a, b], [b, c], [c, a]];

                    for (const [v1, v2] of edges) {
                        const key = v1 < v2 ? `${v1}-${v2}` : `${v2}-${v1}`;

                        if (!edgeMap.has(key)) {
                            const p1 = new THREE.Vector3().fromBufferAttribute(positions, v1);
                            const p2 = new THREE.Vector3().fromBufferAttribute(positions, v2);

                            // Calculate edge midpoint
                            const midpoint = new THREE.Vector3()
                                .addVectors(p1, p2)
                                .multiplyScalar(0.5);

                            // Transform to world space
                            midpoint.applyMatrix4(object.matrixWorld);
                            p1.applyMatrix4(object.matrixWorld);
                            p2.applyMatrix4(object.matrixWorld);

                            // Create helper square
                            const helper = new THREE.Mesh(edgeHelperGeom, edgeHelperMat.clone());
                            helper.position.copy(midpoint);

                            // Store edge data for selection
                            helper.userData.edgeIndices = [v1, v2];
                            helper.userData.edgeStart = p1;
                            helper.userData.edgeEnd = p2;
                            helper.userData.parentObject = object;
                            helper.userData.isSelectionHelper = true;
                            helper.userData.type = 'edge';

                            helper.renderOrder = 1001;
                            scene.add(helper);
                            edgeSelectionHelpers.push(helper);

                            edgeMap.set(key, true);
                        }
                    }
                }
            }
        }
        
        function updateVertexHelpers(object) {
            // Clear existing vertex helpers
            vertexHelpers.forEach(helper => {
                if (helper.parent === object) {
                    object.remove(helper);
                }
                helper.geometry.dispose();
                helper.material.dispose();
            });
            vertexHelpers = [];

            if (!object || !object.geometry) return;
            // Show vertices in vertex mode or when editing faces/edges
            if (selectionMode === 'object') return;

            const geometry = object.geometry;
            const positions = geometry.attributes.position;

            // Create small cubes at each vertex
            const vertexGeom = new THREE.BoxGeometry(0.03, 0.03, 0.03);
            const vertexMat = new THREE.MeshBasicMaterial({
                color: 0xffff00,  // YELLOW (unselected)
                transparent: true,
                opacity: 0.8,
                depthTest: false  // Always render on top
            });

            // Store unique vertices (avoid duplicates at same position)
            // Map stores: key -> {vertex, indices: [array of all indices at this position]}
            const uniqueVerts = new Map();
            const tolerance = 0.001;

            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );

                // Create a key for this vertex position
                const key = `${Math.round(vertex.x/tolerance)*tolerance}_${Math.round(vertex.y/tolerance)*tolerance}_${Math.round(vertex.z/tolerance)*tolerance}`;

                if (!uniqueVerts.has(key)) {
                    uniqueVerts.set(key, {vertex, indices: [i]});
                } else {
                    // Add this index to the existing position's array
                    uniqueVerts.get(key).indices.push(i);
                }
            }

            // Create helpers only for unique vertices
            uniqueVerts.forEach(({vertex, indices}) => {
                const helper = new THREE.Mesh(vertexGeom.clone(), vertexMat.clone());

                // Make helper a child of the object so it moves with it
                helper.position.copy(vertex);
                helper.userData.vertexIndices = indices; // Store ALL indices at this position
                helper.userData.vertexIndex = indices[0]; // Keep first index for backwards compatibility
                helper.userData.parentObject = object;
                helper.renderOrder = 1000; // Render on top of everything, including gizmo

                // Add as child so it follows the object transform
                object.add(helper);
                vertexHelpers.push(helper);
            });
        }

        function createCube(x, y, z) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshPhongMaterial({
                color: 0x7c3aed,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            
            // Add wireframe - we store a reference so we can update it later
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 })  // YELLOW edges
            );
            cube.add(line);
            
            // Add edge visualization (thicker lines for all edges, hidden by default)
            const edgeVisualization = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ 
                    color: 0x888888, 
                    linewidth: 1,
                    transparent: true,
                    opacity: 0.3
                })
            );
            cube.add(edgeVisualization);
            
            // Store references to wireframe and edge visualization for later updates
            cube.userData.wireframe = line;
            cube.userData.edgeVisualization = edgeVisualization;
            cube.userData.type = 'object';

            // Ensure geometry bounds are computed for raycasting
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            cube.updateMatrixWorld();

            scene.add(cube);
            objects.push(cube);

            return cube;
        }
        
        function createSphere(x, y, z) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x3aed7c,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(x, y, z);
            
            // Add wireframe - we store a reference so we can update it later
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges, 
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            sphere.add(line);
            
            // Store reference to wireframe for later updates
            sphere.userData.wireframe = line;
            sphere.userData.type = 'object';

            // Ensure geometry bounds are computed for raycasting
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            sphere.updateMatrixWorld();

            scene.add(sphere);
            objects.push(sphere);

            return sphere;
        }

        function createCylinder(x, y, z) {
            const sidesInput = document.getElementById('primitive-sides');
            const sides = sidesInput ? parseInt(sidesInput.value) : 8;

            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, sides);
            const material = new THREE.MeshPhongMaterial({
                color: 0x3aed7c,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.position.set(x, y, z);

            // Add wireframe - we store a reference so we can update it later
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            cylinder.add(line);

            // Store reference to wireframe for later updates
            cylinder.userData.wireframe = line;
            cylinder.userData.type = 'object';

            // Ensure geometry bounds are computed for raycasting
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            cylinder.updateMatrixWorld();

            scene.add(cylinder);
            objects.push(cylinder);

            return cylinder;
        }

        function createCone(x, y, z) {
            const sidesInput = document.getElementById('primitive-sides');
            const sides = sidesInput ? parseInt(sidesInput.value) : 8;

            const geometry = new THREE.ConeGeometry(0.5, 1, sides);
            const material = new THREE.MeshPhongMaterial({
                color: 0x3aed7c,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const cone = new THREE.Mesh(geometry, material);
            cone.position.set(x, y, z);

            // Add wireframe - we store a reference so we can update it later
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
            );
            cone.add(line);

            // Store reference to wireframe for later updates
            cone.userData.wireframe = line;
            cone.userData.type = 'object';

            // Ensure geometry bounds are computed for raycasting
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            cone.updateMatrixWorld();

            scene.add(cone);
            objects.push(cone);

            return cone;
        }

        function createAxisLabelSprite(text, color) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 72px "Segoe UI", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 14;
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.strokeText(text, canvas.width / 2, canvas.height / 2);
            ctx.fillStyle = color;
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            if (renderer) {
                texture.anisotropy = Math.min(4, renderer.capabilities.getMaxAnisotropy());
            }
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });

            const sprite = new THREE.Sprite(material);
            sprite.userData.aspect = canvas.height / canvas.width;
            sprite.renderOrder = 1000;
            return sprite;
        }
        
        function createTransformGizmo() {
            transformGizmo = new THREE.Group();
            transformGizmo.visible = false;
            
            // We'll store different gizmo types and switch between them
            transformGizmo.userData.gizmos = {};
            
            // === TRANSLATE GIZMO (Arrows) ===
            const translateGizmo = new THREE.Group();
            const gizmoScale = 0.6; // Smaller gizmo for better precision
            const arrowLength = 1.5 * gizmoScale;
            const arrowHeadLength = 0.3 * gizmoScale;
            const arrowHeadWidth = 0.2 * gizmoScale;
            const shaftRadius = 0.02 * gizmoScale;

            // X axis (red)
            const xArrowGeom = new THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);
            const xShaftGeom = new THREE.CylinderGeometry(shaftRadius, shaftRadius, arrowLength - arrowHeadLength, 8);
            
            const xArrowMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xArrow = new THREE.Mesh(xArrowGeom, xArrowMat);
            const xShaft = new THREE.Mesh(xShaftGeom, xArrowMat);
            
            xArrow.position.x = arrowLength;
            xArrow.rotation.z = -Math.PI / 2;
            xShaft.position.x = (arrowLength - arrowHeadLength) / 2;
            xShaft.rotation.z = Math.PI / 2;
            
            const xGroup = new THREE.Group();
            xGroup.add(xArrow);
            xGroup.add(xShaft);
            xGroup.userData.axis = 'x';
            translateGizmo.add(xGroup);
            
            // Y axis (green)
            const yArrowMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yArrow = new THREE.Mesh(xArrowGeom, yArrowMat);
            const yShaft = new THREE.Mesh(xShaftGeom, yArrowMat);
            
            yArrow.position.y = arrowLength;
            yShaft.position.y = (arrowLength - arrowHeadLength) / 2;
            
            const yGroup = new THREE.Group();
            yGroup.add(yArrow);
            yGroup.add(yShaft);
            yGroup.userData.axis = 'y';
            translateGizmo.add(yGroup);
            
            // Z axis (blue)
            const zArrowMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zArrow = new THREE.Mesh(xArrowGeom, zArrowMat);
            const zShaft = new THREE.Mesh(xShaftGeom, zArrowMat);
            
            zArrow.position.z = arrowLength;
            zArrow.rotation.x = Math.PI / 2;
            zShaft.position.z = (arrowLength - arrowHeadLength) / 2;
            zShaft.rotation.x = Math.PI / 2;
            
            const zGroup = new THREE.Group();
            zGroup.add(zArrow);
            zGroup.add(zShaft);
            zGroup.userData.axis = 'z';
            translateGizmo.add(zGroup);

            // Function to create the multi-function control cube
            const createControlCube = (scale = 1) => {
                const cubeSize = 0.25 * gizmoScale * scale;
                const cubeGeom = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

                // Create textures for each face
                const createFaceTexture = (text, bgColor, textColor = '#000000') => {
                    const faceCanvas = document.createElement('canvas');
                    faceCanvas.width = 128;
                    faceCanvas.height = 128;
                    const faceCtx = faceCanvas.getContext('2d');

                    // Background
                    faceCtx.fillStyle = bgColor;
                    faceCtx.fillRect(0, 0, 128, 128);

                    // Border
                    faceCtx.strokeStyle = '#333333';
                    faceCtx.lineWidth = 2;
                    faceCtx.strokeRect(1, 1, 126, 126);

                    // Text
                    faceCtx.fillStyle = textColor;
                    faceCtx.font = 'bold 48px Arial';
                    faceCtx.textAlign = 'center';
                    faceCtx.textBaseline = 'middle';
                    faceCtx.fillText(text, 64, 64);

                    return new THREE.CanvasTexture(faceCanvas);
                };

                // Create materials for each face
                const materials = [
                    new THREE.MeshBasicMaterial({ // Right face (+X)
                        map: createFaceTexture('R', '#ff9999'), // Rotate
                        transparent: true,
                        opacity: 0.9
                    }),
                    new THREE.MeshBasicMaterial({ // Left face (-X)
                        map: createFaceTexture('S', '#99ff99'), // Scale
                        transparent: true,
                        opacity: 0.9
                    }),
                    new THREE.MeshBasicMaterial({ // Top face (+Y)
                        map: createFaceTexture('N', '#ffaa44'), // Normal toggle
                        transparent: true,
                        opacity: 0.9
                    }),
                    new THREE.MeshBasicMaterial({ // Bottom face (-Y)
                        map: createFaceTexture('', '#666666'),
                        transparent: true,
                        opacity: 0.6
                    }),
                    new THREE.MeshBasicMaterial({ // Front face (+Z)
                        map: createFaceTexture('T', '#9999ff'), // Translate
                        transparent: true,
                        opacity: 0.9
                    }),
                    new THREE.MeshBasicMaterial({ // Back face (-Z)
                        map: createFaceTexture('E', '#ff66ff'), // Extrude
                        transparent: true,
                        opacity: 0.9
                    })
                ];

                const controlCube = new THREE.Mesh(cubeGeom, materials);
                controlCube.position.set(cubeSize * 1.5, cubeSize / 2, cubeSize * 1.5);
                controlCube.userData.axis = 'free'; // Default to free movement
                controlCube.userData.isCube = true;
                controlCube.userData.faces = {
                    rotate: 0,     // Right face (+X)
                    scale: 1,      // Left face (-X)
                    normal: 2,     // Top face (+Y) - toggle normal/world
                    translate: 4,  // Front face (+Z)
                    extrude: 5     // Back face (-Z)
                };
                return controlCube;
            };

            // Add control cube to translate gizmo
            translateGizmo.add(createControlCube());

            transformGizmo.userData.gizmos.translate = translateGizmo;
            
            // === ROTATE GIZMO (Circles) ===
            const rotateGizmo = new THREE.Group();
            const radius = 1.2;
            const segments = 64;
            
            // X rotation circle (red)
            const xCircleGeom = new THREE.TorusGeometry(radius, 0.02, 8, segments);
            const xCircleMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xCircle = new THREE.Mesh(xCircleGeom, xCircleMat);
            xCircle.rotation.y = Math.PI / 2;
            xCircle.userData.axis = 'x';
            rotateGizmo.add(xCircle);
            
            // Y rotation circle (green)
            const yCircleGeom = new THREE.TorusGeometry(radius, 0.02, 8, segments);
            const yCircleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yCircle = new THREE.Mesh(yCircleGeom, yCircleMat);
            yCircle.rotation.x = Math.PI / 2;
            yCircle.userData.axis = 'y';
            rotateGizmo.add(yCircle);
            
            // Z rotation circle (blue)
            const zCircleGeom = new THREE.TorusGeometry(radius, 0.02, 8, segments);
            const zCircleMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zCircle = new THREE.Mesh(zCircleGeom, zCircleMat);
            zCircle.userData.axis = 'z';
            rotateGizmo.add(zCircle);

            // Add control cube to rotate gizmo
            rotateGizmo.add(createControlCube());

            transformGizmo.userData.gizmos.rotate = rotateGizmo;
            
            // === SCALE GIZMO (Boxes) ===
            const scaleGizmo = new THREE.Group();
            const boxSize = 0.15;
            const boxGeom = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            
            // X scale handle (red)
            const xScaleMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const xScaleBox = new THREE.Mesh(boxGeom, xScaleMat);
            const xScaleShaft = new THREE.Mesh(xShaftGeom, xScaleMat);
            xScaleBox.position.x = arrowLength;
            xScaleShaft.position.x = arrowLength / 2;
            xScaleShaft.rotation.z = Math.PI / 2;
            const xScaleGroup = new THREE.Group();
            xScaleGroup.add(xScaleBox);
            xScaleGroup.add(xScaleShaft);
            xScaleGroup.userData.axis = 'x';
            scaleGizmo.add(xScaleGroup);
            
            // Y scale handle (green)
            const yScaleMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const yScaleBox = new THREE.Mesh(boxGeom, yScaleMat);
            const yScaleShaft = new THREE.Mesh(xShaftGeom, yScaleMat);
            yScaleBox.position.y = arrowLength;
            yScaleShaft.position.y = arrowLength / 2;
            const yScaleGroup = new THREE.Group();
            yScaleGroup.add(yScaleBox);
            yScaleGroup.add(yScaleShaft);
            yScaleGroup.userData.axis = 'y';
            scaleGizmo.add(yScaleGroup);
            
            // Z scale handle (blue)
            const zScaleMat = new THREE.MeshBasicMaterial({ color: 0x0000ff });
            const zScaleBox = new THREE.Mesh(boxGeom, zScaleMat);
            const zScaleShaft = new THREE.Mesh(xShaftGeom, zScaleMat);
            zScaleBox.position.z = arrowLength;
            zScaleShaft.position.z = arrowLength / 2;
            zScaleShaft.rotation.x = Math.PI / 2;
            const zScaleGroup = new THREE.Group();
            zScaleGroup.add(zScaleBox);
            zScaleGroup.add(zScaleShaft);
            zScaleGroup.userData.axis = 'z';
            scaleGizmo.add(zScaleGroup);

            // Add control cube to scale gizmo
            scaleGizmo.add(createControlCube());

            transformGizmo.userData.gizmos.scale = scaleGizmo;
            
            // === EDGE SCALE GIZMO (Single handle along edge direction) ===
            // Special gizmo for edges - only scales along the edge direction
            const edgeScaleGizmo = new THREE.Group();
            
            // Single yellow handle that points along the edge
            const edgeScaleMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const edgeScaleBox = new THREE.Mesh(boxGeom, edgeScaleMat);
            const edgeScaleShaft = new THREE.Mesh(xShaftGeom, edgeScaleMat);
            
            // Position along Y axis (we'll rotate to align with edge)
            edgeScaleBox.position.y = arrowLength;
            edgeScaleShaft.position.y = arrowLength / 2;
            
            const edgeScaleGroup = new THREE.Group();
            edgeScaleGroup.add(edgeScaleBox);
            edgeScaleGroup.add(edgeScaleShaft);
            edgeScaleGroup.userData.axis = 'edge'; // Special axis identifier
            edgeScaleGizmo.add(edgeScaleGroup);
            
            transformGizmo.userData.gizmos.edgeScale = edgeScaleGizmo;
            
            // Start with translate gizmo
            transformGizmo.add(translateGizmo);
            transformGizmo.userData.currentMode = 'translate';

            const axisLabels = {
                x: createAxisLabelSprite('X', AXIS_COLOR_HEX.x),
                y: createAxisLabelSprite('Y', AXIS_COLOR_HEX.y),
                z: createAxisLabelSprite('Z', AXIS_COLOR_HEX.z)
            };
            const labelDistance = arrowLength + 0.15; // Closer to axis tips

            axisLabels.x.position.set(labelDistance, 0, 0);
            axisLabels.y.position.set(0, labelDistance, 0);
            axisLabels.z.position.set(0, 0, labelDistance);

            Object.values(axisLabels).forEach(sprite => {
                sprite.visible = false;
                transformGizmo.add(sprite);
            });

            transformGizmo.userData.axisLabels = axisLabels;
            transformGizmo.userData.labelDistance = labelDistance;
            transformGizmo.userData.labelScale = 0.35;
            
            scene.add(transformGizmo);
        }
        
        function setupOrbitControls() {
            controls = {
                enabled: true,
                target: new THREE.Vector3(0, 0, 0),
                minDistance: 2,
                maxDistance: 20,
                isOrbiting: false,
                isPanning: false,
                lastMouseX: 0,
                lastMouseY: 0,
                phi: Math.PI / 4,
                theta: Math.PI / 4,
                radius: 5
            };
            
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            updateCameraPosition();
        }
        
        function performSmartSelection(event) {
            // Smart selection: automatically detect what's closest to the click
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );

            raycaster.setFromCamera(mouse, camera);

            // Check all objects
            const intersects = raycaster.intersectObjects(objects, false);
            if (intersects.length === 0) {
                deselectAll();
                return null;
            }

            const intersect = intersects[0];
            const clickedObject = intersect.object;
            const clickPoint = intersect.point;
            const localPoint = clickedObject.worldToLocal(clickPoint.clone());

            // Get geometry data
            const geometry = clickedObject.geometry;
            const positions = geometry.attributes.position;

            // Find closest vertex
            let closestVertex = null;
            let closestVertexDist = Infinity;

            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                clickedObject.localToWorld(vertex);
                const dist = vertex.distanceTo(clickPoint);

                if (dist < closestVertexDist) {
                    closestVertexDist = dist;
                    closestVertex = { index: i, position: vertex, distance: dist };
                }
            }

            // Find closest edge
            let closestEdge = null;
            let closestEdgeDist = Infinity;

            const indices = geometry.index ? geometry.index.array : null;
            const faceCount = indices ? indices.length / 3 : positions.count / 3;

            const edges = new Set();
            for (let i = 0; i < faceCount; i++) {
                const a = indices ? indices[i * 3] : i * 3;
                const b = indices ? indices[i * 3 + 1] : i * 3 + 1;
                const c = indices ? indices[i * 3 + 2] : i * 3 + 2;

                const edgeList = [[a, b], [b, c], [c, a]];
                for (const [v1, v2] of edgeList) {
                    const edgeKey = `${Math.min(v1, v2)}-${Math.max(v1, v2)}`;
                    if (edges.has(edgeKey)) continue;
                    edges.add(edgeKey);

                    const p1 = new THREE.Vector3(positions.getX(v1), positions.getY(v1), positions.getZ(v1));
                    const p2 = new THREE.Vector3(positions.getX(v2), positions.getY(v2), positions.getZ(v2));
                    clickedObject.localToWorld(p1);
                    clickedObject.localToWorld(p2);

                    // Calculate distance from point to line segment
                    const line = new THREE.Vector3().subVectors(p2, p1);
                    const lineLength = line.length();
                    line.normalize();

                    const toPoint = new THREE.Vector3().subVectors(clickPoint, p1);
                    const projection = toPoint.dot(line);

                    let dist;
                    if (projection <= 0) {
                        dist = clickPoint.distanceTo(p1);
                    } else if (projection >= lineLength) {
                        dist = clickPoint.distanceTo(p2);
                    } else {
                        const projectedPoint = p1.clone().add(line.multiplyScalar(projection));
                        dist = clickPoint.distanceTo(projectedPoint);
                    }

                    if (dist < closestEdgeDist) {
                        closestEdgeDist = dist;
                        closestEdge = { indices: [v1, v2], start: p1, end: p2, distance: dist };
                    }
                }
            }

            // Dynamic thresholds based on camera distance
            const cameraDistance = camera.position.distanceTo(clickPoint);
            const baseFactor = Math.min(cameraDistance * 0.02, 0.3); // Scale with distance but cap it

            // Adjusted thresholds - make vertices MUCH easier to select
            const vertexThreshold = baseFactor * 3.0;  // Very generous for vertices
            const edgeThreshold = baseFactor * 0.5;    // Very restrictive for edges

            // Calculate relative distances (normalized by thresholds)
            const vertexScore = closestVertex ? (vertexThreshold - closestVertex.distance) / vertexThreshold : -1;
            const edgeScore = closestEdge ? (edgeThreshold - closestEdge.distance) / edgeThreshold : -1;

            // Smart selection based on scores - STRONG vertex priority
            // If vertex has any reasonable score, select it over edges
            if (vertexScore > 0.05) {  // Very low threshold - prioritize vertices heavily
                // Strong vertex selection - override edge selection
                setSelectionMode('vertex');
                selectObject(clickedObject);
                selectVertex(clickedObject, intersect);
                return 'vertex';
            } else if (edgeScore > 0.5) {  // Higher threshold for edges
                // Select edge - need to properly set up the edge with indices
                setSelectionMode('edge');
                selectObject(clickedObject);

                // Build proper edge structure with indices for movement
                const geometry = clickedObject.geometry;
                const positionAttr = geometry.attributes.position;
                const threshold = 0.05;

                // Find all vertices at start position
                const startIndices = [];
                const endIndices = [];
                const localStart = closestEdge.start.clone();
                const localEnd = closestEdge.end.clone();
                clickedObject.worldToLocal(localStart);
                clickedObject.worldToLocal(localEnd);

                for (let i = 0; i < positionAttr.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                    if (v.distanceTo(localStart) < threshold) {
                        startIndices.push(i);
                    } else if (v.distanceTo(localEnd) < threshold) {
                        endIndices.push(i);
                    }
                }

                // Create properly structured edge object
                selectedEdge = {
                    start: closestEdge.start,
                    end: closestEdge.end,
                    localStart: localStart.clone(),
                    localEnd: localEnd.clone(),
                    indices: {
                        start: startIndices,
                        end: endIndices
                    }
                };

                updateEdgeHighlight(closestEdge.start, closestEdge.end);

                // Position gizmo at edge center
                const edgeCenter = new THREE.Vector3()
                    .addVectors(closestEdge.start, closestEdge.end)
                    .multiplyScalar(0.5);
                if (transformMode !== 'select') {
                    transformGizmo.visible = true;
                    transformGizmo.position.copy(edgeCenter);
                }
                alignTransformGizmo();

                return 'edge';
            } else {
                // Select face
                setSelectionMode('face');
                selectObject(clickedObject);
                selectFace(clickedObject, intersect);
                return 'face';
            }
        }

        function updateEdgeHighlight(start, end) {
            edgeHighlight.visible = true;
            const sphere1 = edgeHighlight.children[0];
            const sphere2 = edgeHighlight.children[1];
            if (sphere1 && sphere2) {
                sphere1.position.copy(start);
                sphere2.position.copy(end);
            }
        }

        function onCanvasMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // PRIORITY 0: Box selection mode - start box selection if 'B' key is held
            if (boxSelectActive && selectedObject) {
                boxSelectStart = { x: event.clientX, y: event.clientY };
                boxSelectCurrent = { x: event.clientX, y: event.clientY };
                clearBoxSelectionCanvas();
                console.log('ðŸ“¦ Box selection started at:', boxSelectStart);
                event.preventDefault();
                return;
            }

            // Check for double-click
            const currentTime = Date.now();
            const isDoubleClick = (currentTime - lastClickTime) < DOUBLE_CLICK_TIME;
            lastClickTime = currentTime;

            // Ensure all objects have updated matrices
            objects.forEach(obj => {
                obj.updateMatrixWorld(true);
            });

            // PRIORITY 1: Check if clicking on a vertex helper (yellow/red cube) FIRST
            // This allows direct selection of vertices by clicking their visual markers
            // Must come before gizmo check so gizmo doesn't block vertex selection
            if (vertexHelpers.length > 0) {
                raycaster.setFromCamera(mouse, camera);
                const helperIntersects = raycaster.intersectObjects(vertexHelpers, false);
                if (helperIntersects.length > 0) {
                    const helperMesh = helperIntersects[0].object;
                    const vertexIndex = helperMesh.userData.vertexIndex;
                    const parentObject = helperMesh.userData.parentObject;

                    if (parentObject && vertexIndex !== undefined) {
                        console.log('Vertex helper clicked! Index:', vertexIndex, 'Shift held:', event.shiftKey);

                        // Get the actual vertex position
                        const geometry = parentObject.geometry;
                        const positionAttr = geometry.attributes.position;
                        const vertexPos = new THREE.Vector3().fromBufferAttribute(positionAttr, vertexIndex);
                        parentObject.updateMatrixWorld();
                        vertexPos.applyMatrix4(parentObject.matrixWorld);

                        // Select this vertex
                        setSelectionMode('vertex');

                        // Only call selectObject if it's a different object
                        if (selectedObject !== parentObject) {
                            selectObject(parentObject);
                        }

                        selectVertexDirect(parentObject, vertexIndex, vertexPos, event.shiftKey);
                        updateSelectionInfo();
                        return;
                    }
                }
            }

            // PRIORITY 2: Check if clicking on gizmo
            if (transformGizmo.visible && transformMode !== 'select') {
                raycaster.setFromCamera(mouse, camera);
                const gizmoIntersects = raycaster.intersectObjects(transformGizmo.children, true);

                if (gizmoIntersects.length > 0) {
                    let obj = gizmoIntersects[0].object;

                    // Check if clicking on the control cube
                    if (obj.userData.isCube) {
                        const face = gizmoIntersects[0].face;
                        const faceIndex = Math.floor(gizmoIntersects[0].faceIndex / 2); // Each cube face has 2 triangles

                        // Determine which face was clicked and switch mode
                        if (faceIndex === 0) {
                            // Right face - Rotate mode
                            setTransformMode('rotate');
                            controls.lastMouseX = event.clientX;
                            controls.lastMouseY = event.clientY;
                            event.preventDefault();
                            return;
                        } else if (faceIndex === 1) {
                            // Left face - Scale mode
                            setTransformMode('scale');
                            controls.lastMouseX = event.clientX;
                            controls.lastMouseY = event.clientY;
                            event.preventDefault();
                            return;
                        } else if (faceIndex === 2) {
                            // Top face - Normal/World toggle
                            useNormalAlignment = !useNormalAlignment;
                            alignTransformGizmo();
                            console.log('Gizmo alignment:', useNormalAlignment ? 'NORMAL' : 'WORLD');
                            controls.lastMouseX = event.clientX;
                            controls.lastMouseY = event.clientY;
                            event.preventDefault();
                            return;
                        } else if (faceIndex === 4) {
                            // Front face - Translate mode
                            setTransformMode('translate');
                            controls.lastMouseX = event.clientX;
                            controls.lastMouseY = event.clientY;
                            event.preventDefault();
                            return;
                        } else if (faceIndex === 5) {
                            // Back face - Extrude (only works if face is selected)
                            if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                                // Start face extrusion (sets up extrusionData and shows panel)
                                startFaceExtrusion();
                                console.log('Extrude mode activated for selected face(s)');
                            } else {
                                console.log('Please select a face first to extrude');
                            }
                            controls.lastMouseX = event.clientX;
                            controls.lastMouseY = event.clientY;
                            event.preventDefault();
                            return;
                        } else {
                            // Bottom face - allow free move
                            isDraggingGizmo = true;
                            draggedAxis = 'free';
                        }
                    } else {
                        // Regular gizmo handle
                        isDraggingGizmo = true;
                        while (obj.parent && !obj.userData.axis) {
                            obj = obj.parent;
                        }
                        draggedAxis = obj.userData.axis;
                    }

                    // Reset accumulated movement for grid snapping
                    accumulatedMovement.set(0, 0, 0);

                    // Store starting position based on selection mode
                    if (selectionMode === 'object') {
                        objectStartPos.copy(selectedObject.position);
                    } else if (selectionMode === 'face' || selectionMode === 'edge' || selectionMode === 'vertex') {
                        objectStartPos.copy(transformGizmo.position);
                    }

                    // Store initial scale for scale mode
                    if (transformMode === 'scale') {
                        if (selectionMode === 'object') {
                            objectStartPos.copy(selectedObject.scale);
                        }
                    }

                    // IMPORTANT: Set last mouse position BEFORE returning to prevent jutter on first mousemove
                    controls.lastMouseX = event.clientX;
                    controls.lastMouseY = event.clientY;

                    controls.enabled = false;
                    event.preventDefault();
                    return;
                }
            }

            // Check if clicking on object or face
            // IMPORTANT: Set raycaster from camera BEFORE checking objects
            raycaster.setFromCamera(mouse, camera);
            // Use false (non-recursive) to avoid wireframe children interfering with raycasting
            const intersects = raycaster.intersectObjects(objects, false);

            // Click detection - camera mode debug
            console.log('=== CLICK DEBUG ===');
            console.log('Camera mode:', isOrthographic ? 'ORTHOGRAPHIC' : 'PERSPECTIVE');
            console.log('Camera type:', camera.type);
            console.log('Intersects found:', intersects.length);

            if (objects.length > 0) {
                const obj = objects[0];
                console.log('First object:', {
                    hasGeometry: !!obj.geometry,
                    vertexCount: obj.geometry?.attributes.position?.count,
                    boundingSphere: obj.geometry?.boundingSphere,
                    boundingBox: obj.geometry?.boundingBox,
                    position: obj.position,
                    visible: obj.visible,
                    layers: obj.layers.mask,
                    matrixWorldNeedsUpdate: obj.matrixWorldNeedsUpdate
                });

                // Try manual raycast with detailed logging
                console.log('Attempting direct raycast...');
                console.log('  Raycaster ray origin:', raycaster.ray.origin);
                console.log('  Raycaster ray direction:', raycaster.ray.direction);

                const testIntersects = raycaster.intersectObject(obj, false);
                console.log('Direct raycast on object:', testIntersects.length, 'intersects');
                if (testIntersects.length > 0) {
                    console.log('  First intersection:', testIntersects[0]);
                } else {
                    // Debug why raycast failed
                    console.log('Ã¢Å¡Â  Raycast failed - debugging:');
                    console.log('  Bounding sphere valid:', obj.geometry.boundingSphere && obj.geometry.boundingSphere.radius > 0);
                    console.log('  Geometry has positions:', !!obj.geometry.attributes.position);
                    console.log('  Position count:', obj.geometry.attributes.position?.count);
                    console.log('  DrawRange:', obj.geometry.drawRange);
                }
            }
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                let clickedObject = intersect.object;

                // Find the parent object
                while (clickedObject.parent && !objects.includes(clickedObject)) {
                    clickedObject = clickedObject.parent;
                }

                if (objects.includes(clickedObject)) {
                    // Cut tool is now edge-based, no point clicking needed

                    if (isDoubleClick) {
                        // Double-click: always select object
                        setSelectionMode('object');
                        selectObject(clickedObject);
                        updateSelectionInfo();
                    } else {
                        // Always use smart selection for single clicks
                        performSmartSelection(event);
                        updateSelectionInfo();
                    }
                    return;
                }
            }
            
            console.log('No valid object clicked');
            
            // Start orbiting if nothing selected
            if (event.button === 0) {
                controls.isOrbiting = true;
            } else if (event.button === 2) {
                controls.isPanning = true;
                event.preventDefault();
            }
            
            controls.lastMouseX = event.clientX;
            controls.lastMouseY = event.clientY;

            if (transformGizmo && transformGizmo.visible) {
                updateGizmoAxisLabels();
            }
        }
        
        function onCanvasMouseMove(event) {
            const deltaX = event.clientX - controls.lastMouseX;
            const deltaY = event.clientY - controls.lastMouseY;

            // Box selection mode - update selection rectangle and preview
            if (boxSelectActive && boxSelectStart) {
                boxSelectCurrent = { x: event.clientX, y: event.clientY };
                drawBoxSelection();
                previewBoxSelection(); // Show RED preview of what will be selected
                event.preventDefault();
                return;
            }

            if (isDraggingGizmo && selectedObject) {
                // Use a more precise scale for better control
                const movementScale = selectionMode === 'edge' ? 0.008 : 0.01;
                
                if (transformMode === 'translate') {
                    let movement = new THREE.Vector3();

                    if (draggedAxis === 'free') {
                        // Free movement in X-Z plane (based on camera view)
                        movement.x = deltaX * movementScale;
                        movement.z = deltaY * movementScale;
                    } else {
                        // Transform movement by gizmo orientation when using normal alignment
                        // For face/edge, use normal alignment. For vertex/object, use world (or respect toggle)
                        const shouldUseNormalAlignment = (selectionMode === 'face' || selectionMode === 'edge') ||
                                                        (selectionMode === 'object' && useNormalAlignment);
                        if (shouldUseNormalAlignment && transformGizmo) {
                            // Calculate movement along the actual gizmo axis direction
                            const axisVector = GIZMO_AXIS_BASE_VECTORS[draggedAxis].clone();
                            const worldAxisDirection = axisVector.applyQuaternion(transformGizmo.quaternion);

                            // Map mouse delta to movement amount
                            let movementAmount = 0;
                            if (draggedAxis === 'x') {
                                movementAmount = deltaX * movementScale;
                            } else if (draggedAxis === 'y') {
                                movementAmount = -deltaY * movementScale;
                            } else if (draggedAxis === 'z') {
                                movementAmount = -deltaY * movementScale;
                            }

                            // Movement = amount * direction
                            movement.copy(worldAxisDirection.multiplyScalar(movementAmount));
                        } else {
                            // World space movement (no normal alignment)
                            if (draggedAxis === 'x') {
                                movement.x = deltaX * movementScale;
                            } else if (draggedAxis === 'y') {
                                movement.y = -deltaY * movementScale;
                            } else if (draggedAxis === 'z') {
                                movement.z = -deltaY * movementScale;
                            }
                        }
                    }

                    const gridSnapEnabled = document.getElementById('grid-snap-checkbox').checked;
                    const gridSize = gridSnapEnabled ? currentGridSize : 0;

                    if (gridSnapEnabled) {
                        // Accumulate the unsnapped movement
                        accumulatedMovement.add(movement);

                        // Calculate target position from start
                        const targetPos = objectStartPos.clone().add(accumulatedMovement);

                        // Snap the target position
                        const snappedTarget = new THREE.Vector3(
                            snapToGrid(targetPos.x, gridSize),
                            snapToGrid(targetPos.y, gridSize),
                            snapToGrid(targetPos.z, gridSize)
                        );

                        // Calculate the actual movement to apply
                        const actualMovement = snappedTarget.sub(
                            selectionMode === 'object' ? selectedObject.position : transformGizmo.position
                        );

                        // Apply movement based on selection mode
                        if (selectionMode === 'object') {
                            selectedObject.position.add(actualMovement);
                            transformGizmo.position.copy(selectedObject.position);
                        } else if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                            if (actualMovement.length() > 0.0001) {
                                moveFaceVertices(actualMovement);
                            }
                        } else if (selectionMode === 'edge' && selectedEdge) {
                            if (actualMovement.length() > 0.0001) {
                                moveEdgeVertices(actualMovement);
                            }
                        } else if (selectionMode === 'vertex' && (selectedVertex || selectedVertices.length > 0)) {
                            if (actualMovement.length() > 0.0001) {
                                moveVertex(actualMovement);
                            }
                        }
                    } else {
                        // No grid snap - just apply movement directly
                        if (selectionMode === 'object') {
                            selectedObject.position.add(movement);
                            transformGizmo.position.copy(selectedObject.position);
                        } else if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                            moveFaceVertices(movement);
                        } else if (selectionMode === 'edge' && selectedEdge) {
                            moveEdgeVertices(movement);
                        } else if (selectionMode === 'vertex' && (selectedVertex || selectedVertices.length > 0)) {
                            moveVertex(movement);
                        }
                    }
                } else if (transformMode === 'rotate') {
                    const rotationSpeed = 0.02;
                    const rotationAmount = (deltaX + deltaY) * rotationSpeed;
                    
                    if (selectionMode === 'object') {
                        // Rotate entire object
                        if (draggedAxis === 'x') {
                            selectedObject.rotation.x += deltaY * rotationSpeed;
                        } else if (draggedAxis === 'y') {
                            selectedObject.rotation.y += deltaX * rotationSpeed;
                        } else if (draggedAxis === 'z') {
                            selectedObject.rotation.z += deltaX * rotationSpeed;
                        }
                    } else if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                        // Rotate face vertices around face center
                        rotateFaceVertices(draggedAxis, rotationAmount);
                    } else if (selectionMode === 'edge' && selectedEdge) {
                        // Rotate edge vertices around edge center
                        rotateEdgeVertices(draggedAxis, rotationAmount);
                    } else if (selectionMode === 'vertex' && (selectedVertex || selectedVertices.length > 0)) {
                        // Can't rotate a single vertex, but could rotate multiple
                        if (selectedVertices.length > 1) {
                            console.log('Multi-vertex rotation not yet implemented');
                            // TODO: Implement rotation of multiple vertices around their center
                        } else {
                            console.log('Cannot rotate a single vertex');
                        }
                    }
                } else if (transformMode === 'scale') {
                    const scaleSpeed = 0.01;
                    const scaleChange = -deltaY * scaleSpeed; // Negative because dragging up should scale up
                    
                    if (selectionMode === 'object') {
                        // Scale entire object
                        if (draggedAxis === 'x') {
                            selectedObject.scale.x = Math.max(0.1, selectedObject.scale.x + scaleChange);
                        } else if (draggedAxis === 'y') {
                            selectedObject.scale.y = Math.max(0.1, selectedObject.scale.y + scaleChange);
                        } else if (draggedAxis === 'z') {
                            selectedObject.scale.z = Math.max(0.1, selectedObject.scale.z + scaleChange);
                        }
                    } else if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                        // Scale face vertices from face center
                        scaleFaceVertices(draggedAxis, scaleChange);
                    } else if (selectionMode === 'edge' && selectedEdge) {
                        // Scale edge - but ONLY along the edge direction
                        // The draggedAxis should be 'edge' for the special edge gizmo
                        console.log('Edge scale triggered, axis:', draggedAxis, 'change:', scaleChange);
                        scaleEdgeAlongDirection(scaleChange);
                    } else if (selectionMode === 'vertex' && (selectedVertex || selectedVertices.length > 0)) {
                        // Can't scale a single vertex, but could scale multiple
                        if (selectedVertices.length > 1) {
                            console.log('Multi-vertex scaling not yet implemented');
                            // TODO: Implement scaling of multiple vertices from their center
                        } else {
                            console.log('Cannot scale a single vertex');
                        }
                    }
                }
                updateSelectionInfo();
            } else if (controls.isOrbiting) {
                controls.theta -= deltaX * 0.01;
                controls.phi -= deltaY * 0.01;
                controls.phi = Math.max(0.1, Math.min(Math.PI - 0.1, controls.phi));
                updateCameraPosition();
            } else if (controls.isPanning) {
                const panSpeed = 0.01;
                const right = new THREE.Vector3();
                const up = new THREE.Vector3(0, 1, 0);
                camera.getWorldDirection(right);
                right.cross(up).normalize();
                
                controls.target.x -= right.x * deltaX * panSpeed;
                controls.target.z -= right.z * deltaX * panSpeed;
                controls.target.y += deltaY * panSpeed;
                
                updateCameraPosition();
            }
            
            controls.lastMouseX = event.clientX;
            controls.lastMouseY = event.clientY;
        }
        
        function onCanvasMouseUp(event) {
            // Box selection mode - keep preview showing, selection finalizes on B key release
            if (boxSelectStart) {
                // Don't finalize yet - just stop dragging
                // Keep the rectangle and preview visible until B is released
                console.log('ðŸ–±ï¸ Mouse released, keeping preview until B is released');
                event.preventDefault();
                return;
            }

            controls.isOrbiting = false;
            controls.isPanning = false;
            isDraggingGizmo = false;
            draggedAxis = null;
            controls.enabled = true;
        }
        
        function onMouseWheel(event) {
            event.preventDefault();

            if (isOrthographic) {
                // For orthographic camera, adjust frustum size
                // Proportional zoom feels smoother
                camera.userData.frustumSize = camera.userData.frustumSize || 10;
                const zoomFactor = 1 + (event.deltaY * 0.001); // Much smoother (was 0.1)
                camera.userData.frustumSize *= zoomFactor;
                camera.userData.frustumSize = Math.max(1, Math.min(50, camera.userData.frustumSize));

                const aspect = window.innerWidth / window.innerHeight;
                camera.left = camera.userData.frustumSize * aspect / -2;
                camera.right = camera.userData.frustumSize * aspect / 2;
                camera.top = camera.userData.frustumSize / 2;
                camera.bottom = camera.userData.frustumSize / -2;
                camera.updateProjectionMatrix();
            } else {
                // For perspective camera, adjust radius
                controls.radius += event.deltaY * 0.01;
                controls.radius = Math.max(controls.minDistance, Math.min(controls.maxDistance, controls.radius));
                updateCameraPosition();
            }
        }
        
        function onKeyDown(event) {
            // Box Selection: Hold 'B' key to activate box select mode (face/vertex selection)
            if ((event.key === 'b' || event.key === 'B') && !event.ctrlKey && !event.altKey) {
                if (!boxSelectActive && (selectionMode === 'face' || selectionMode === 'vertex')) {
                    boxSelectActive = true;

                    // Clear existing selections when entering box select mode
                    console.log('ðŸ§¹ Clearing previous selections...');
                    selectedFace = null;
                    selectedVertex = null;
                    selectedFaces = [];
                    selectedVertices = [];

                    // Hide single-face highlight
                    if (faceHighlight) {
                        faceHighlight.visible = false;
                    }

                    // Clear multi-face highlights
                    multiFaceHighlights.forEach(highlight => {
                        scene.remove(highlight);
                        highlight.geometry?.dispose();
                        highlight.material?.dispose();
                    });
                    multiFaceHighlights = [];

                    // Reset all vertex colors to yellow
                    vertexHelpers.forEach(helper => {
                        helper.material.color.setHex(0xffff00);
                    });

                    updateSelectionInfo();
                    console.log('ðŸ“¦ Box selection mode activated! Drag to select multiple ' + selectionMode + 's');
                }
                return;
            }

            // Undo/Redo
            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault();
                performUndo();
                return;
            }
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault();
                performRedo();
                return;
            }

            // View shortcuts
            if (event.key === '1') {
                setCameraView('front');
                return;
            }
            if (event.key === '2') {
                setCameraView('side');
                return;
            }
            if (event.key === '3') {
                setCameraView('top');
                return;
            }

            // Camera mode toggles
            if (event.key === 'o' || event.key === 'O') {
                toggleCameraMode('orthographic');
                return;
            }
            if (event.key === 'p' || event.key === 'P') {
                toggleCameraMode('perspective');
                return;
            }

            // Cut tool: TAB to cycle which side to keep
            if (event.key === 'Tab' && cutToolActive) {
                event.preventDefault();
                cutKeepSide = -cutKeepSide; // Toggle between 1 and -1
                updateCutPlanePreview(); // Update visualization
                const sideText = cutKeepSide === 1 ? 'POSITIVE (arrow side)' : 'NEGATIVE (opposite side)';
                console.log('Cut side switched to:', sideText);
                return;
            }

            // Frame/Focus selected object (center it)
            if (event.key === 'f' || event.key === 'F') {
                frameSelectedObject();
                return;
            }

            // Other controls
            if (event.key === 'Escape') {
                deselectAll();
            } else if (event.key === 'Delete' || event.key === 'Backspace') {
                deleteSelected();
            }
        }

        function onKeyUp(event) {
            // Box Selection: Release 'B' key to finalize selection
            if (event.key === 'b' || event.key === 'B') {
                if (boxSelectActive) {
                    boxSelectActive = false;

                    console.log('ðŸ“¦ Finalizing box selection...');
                    console.log('Preview faces:', boxSelectPreviewFaces.length);
                    console.log('Preview vertices:', boxSelectPreviewVertices.length);
                    console.log('Preview vertex indices:', boxSelectPreviewVertices);

                    // Copy preview to actual selection
                    selectedFaces = [...boxSelectPreviewFaces];

                    // Create vertex objects with WORLD positions (not local)
                    selectedVertices = boxSelectPreviewVertices.map(idx => {
                        const localPos = new THREE.Vector3().fromBufferAttribute(
                            selectedObject.geometry.attributes.position, idx
                        );
                        // Transform to world space
                        selectedObject.updateMatrixWorld();
                        const worldPos = localPos.clone();
                        worldPos.applyMatrix4(selectedObject.matrixWorld);

                        return {
                            index: idx,
                            pos: worldPos  // Use 'pos' not 'worldPos' to match selectVertexDirect
                        };
                    });

                    console.log('Final faces:', selectedFaces.length);
                    console.log('Final vertices:', selectedVertices.length);
                    console.log('Final vertex objects:', selectedVertices);

                    // Set the primary selected vertex (needed for gizmo and other operations)
                    if (selectionMode === 'vertex' && selectedVertices.length > 0) {
                        selectedVertex = selectedVertices[selectedVertices.length - 1];

                        // Calculate center of all selected vertices
                        const center = new THREE.Vector3();
                        selectedVertices.forEach(v => center.add(v.pos));
                        center.divideScalar(selectedVertices.length);

                        // Show vertex highlight sphere at last selected vertex
                        if (vertexHighlight) {
                            vertexHighlight.position.copy(selectedVertex.pos);
                            vertexHighlight.visible = true;
                        }

                        // Show gizmo at the center of all selected vertices
                        if (transformMode !== 'select') {
                            transformGizmo.visible = true;
                            transformGizmo.position.copy(center);
                            alignTransformGizmo();
                        }
                    }

                    // Handle faces even in vertex mode - if all vertices of a face are selected
                    if (selectedFaces.length > 0) {
                        if (selectionMode === 'face') {
                            // In face mode, set selectedFace for operations like extrusion
                            if (selectedFaces.length === 1) {
                                selectedFace = selectedFaces[0];
                            } else if (selectedFaces.length > 0) {
                                // For multi-face selection, use the first face as primary
                                selectedFace = selectedFaces[0];
                                console.log(`Set primary face for operations (${selectedFaces.length} total faces selected)`);
                            }

                            // Ensure faces have proper format with normal and center
                            selectedFaces.forEach(face => {
                                if (!face.normal || !face.center) {
                                    // Calculate face normal and center if missing
                                    const geometry = selectedObject.geometry;
                                    const positionAttr = geometry.attributes.position;

                                    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, face.vertexIndices[0]);
                                    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, face.vertexIndices[1]);
                                    const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, face.vertexIndices[2]);

                                    // Calculate normal
                                    const edge1 = new THREE.Vector3().subVectors(v2, v1);
                                    const edge2 = new THREE.Vector3().subVectors(v3, v1);
                                    face.normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                                    // Calculate center
                                    face.center = new THREE.Vector3()
                                        .add(v1)
                                        .add(v2)
                                        .add(v3)
                                        .divideScalar(3);
                                }
                            });
                        }
                        // Face highlights will be shown regardless of mode
                    }

                    // Clear preview highlights (will be replaced with final highlights)
                    clearBoxSelectionPreview();

                    // Update final highlights
                    updateFaceHighlights();
                    updateVertexHighlights();
                    updateSelectionInfo();

                    // Clear box rectangle and state
                    clearBoxSelectionCanvas();
                    boxSelectStart = null;
                    boxSelectCurrent = null;

                    console.log('âœ… Box selection finalized! Selected:',
                        selectionMode === 'face' ? selectedFaces.length + ' faces' :
                        selectedVertices.length + ' vertices');
                }
                return;
            }
        }

        function saveToHistory() {
            if (!selectedObject) return;

            const state = {
                objectId: objects.indexOf(selectedObject),
                geometry: selectedObject.geometry.clone(),
                position: selectedObject.position.clone(),
                rotation: selectedObject.rotation.clone(),
                scale: selectedObject.scale.clone()
            };

            undoHistory.push(state);
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            }
            redoHistory = []; // Clear redo when new action is performed
        }

        function performUndo() {
            if (undoHistory.length === 0) return;

            const state = undoHistory.pop();
            if (state.objectId < 0 || state.objectId >= objects.length) return;

            const obj = objects[state.objectId];

            // Save current state to redo
            redoHistory.push({
                objectId: state.objectId,
                geometry: obj.geometry.clone(),
                position: obj.position.clone(),
                rotation: obj.rotation.clone(),
                scale: obj.scale.clone()
            });

            // Restore old state
            obj.geometry = state.geometry;
            obj.position.copy(state.position);
            obj.rotation.copy(state.rotation);
            obj.scale.copy(state.scale);

            updateWireframe(obj);
        }

        function performRedo() {
            if (redoHistory.length === 0) return;

            const state = redoHistory.pop();
            if (state.objectId < 0 || state.objectId >= objects.length) return;

            const obj = objects[state.objectId];

            // Save current state to undo
            undoHistory.push({
                objectId: state.objectId,
                geometry: obj.geometry.clone(),
                position: obj.position.clone(),
                rotation: obj.rotation.clone(),
                scale: obj.scale.clone()
            });

            // Restore state
            obj.geometry = state.geometry;
            obj.position.copy(state.position);
            obj.rotation.copy(state.rotation);
            obj.scale.copy(state.scale);

            updateWireframe(obj);
        }

        function toggleCameraMode(mode) {
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = controls.radius || 10; // Use current view distance

            if (mode === 'orthographic' && !isOrthographic) {
                // Switch to orthographic
                const newCamera = new THREE.OrthographicCamera(
                    frustumSize * aspect / -2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    frustumSize / -2,
                    0.1,
                    1000
                );
                newCamera.position.copy(camera.position);
                newCamera.lookAt(controls.target);
                camera = newCamera;
                isOrthographic = true;

                // Store frustum size for zoom
                camera.userData.frustumSize = frustumSize;
            } else if (mode === 'perspective' && isOrthographic) {
                // Switch to perspective
                const newCamera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                newCamera.position.copy(camera.position);
                newCamera.lookAt(controls.target);
                camera = newCamera;
                isOrthographic = false;
            }

            // Force update
            camera.updateProjectionMatrix();
        }

        function frameSelectedObject() {
            if (!selectedObject) return;

            // Center camera on selected object
            controls.target.copy(selectedObject.position);
            controls.radius = 5;
            updateCameraPosition();
        }

        function updateCameraPosition() {
            const x = controls.radius * Math.sin(controls.phi) * Math.cos(controls.theta);
            const y = controls.radius * Math.cos(controls.phi);
            const z = controls.radius * Math.sin(controls.phi) * Math.sin(controls.theta);
            
            camera.position.set(
                controls.target.x + x,
                controls.target.y + y,
                controls.target.z + z
            );
            camera.lookAt(controls.target);
        }
        
        function selectObject(obj) {
            // Clear previous selections
            clearSelectionHighlights();

            // Deselect previous
            if (selectedObject && selectedObject !== obj) {
                selectedObject.material.emissive.setHex(0x000000);
            }

            selectedObject = obj;
            selectedObject.material.emissive.setHex(0x444444);

            // Update vertex helpers if in any edit mode
            if (selectionMode !== 'object') {
                updateVertexHelpers(obj);
                // updateFaceEdgeSelectionHelpers(obj); // Disabled - too cluttered
            }
            selectedFace = null;
            selectedEdge = null;
            selectedVertex = null;
            
            // Show and position gizmo
            if (transformMode !== 'select') {
                transformGizmo.visible = true;
                transformGizmo.position.copy(selectedObject.position);
            }
            alignTransformGizmo();
        }

        function sortFaceVertexEntries(entries, normal) {
            if (entries.length <= 2) {
                return entries.slice();
            }

            const center = new THREE.Vector3();
            entries.forEach(entry => center.add(entry.local));
            center.divideScalar(entries.length);

            let tangent = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(0, 1, 0));
            if (tangent.lengthSq() < 1e-8) {
                tangent = new THREE.Vector3().crossVectors(normal, new THREE.Vector3(1, 0, 0));
            }
            tangent.normalize();

            const bitangent = new THREE.Vector3().crossVectors(normal, tangent).normalize();

            return entries
                .map(entry => {
                    const offset = entry.local.clone().sub(center);
                    const u = offset.dot(tangent);
                    const v = offset.dot(bitangent);
                    const angle = Math.atan2(v, u);
                    return { entry, angle };
                })
                .sort((a, b) => a.angle - b.angle)
                .map(item => item.entry);
        }

        function buildFaceVertexEntries(vertexIndices, positionAttr, object, normal, tolerance = 0.0005) {
            const toleranceSq = tolerance * tolerance;
            const uniqueEntries = [];

            vertexIndices.forEach(idx => {
                const localPos = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                let existing = null;

                for (let i = 0; i < uniqueEntries.length; i++) {
                    if (uniqueEntries[i].local.distanceToSquared(localPos) <= toleranceSq) {
                        existing = uniqueEntries[i];
                        break;
                    }
                }

                if (existing) {
                    existing.indices.push(idx);
                } else {
                    const storedLocal = localPos.clone();
                    uniqueEntries.push({
                        index: idx,
                        indices: [idx],
                        local: storedLocal,
                        world: storedLocal.clone().applyMatrix4(object.matrixWorld)
                    });
                }
            });

            const orderedEntries = sortFaceVertexEntries(uniqueEntries, normal);
            const centerLocal = new THREE.Vector3();
            orderedEntries.forEach(entry => centerLocal.add(entry.local));
            centerLocal.divideScalar(orderedEntries.length);

            const centerWorld = centerLocal.clone().applyMatrix4(object.matrixWorld);
            const worldNormal = normal.clone().transformDirection(object.matrixWorld).normalize();

            return {
                orderedEntries,
                centerLocal,
                centerWorld,
                localNormal: normal.clone(),
                worldNormal
            };
        }

        function buildFaceHighlightGeometry(worldVertices, worldNormal, offset = 0.02) {
            if (!worldVertices || worldVertices.length < 3) {
                return null;
            }

            const elevated = worldVertices.map(vertex =>
                vertex.clone().add(worldNormal.clone().multiplyScalar(offset))
            );

            const positions = [];
            for (let i = 1; i < elevated.length - 1; i++) {
                const v0 = elevated[0];
                const v1 = elevated[i];
                const v2 = elevated[i + 1];

                positions.push(
                    v0.x, v0.y, v0.z,
                    v1.x, v1.y, v1.z,
                    v2.x, v2.y, v2.z
                );
            }

            if (positions.length === 0) {
                return null;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.computeVertexNormals();

            return geometry;
        }

        function finalizeFaceSelection(object, faceIndex, positionAttr, baseNormal, vertexIndices) {
            const faceInfo = buildFaceVertexEntries(vertexIndices, positionAttr, object, baseNormal);

            if (!faceInfo.orderedEntries || faceInfo.orderedEntries.length < 3) {
                console.warn('Failed to build face selection (insufficient unique vertices)');
                selectedFace = null;
                faceHighlight.visible = false;
                return;
            }

            const worldVertices = faceInfo.orderedEntries.map(entry => entry.world.clone());
            const highlightGeometry = buildFaceHighlightGeometry(worldVertices, faceInfo.worldNormal);

            if (highlightGeometry) {
                if (faceHighlight.geometry) {
                    faceHighlight.geometry.dispose();
                }
                faceHighlight.geometry = highlightGeometry;
                faceHighlight.position.set(0, 0, 0);
                faceHighlight.rotation.set(0, 0, 0);
                faceHighlight.scale.set(1, 1, 1);
                faceHighlight.visible = true;
            } else {
                faceHighlight.visible = false;
            }

            selectedFace = {
                faceIndex,
                vertexIndices: faceInfo.orderedEntries.flatMap(entry => entry.indices.slice()),
                loopIndices: faceInfo.orderedEntries.map(entry => entry.index),
                normal: faceInfo.localNormal.clone(),
                worldNormal: faceInfo.worldNormal.clone(),
                localCenter: faceInfo.centerLocal.clone(),
                worldCenter: faceInfo.centerWorld.clone()
            };

            console.log('Face center (world):', faceInfo.centerWorld);
            console.log('Highlight created with', worldVertices.length, 'vertices');

            if (transformMode !== 'select') {
                transformGizmo.visible = true;
                // Offset gizmo away from object center so it sits outside the object
                const toFaceFromCenter = new THREE.Vector3().subVectors(faceInfo.centerWorld, selectedObject.position);
                const offsetDir = toFaceFromCenter.lengthSq() > 0 ? toFaceFromCenter.normalize() : faceInfo.worldNormal.clone().normalize();
                const offset = offsetDir.multiplyScalar(GIZMO_FACE_OFFSET);
                transformGizmo.position.copy(faceInfo.centerWorld).add(offset);
            }
            alignTransformGizmo();
        }

        function computeFaceTangentWorld() {
            if (!selectedObject || !selectedFace || !selectedFace.loopIndices || selectedFace.loopIndices.length < 2) {
                return new THREE.Vector3(1, 0, 0);
            }

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            selectedObject.updateMatrixWorld();

            const firstIndex = selectedFace.loopIndices[0];
            const firstPos = new THREE.Vector3().fromBufferAttribute(positionAttr, firstIndex).applyMatrix4(selectedObject.matrixWorld);

            for (let i = 1; i < selectedFace.loopIndices.length; i++) {
                const idx = selectedFace.loopIndices[i];
                const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, idx).applyMatrix4(selectedObject.matrixWorld);
                const dir = pos.clone().sub(firstPos);
                if (dir.lengthSq() > 1e-10) {
                    return dir.normalize();
                }
            }

            return new THREE.Vector3(1, 0, 0);
        }

        function computeVertexWorldNormal() {
            if (!selectedObject || !selectedVertex) {
                return null;
            }

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            const normalAttr = geometry.attributes.normal;
            if (!normalAttr) {
                return null;
            }

            selectedObject.updateMatrixWorld();

            const localReference = new THREE.Vector3().fromBufferAttribute(positionAttr, selectedVertex.index);
            const threshold = 0.0005;
            const matchingIndices = [];

            for (let i = 0; i < positionAttr.count; i++) {
                const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                if (pos.distanceTo(localReference) < threshold) {
                    matchingIndices.push(i);
                }
            }

            if (matchingIndices.length === 0) {
                matchingIndices.push(selectedVertex.index);
            }

            const normal = new THREE.Vector3();
            matchingIndices.forEach(idx => {
                const n = new THREE.Vector3().fromBufferAttribute(normalAttr, idx);
                normal.add(n);
            });

            if (normal.lengthSq() === 0) {
                return null;
            }

            normal.normalize();
            return normal.transformDirection(selectedObject.matrixWorld).normalize();
        }

        function buildOrthonormalBasis(normal, preferredDirection) {
            const zAxis = normal.clone().normalize();
            let xAxis = null;

            if (preferredDirection && preferredDirection.lengthSq() > 1e-6) {
                xAxis = preferredDirection.clone();
            }

            if (xAxis) {
                const projection = zAxis.clone().multiplyScalar(xAxis.dot(zAxis));
                xAxis.sub(projection);
            }

            if (!xAxis || xAxis.lengthSq() < 1e-6 || !isFinite(xAxis.lengthSq())) {
                const candidates = [
                    new THREE.Vector3(1, 0, 0),
                    new THREE.Vector3(0, 1, 0),
                    new THREE.Vector3(0, 0, 1)
                ];

                let bestCandidate = null;
                let lowestDot = Infinity;
                candidates.forEach(candidate => {
                    const dot = Math.abs(candidate.dot(zAxis));
                    if (dot < lowestDot - 1e-4) {
                        lowestDot = dot;
                        bestCandidate = candidate.clone();
                    }
                });

                xAxis = bestCandidate.sub(zAxis.clone().multiplyScalar(bestCandidate.dot(zAxis)));
            }

            if (xAxis.lengthSq() < 1e-6 || !isFinite(xAxis.lengthSq())) {
                xAxis = new THREE.Vector3(-zAxis.y, zAxis.x, 0);
                if (xAxis.lengthSq() < 1e-6) {
                    xAxis.set(0, -zAxis.z, zAxis.y);
                }
            }

            xAxis.normalize();

            const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();
            const correctedXAxis = new THREE.Vector3().crossVectors(yAxis, zAxis).normalize();

            if (preferredDirection && preferredDirection.lengthSq() > 1e-6) {
                if (correctedXAxis.dot(preferredDirection) < 0) {
                    correctedXAxis.negate();
                    yAxis.negate();
                }
            }

            return {
                xAxis: correctedXAxis,
                yAxis,
                zAxis
            };
        }

        function updateGizmoAxisLabels() {
            if (!transformGizmo || !transformGizmo.userData?.axisLabels) {
                return;
            }

            const { axisLabels, labelDistance = 1, labelScale = 0.35 } = transformGizmo.userData;
            const shouldShow = transformGizmo.visible && transformMode !== 'select';

            Object.values(axisLabels).forEach(sprite => {
                sprite.visible = shouldShow;
            });

            if (!shouldShow) {
                return;
            }

            const distance = camera ? camera.position.distanceTo(transformGizmo.position) : 1;
            const scaled = labelScale * Math.min(Math.max(distance / 4.5, 0.6), 2.2);

            Object.entries(axisLabels).forEach(([axis, sprite]) => {
                const dir = GIZMO_AXIS_BASE_VECTORS[axis].clone().applyQuaternion(transformGizmo.quaternion);
                sprite.position.copy(dir.multiplyScalar(labelDistance));
                const aspect = sprite.userData.aspect || 0.5;
                sprite.scale.set(scaled, scaled * aspect, 1);
            });
        }

        function alignTransformGizmo() {
            if (!transformGizmo) return;

            // For face/edge selection, use normal alignment
            // For vertex/object selection, use world alignment (or respect toggle)
            const shouldUseNormalAlignment = (selectionMode === 'face' || selectionMode === 'edge') ||
                                            (selectionMode === 'object' && useNormalAlignment);

            if (!shouldUseNormalAlignment) {
                // World alignment mode - keep gizmo aligned with world axes
                // X = red (right), Y = green (up), Z = blue (forward)
                transformGizmo.rotation.set(0, 0, 0);
            } else {
                // Normal alignment mode - align gizmo with face/edge/vertex normal
                const applyBasis = (xAxis, yAxis, zAxis) => {
                    const basis = new THREE.Matrix4().makeBasis(xAxis, yAxis, zAxis);
                    transformGizmo.setRotationFromMatrix(basis);
                };

                if (selectionMode === 'face' && selectedFace && selectedFace.worldNormal && selectedObject) {
                    selectedObject.updateMatrixWorld();
                    // Use the actual face normal - don't flip it
                    // This allows the gizmo to properly orient to each face's local coordinate system
                    let normal = selectedFace.worldNormal.clone().normalize();

                    console.log('ðŸŽ¯ GIZMO ALIGNMENT DEBUG:');
                    console.log('  Face world normal:', normal.toArray());
                    console.log('  Face local normal:', selectedFace.normal.toArray());

                    let tangent = computeFaceTangentWorld();
                    const { xAxis, yAxis, zAxis } = buildOrthonormalBasis(normal, tangent);

                    console.log('  Gizmo basis vectors:');
                    console.log('    X-axis (red):', xAxis.toArray());
                    console.log('    Y-axis (green):', yAxis.toArray());
                    console.log('    Z-axis (blue):', zAxis.toArray());

                    applyBasis(xAxis, yAxis, zAxis);
                } else if (selectionMode === 'edge' && selectedEdge && selectedObject) {
                    selectedObject.updateMatrixWorld();
                    const direction = new THREE.Vector3().subVectors(selectedEdge.end, selectedEdge.start);
                    if (direction.lengthSq() === 0) {
                        transformGizmo.rotation.set(0, 0, 0);
                    } else {
                        const xAxisTarget = direction.clone().normalize();
                        let zAxis = new THREE.Vector3(0, 1, 0);
                        if (Math.abs(xAxisTarget.dot(zAxis)) > 0.9) {
                            zAxis = new THREE.Vector3(0, 0, 1);
                        }
                        zAxis.sub(xAxisTarget.clone().multiplyScalar(zAxis.dot(xAxisTarget))).normalize();
                        const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxisTarget).normalize();
                        applyBasis(xAxisTarget, yAxis, zAxis);
                    }
                } else if (selectionMode === 'vertex' && selectedVertex && selectedObject) {
                    const normal = computeVertexWorldNormal();
                    if (normal && normal.lengthSq() > 0) {
                        const { xAxis, yAxis, zAxis } = buildOrthonormalBasis(normal, null);
                        applyBasis(xAxis, yAxis, zAxis);
                    } else {
                        transformGizmo.rotation.set(0, 0, 0);
                    }
                } else {
                    // Default to world alignment if no selection
                    transformGizmo.rotation.set(0, 0, 0);
                }
            }

            updateGizmoAxisLabels();
        }
        
        /**
         * Selects a face on an object and highlights it
         * For cubes: Each visible face is made of 2 triangles, we need to highlight the whole quad
         * 
         * @param {THREE.Mesh} obj - The object containing the face
         * @param {Object} intersect - The raycaster intersection data
         */
        function selectFace(obj, intersect) {
            clearSelectionHighlights();

            selectedObject = obj;
            selectedEdge = null;
            selectedVertex = null;

            // Face selection
            console.log('Intersect object:', intersect);

            const geometry = obj.geometry;
            if (!geometry || !geometry.attributes || !geometry.attributes.position) {
                console.error('Object has no geometry for face selection');
                selectedFace = null;
                return;
            }

            const faceIndex = intersect.faceIndex;
            if (faceIndex === undefined) {
                console.error('No face index in intersect!', intersect);
                selectedFace = null;
                return;
            }

            const positionAttr = geometry.attributes.position;
            obj.updateMatrixWorld();

            if (geometry.index) {
                const indices = geometry.index.array;
                const a = indices[faceIndex * 3];
                const b = indices[faceIndex * 3 + 1];
                const c = indices[faceIndex * 3 + 2];

                console.log('Clicked triangle indices:', a, b, c);

                // Use the face normal from the intersection (already calculated by Three.js)
                // This respects the geometry's actual normal data
                let normal;
                if (intersect.face && intersect.face.normal) {
                    normal = intersect.face.normal.clone();
                    console.log('Using intersect face normal (local):', normal);
                } else {
                    // Fallback: calculate from vertex positions
                    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, a);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, b);
                    const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, c);

                    normal = new THREE.Vector3()
                        .crossVectors(
                            new THREE.Vector3().subVectors(v2, v1),
                            new THREE.Vector3().subVectors(v3, v1)
                        )
                        .normalize();
                    console.log('Computed face normal from vertices (local):', normal);
                }

                console.log('ðŸ“ FACE SELECTION - Triangle Normal:', normal.toArray());

                const threshold = 0.01;
                const vertexSet = new Set([a, b, c]);
                const faceCount = indices.length / 3;

                for (let i = 0; i < faceCount; i++) {
                    if (i === faceIndex) continue;

                    const ia = indices[i * 3];
                    const ib = indices[i * 3 + 1];
                    const ic = indices[i * 3 + 2];

                    const fv1 = new THREE.Vector3().fromBufferAttribute(positionAttr, ia);
                    const fv2 = new THREE.Vector3().fromBufferAttribute(positionAttr, ib);
                    const fv3 = new THREE.Vector3().fromBufferAttribute(positionAttr, ic);

                    const faceNormal = new THREE.Vector3()
                        .crossVectors(
                            new THREE.Vector3().subVectors(fv2, fv1),
                            new THREE.Vector3().subVectors(fv3, fv1)
                        )
                        .normalize();

                    const dot = Math.abs(normal.dot(faceNormal));
                    if (dot > (1 - threshold)) {
                        const shared = [ia, ib, ic].filter(idx => vertexSet.has(idx));
                        if (shared.length >= 2) {
                            vertexSet.add(ia);
                            vertexSet.add(ib);
                            vertexSet.add(ic);
                        }
                    }
                }

                finalizeFaceSelection(obj, faceIndex, positionAttr, normal, Array.from(vertexSet));
                console.log('=== End Face Selection ===');
            } else {
                console.log('Non-indexed geometry detected');

                const a = faceIndex * 3;
                const b = faceIndex * 3 + 1;
                const c = faceIndex * 3 + 2;

                // Get vertex positions (needed for both normal calculation and accumulation)
                const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, a);
                const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, b);
                const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, c);

                // Use the face normal from the intersection (already calculated by Three.js)
                let normal;
                if (intersect.face && intersect.face.normal) {
                    normal = intersect.face.normal.clone();
                } else {
                    // Fallback: calculate from vertex positions
                    normal = new THREE.Vector3()
                        .crossVectors(
                            new THREE.Vector3().subVectors(v2, v1),
                            new THREE.Vector3().subVectors(v3, v1)
                        )
                        .normalize();
                }

                console.log('Computed face normal (local, non-indexed):', normal);

                const threshold = 0.01;
                const posThreshold = 0.001;
                const vertexSet = new Set([a, b, c]);
                const accumulatedPositions = [v1.clone(), v2.clone(), v3.clone()];
                const faceCount = positionAttr.count / 3;

                for (let i = 0; i < faceCount; i++) {
                    if (i === faceIndex) continue;

                    const ia = i * 3;
                    const ib = i * 3 + 1;
                    const ic = i * 3 + 2;

                    const fv1 = new THREE.Vector3().fromBufferAttribute(positionAttr, ia);
                    const fv2 = new THREE.Vector3().fromBufferAttribute(positionAttr, ib);
                    const fv3 = new THREE.Vector3().fromBufferAttribute(positionAttr, ic);

                    const faceNormal = new THREE.Vector3()
                        .crossVectors(
                            new THREE.Vector3().subVectors(fv2, fv1),
                            new THREE.Vector3().subVectors(fv3, fv1)
                        )
                        .normalize();

                    const dot = Math.abs(normal.dot(faceNormal));
                    if (dot > (1 - threshold)) {
                        const candidatePositions = [fv1, fv2, fv3];
                        const sharedPositions = candidatePositions.filter(candidatePos =>
                            accumulatedPositions.some(existing => existing.distanceTo(candidatePos) < posThreshold)
                        );
                        if (sharedPositions.length >= 2) {
                            vertexSet.add(ia);
                            vertexSet.add(ib);
                            vertexSet.add(ic);
                            accumulatedPositions.push(fv1.clone(), fv2.clone(), fv3.clone());
                        }
                    }
                }

                finalizeFaceSelection(obj, faceIndex, positionAttr, normal, Array.from(vertexSet));
                console.log('=== End Face Selection (Non-Indexed) ===');
            }
        }

        function selectEdge(obj, intersect) {
            clearSelectionHighlights();
            
            selectedObject = obj;
            selectedFace = null;
            selectedVertex = null;
            
            console.log('=== Edge Selection Debug ===');
            console.log('Selecting edge, intersect:', intersect);
            
            const geometry = obj.geometry;
            const faceIndex = intersect.faceIndex;
            
            if (faceIndex !== undefined) {
                let a, b, c;
                
                if (geometry.index) {
                    // Indexed geometry
                    const indices = geometry.index.array;
                    a = indices[faceIndex * 3];
                    b = indices[faceIndex * 3 + 1];
                    c = indices[faceIndex * 3 + 2];
                } else {
                    // Non-indexed geometry
                    a = faceIndex * 3;
                    b = faceIndex * 3 + 1;
                    c = faceIndex * 3 + 2;
                }
                
                const positionAttr = geometry.attributes.position;
                const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, a);
                const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, b);
                const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, c);

                console.log('Triangle vertices (local):', {v1, v2, v3});

                const localFaceNormal = new THREE.Vector3()
                    .crossVectors(
                        new THREE.Vector3().subVectors(v2, v1),
                        new THREE.Vector3().subVectors(v3, v1)
                    )
                    .normalize();

                // Transform to world space
                obj.updateMatrixWorld();
                v1.applyMatrix4(obj.matrixWorld);
                v2.applyMatrix4(obj.matrixWorld);
                v3.applyMatrix4(obj.matrixWorld);
                const worldFaceNormal = localFaceNormal.clone().transformDirection(obj.matrixWorld).normalize();
                
                console.log('Triangle vertices (world):', {v1, v2, v3});
                
                // Find closest edge to click point
                const point = intersect.point;
                const edges = [
                    {start: v1.clone(), end: v2.clone(), indices: [a, b]},
                    {start: v2.clone(), end: v3.clone(), indices: [b, c]},
                    {start: v3.clone(), end: v1.clone(), indices: [c, a]}
                ];
                
                let closestEdge = edges[0];
                let minDist = Infinity;
                
                edges.forEach(edge => {
                    const mid = new THREE.Vector3()
                        .addVectors(edge.start, edge.end)
                        .multiplyScalar(0.5);
                    const dist = point.distanceTo(mid);
                    console.log('Edge distance:', dist, 'from', edge.start, 'to', edge.end);
                    if (dist < minDist) {
                        minDist = dist;
                        closestEdge = edge;
                    }
                });
                
                // CRITICAL: Find ALL vertex indices at the edge endpoints
                // We need to store these for scaling to work after the vertices move
                const localV1 = new THREE.Vector3().fromBufferAttribute(positionAttr, closestEdge.indices[0]);
                const localV2 = new THREE.Vector3().fromBufferAttribute(positionAttr, closestEdge.indices[1]);
                
                const threshold = 0.05;
                const startIndices = [];
                const endIndices = [];
                
                for (let i = 0; i < positionAttr.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                    if (v.distanceTo(localV1) < threshold) {
                        startIndices.push(i);
                    } else if (v.distanceTo(localV2) < threshold) {
                        endIndices.push(i);
                    }
                }
                
                console.log('Found edge vertex indices:', {
                    start: startIndices,
                    end: endIndices
                });
                
                // Store edge data with indices and local positions
                selectedEdge = {
                    start: closestEdge.start.clone(),  // world-space
                    end: closestEdge.end.clone(),      // world-space
                    localStart: localV1.clone(),       // object-space
                    localEnd: localV2.clone(),         // object-space
                    localNormal: localFaceNormal.clone(),
                    worldNormal: worldFaceNormal.clone(),
                    index1: closestEdge.indices[0],
                    index2: closestEdge.indices[1],
                    indices: {
                        start: startIndices,
                        end: endIndices
                    }
                };

                console.log('Selected edge:', selectedEdge, 'distance:', minDist);
                
                // Update edge highlight - TWO SPHERES at the endpoints
                const sphere1 = edgeHighlight.userData.sphere1;
                const sphere2 = edgeHighlight.userData.sphere2;
                
                sphere1.position.copy(closestEdge.start);
                sphere2.position.copy(closestEdge.end);
                
                edgeHighlight.visible = true;
                
                console.log('Edge highlight updated (TWO SPHERES):', {
                    visible: edgeHighlight.visible,
                    sphere1Pos: closestEdge.start,
                    sphere2Pos: closestEdge.end
                });
                
                // Show gizmo at edge center
                const edgeCenter = new THREE.Vector3()
                    .addVectors(closestEdge.start, closestEdge.end)
                    .multiplyScalar(0.5);
                
                if (transformMode !== 'select') {
                    transformGizmo.visible = true;
                    transformGizmo.position.copy(edgeCenter);
                }
                alignTransformGizmo();

                console.log('=== End Edge Selection ===');
            } else {
                console.error('No face index for edge selection');
            }
        }
        
        function selectVertex(obj, intersect) {
            clearSelectionHighlights();
            
            selectedObject = obj;
            selectedFace = null;
            selectedEdge = null;
            
            console.log('Selecting vertex, intersect:', intersect);
            
            const geometry = obj.geometry;
            const faceIndex = intersect.faceIndex;
            
            if (faceIndex !== undefined) {
                let a, b, c;
                
                if (geometry.index) {
                    // Indexed geometry
                    const indices = geometry.index.array;
                    a = indices[faceIndex * 3];
                    b = indices[faceIndex * 3 + 1];
                    c = indices[faceIndex * 3 + 2];
                } else {
                    // Non-indexed geometry
                    a = faceIndex * 3;
                    b = faceIndex * 3 + 1;
                    c = faceIndex * 3 + 2;
                }
                
                const positionAttr = geometry.attributes.position;
                const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, a);
                const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, b);
                const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, c);
                
                // Transform to world space
                obj.updateMatrixWorld();
                v1.applyMatrix4(obj.matrixWorld);
                v2.applyMatrix4(obj.matrixWorld);
                v3.applyMatrix4(obj.matrixWorld);
                
                // Find closest vertex to click point
                const point = intersect.point;
                const vertices = [
                    {pos: v1.clone(), index: a},
                    {pos: v2.clone(), index: b},
                    {pos: v3.clone(), index: c}
                ];
                
                let closestVertex = vertices[0];
                let minDist = Infinity;
                
                vertices.forEach(vertex => {
                    const dist = point.distanceTo(vertex.pos);
                    if (dist < minDist) {
                        minDist = dist;
                        closestVertex = vertex;
                    }
                });
                
                selectedVertex = closestVertex;

                // Initialize selectedVertices array with this vertex
                selectedVertices = [{
                    pos: closestVertex.pos.clone(),
                    index: closestVertex.index
                }];
                console.log('Vertex selected:', closestVertex, 'visible:', vertexHighlight.visible);
                console.log('â†’ selectedVertices array initialized with', selectedVertices.length, 'vertex');

                // Update visual highlights
                updateMultiVertexHighlights();

                // Show gizmo at vertex
                if (transformMode !== 'select') {
                    transformGizmo.visible = true;
                    transformGizmo.position.copy(closestVertex.pos);
                }
                alignTransformGizmo();
            } else {
                console.error('No face index for vertex selection');
            }
        }

        // Direct vertex selection by index (when clicking vertex helpers)
        // Supports multi-selection with shift key
        function selectVertexDirect(obj, vertexIndex, vertexPos, isShiftHeld) {
            console.log('selectVertexDirect called - Shift:', isShiftHeld, 'Index:', vertexIndex, 'Current selection count:', selectedVertices.length);

            selectedObject = obj;
            selectedFace = null;
            selectedEdge = null;

            // If shift is held, add to selection; otherwise replace selection
            if (isShiftHeld && selectedVertices.length > 0) {
                // Check if this vertex is already selected
                const alreadySelected = selectedVertices.some(v => v.index === vertexIndex);

                if (alreadySelected) {
                    // Deselect this vertex
                    selectedVertices = selectedVertices.filter(v => v.index !== vertexIndex);
                    console.log('âœ“ Vertex DESELECTED:', vertexIndex, 'â†’ Total selected:', selectedVertices.length);
                } else {
                    // Add to selection
                    selectedVertices.push({
                        pos: vertexPos.clone(),
                        index: vertexIndex
                    });
                    console.log('âœ“ Vertex ADDED to selection:', vertexIndex, 'â†’ Total selected:', selectedVertices.length);
                }
            } else {
                // Replace selection with this single vertex
                const reason = !isShiftHeld ? 'no shift key' : 'empty selection';
                selectedVertices = [{
                    pos: vertexPos.clone(),
                    index: vertexIndex
                }];
                console.log('âœ“ Single vertex selected:', vertexIndex, '(reason:', reason + ')');
            }

            // Set the primary selected vertex (for backwards compatibility)
            if (selectedVertices.length > 0) {
                selectedVertex = selectedVertices[selectedVertices.length - 1];
            } else {
                selectedVertex = null;
            }

            // Update visual highlights for all selected vertices
            updateMultiVertexHighlights();

            // Show gizmo at the center of all selected vertices
            if (transformMode !== 'select' && selectedVertex) {
                transformGizmo.visible = true;
                // Calculate center of all selected vertices
                if (selectedVertices.length > 1) {
                    const center = new THREE.Vector3();
                    selectedVertices.forEach(v => center.add(v.pos));
                    center.divideScalar(selectedVertices.length);
                    transformGizmo.position.copy(center);
                } else {
                    transformGizmo.position.copy(selectedVertex.pos);
                }
                alignTransformGizmo();
            }
        }

        // Update visual highlights for multiple selected vertices
        function updateMultiVertexHighlights() {
            clearSelectionHighlights();

            if (selectedVertices.length === 0) {
                return;
            }

            // Show primary vertex highlight at the last selected vertex
            if (selectedVertices.length > 0) {
                const lastVertex = selectedVertices[selectedVertices.length - 1];
                vertexHighlight.position.copy(lastVertex.pos);
                vertexHighlight.visible = true;
            }

            // Update vertex helper colors
            if (selectedObject && vertexHelpers.length > 0) {
                // Get the selected vertex indices
                const selectedIndices = new Set(selectedVertices.map(v => v.index));

                // Color all vertex helpers based on selection state
                vertexHelpers.forEach(helper => {
                    const helperIndex = helper.userData.vertexIndex;
                    const helperParent = helper.userData.parentObject;

                    if (helperParent === selectedObject && selectedIndices.has(helperIndex)) {
                        // Selected: bright red
                        helper.material.color.setHex(0xff0000);
                    } else {
                        // Not selected: also red (same as base color)
                        helper.material.color.setHex(0xff0000);
                    }
                });
            }
        }

        function clearSelectionHighlights() {
            faceHighlight.visible = false;
            edgeHighlight.visible = false;
            vertexHighlight.visible = false;

            // Clear multi-face highlights from box selection
            multiFaceHighlights.forEach(highlight => {
                scene.remove(highlight);
                highlight.geometry?.dispose();
                highlight.material?.dispose();
            });
            multiFaceHighlights = [];
            selectedFaces = [];
        }
        
        /**
         * Creates an edge key from two vertex indices (order-independent)
         */
        function makeEdgeKey(v1, v2) {
            return v1 < v2 ? `${v1}_${v2}` : `${v2}_${v1}`;
        }

        /**
         * Builds a BufferGeometry for LineSegments from an array of edge pairs
         * @param {Array} edgePairs - Array of [v1Index, v2Index, v1Pos, v2Pos] tuples
         * @returns {THREE.BufferGeometry}
         */
        function buildEdgeGeometry(edgePairs) {
            const positions = [];
            for (const [v1Idx, v2Idx, v1Pos, v2Pos] of edgePairs) {
                positions.push(v1Pos.x, v1Pos.y, v1Pos.z);
                positions.push(v2Pos.x, v2Pos.y, v2Pos.z);
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            return geometry;
        }

        /**
         * Marks an edge as hidden in the wireframe
         * @param {THREE.Mesh} object - The mesh object
         * @param {number} v1 - First vertex index
         * @param {number} v2 - Second vertex index
         */
        function markEdgeHidden(object, v1, v2) {
            if (!object.userData.hiddenEdges) {
                object.userData.hiddenEdges = new Set();
            }
            const key = makeEdgeKey(v1, v2);
            object.userData.hiddenEdges.add(key);
            updateWireframe(object);
            console.log(`Edge ${key} marked as hidden`);
        }

        /**
         * Marks an edge as visible in the wireframe
         * @param {THREE.Mesh} object - The mesh object
         * @param {number} v1 - First vertex index
         * @param {number} v2 - Second vertex index
         */
        function markEdgeVisible(object, v1, v2) {
            if (!object.userData.hiddenEdges) return;
            const key = makeEdgeKey(v1, v2);
            object.userData.hiddenEdges.delete(key);
            updateWireframe(object);
            console.log(`Edge ${key} marked as visible`);
        }

        /**
         * Shows all edges (clears hidden edge list)
         * @param {THREE.Mesh} object - The mesh object
         */
        function showAllEdges(object) {
            if (object.userData.hiddenEdges) {
                object.userData.hiddenEdges.clear();
                updateWireframe(object);
                console.log('All edges shown');
            }
        }

        /**
         * Updates the wireframe of an object after geometry has been modified
         * This is necessary because EdgesGeometry doesn't automatically update
         * when the underlying BufferGeometry changes
         *
         * Supports selective edge visibility via userData.hiddenEdges Set
         *
         * @param {THREE.Mesh} object - The mesh whose wireframe needs updating
         */
        function updateWireframe(object) {
            // Remove old wireframe if it exists
            if (object.userData.wireframe) {
                object.remove(object.userData.wireframe);
                object.userData.wireframe.geometry.dispose();
            }

            // Remove old edge visualization if it exists
            if (object.userData.edgeVisualization) {
                object.remove(object.userData.edgeVisualization);
                object.userData.edgeVisualization.geometry.dispose();
            }

            // Get all edges from geometry
            const edgesGeom = new THREE.EdgesGeometry(object.geometry);
            const edgePositions = edgesGeom.attributes.position.array;
            const positionAttr = object.geometry.attributes.position;

            // Build list of all edges with their vertex indices
            const allEdges = [];
            const precision = 1e-6;

            for (let i = 0; i < edgePositions.length; i += 6) {
                // Each edge is 2 vertices * 3 components
                const v1Pos = new THREE.Vector3(edgePositions[i], edgePositions[i+1], edgePositions[i+2]);
                const v2Pos = new THREE.Vector3(edgePositions[i+3], edgePositions[i+4], edgePositions[i+5]);

                // Find vertex indices by position matching
                let v1Idx = -1, v2Idx = -1;
                for (let j = 0; j < positionAttr.count; j++) {
                    const px = positionAttr.getX(j);
                    const py = positionAttr.getY(j);
                    const pz = positionAttr.getZ(j);

                    if (v1Idx === -1 && Math.abs(px - v1Pos.x) < precision &&
                        Math.abs(py - v1Pos.y) < precision && Math.abs(pz - v1Pos.z) < precision) {
                        v1Idx = j;
                    }
                    if (v2Idx === -1 && Math.abs(px - v2Pos.x) < precision &&
                        Math.abs(py - v2Pos.y) < precision && Math.abs(pz - v2Pos.z) < precision) {
                        v2Idx = j;
                    }

                    if (v1Idx !== -1 && v2Idx !== -1) break;
                }

                if (v1Idx !== -1 && v2Idx !== -1) {
                    allEdges.push([v1Idx, v2Idx, v1Pos, v2Pos]);
                }
            }

            edgesGeom.dispose(); // Clean up temporary geometry

            // Split edges into visible and hidden based on userData.hiddenEdges
            const hiddenEdges = object.userData.hiddenEdges || new Set();
            const visibleEdges = [];
            const hiddenEdgeList = [];

            for (const edge of allEdges) {
                const [v1Idx, v2Idx, v1Pos, v2Pos] = edge;
                const key = makeEdgeKey(v1Idx, v2Idx);

                if (hiddenEdges.has(key)) {
                    hiddenEdgeList.push(edge);
                } else {
                    visibleEdges.push(edge);
                }
            }

            // Create visible wireframe (white, bright)
            if (visibleEdges.length > 0) {
                const visibleGeom = buildEdgeGeometry(visibleEdges);
                const line = new THREE.LineSegments(
                    visibleGeom,
                    new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 })
                );
                object.add(line);
                object.userData.wireframe = line;
            }

            // Create hidden edge visualization (gray, dim)
            if (hiddenEdgeList.length > 0) {
                const hiddenGeom = buildEdgeGeometry(hiddenEdgeList);
                const edgeVis = new THREE.LineSegments(
                    hiddenGeom,
                    new THREE.LineBasicMaterial({
                        color: 0x444444,  // Darker gray for hidden edges
                        linewidth: 1,
                        transparent: true,
                        opacity: 0.2  // Very dim
                    })
                );
                object.add(edgeVis);
                object.userData.edgeVisualization = edgeVis;
            }

            // CRITICAL: Recompute bounding sphere for raycasting after geometry changes
            object.geometry.computeBoundingBox();
            object.geometry.computeBoundingSphere();
            object.updateMatrixWorld();

            if (!object.userData?.isMirrorClone && object.userData?.mirror) {
                rebuildMirrorGeometry(object);
            }
        }

        // Expose edge visibility API to window for console testing
        window.edgeAPI = {
            hide: markEdgeHidden,
            show: markEdgeVisible,
            showAll: showAllEdges,
            getObjects: () => objects,  // Access to objects array
            getSelected: () => selectedObject,  // Access to currently selected object
            help: function() {
                console.log('Edge Visibility API:');
                console.log('  edgeAPI.hide(object, v1, v2) - Hide edge between vertices v1 and v2');
                console.log('  edgeAPI.show(object, v1, v2) - Show edge between vertices v1 and v2');
                console.log('  edgeAPI.showAll(object) - Show all edges');
                console.log('  edgeAPI.getObjects() - Get all objects in scene');
                console.log('  edgeAPI.getSelected() - Get currently selected object');
                console.log('');
                console.log('Example usage:');
                console.log('  const obj = edgeAPI.getObjects()[0];  // Get first object');
                console.log('  edgeAPI.hide(obj, 0, 1);              // Hide edge 0-1');
                console.log('  edgeAPI.hide(obj, 1, 2);              // Hide edge 1-2');
                console.log('  edgeAPI.showAll(obj);                 // Show all edges');
                console.log('');
                console.log('Or use the selected object:');
                console.log('  edgeAPI.hide(edgeAPI.getSelected(), 0, 1);');
            }
        };

        /**
         * Moves all vertices that make up a selected face
         * CRITICAL: In indexed geometry, multiple indices can point to the same vertex position
         * We must find ALL indices at each position and move them together to keep the mesh connected
         * 
         * @param {THREE.Vector3} movement - The world-space movement vector
         */
        function moveFaceVertices(movement) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            // Handle both single face (selectedFace) and multiple faces (selectedFaces)
            const facesToProcess = selectedFaces.length > 0 ? selectedFaces :
                                  selectedFace ? [selectedFace] : [];

            if (facesToProcess.length === 0) {
                console.error('No face data to move!');
                return;
            }

            console.log(`=== Moving ${facesToProcess.length} Face(s) ===`);

            // STEP 1: Get the actual POSITIONS of all vertices we want to move
            const positionsToMove = [];
            facesToProcess.forEach(face => {
                if (!face.vertexIndices) {
                    console.warn('Face missing vertexIndices:', face);
                    return;
                }
                face.vertexIndices.forEach(idx => {
                    const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                    positionsToMove.push(pos);
                });
            });

            console.log('Target positions to move:', positionsToMove);
            const localCenterBefore = new THREE.Vector3();
            positionsToMove.forEach(pos => localCenterBefore.add(pos));
            localCenterBefore.divideScalar(positionsToMove.length);
            
            // STEP 2: Find ALL vertex indices in the entire geometry that have these positions
            // This is the key fix - we need to move every vertex that's at these locations
            const allIndicesToMove = new Set();
            const threshold = 0.0001; // Very small threshold for position matching
            
            for (let i = 0; i < positionAttr.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                
                // Check if this vertex is at any of the positions we want to move
                for (let targetPos of positionsToMove) {
                    if (v.distanceTo(targetPos) < threshold) {
                        allIndicesToMove.add(i);
                        break; // Found a match, no need to check other positions
                    }
                }
            }
            
            console.log(`Found ${allIndicesToMove.size} total vertex indices to move (including duplicates)`);
            console.log('All indices:', Array.from(allIndicesToMove));
            
            // STEP 3: Convert world-space movement to local object space
            selectedObject.updateMatrixWorld();
            const worldCenterBefore = localCenterBefore.clone().applyMatrix4(selectedObject.matrixWorld);
            const worldCenterAfter = worldCenterBefore.clone().add(movement);
            const localCenterAfter = worldCenterAfter.clone();
            selectedObject.worldToLocal(localCenterAfter);
            const localMovement = localCenterAfter.sub(localCenterBefore);
            
            console.log('World movement:', movement, 'Local movement:', localMovement);
            
            // STEP 4: Move ALL vertices at those positions
            const movedPositions = [];
            allIndicesToMove.forEach(vertexIndex => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, vertexIndex);
                const before = v.clone();
                v.add(localMovement);
                positionAttr.setXYZ(vertexIndex, v.x, v.y, v.z);

                console.log(`  Moved vertex ${vertexIndex}: ${before.toArray().map(n => n.toFixed(3))} -> ${v.toArray().map(n => n.toFixed(3))}`);

                movedPositions.push(v.clone());
            });

            // Apply symmetry if enabled
            if (symmetryEnabled) {
                applySymmetricTransform(geometry, Array.from(allIndicesToMove), localMovement);
            }

            // Mark geometry as needing update
            positionAttr.needsUpdate = true;

            // Recompute normals for proper lighting after deformation
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();

            // Update the wireframe to reflect the new geometry
            updateWireframe(selectedObject);
            
            console.log('Geometry updated, wireframe refreshed');
            
            // STEP 5: Update face highlight to follow the moved face
            selectedObject.updateMatrixWorld();

            // Recalculate the face center from the CURRENT positions of the moved vertices
            // We need to get fresh positions from the geometry, not use the old movedPositions
            const currentPositions = [];
            selectedFace.vertexIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const worldV = v.clone().applyMatrix4(selectedObject.matrixWorld);
                currentPositions.push(worldV);
            });
            
            console.log('Current vertex positions after move (world):', currentPositions);
            
            // Remove duplicates for accurate center calculation
            const uniqueCurrentPositions = [];
            const posThreshold = 0.001;
            currentPositions.forEach(pos => {
                const isDuplicate = uniqueCurrentPositions.some(existing => 
                    existing.distanceTo(pos) < posThreshold
                );
                if (!isDuplicate) {
                    uniqueCurrentPositions.push(pos);
                }
            });
            
            console.log('Unique positions for center calc:', uniqueCurrentPositions.length);
            
            // Calculate new center
            const newCenter = new THREE.Vector3();
            uniqueCurrentPositions.forEach(v => {
                newCenter.add(v);
            });
            newCenter.divideScalar(uniqueCurrentPositions.length);
            
            // Recalculate the normal from current vertex positions
            if (uniqueCurrentPositions.length >= 3) {
                const v1 = uniqueCurrentPositions[0];
                const v2 = uniqueCurrentPositions[1];
                const v3 = uniqueCurrentPositions[2];
                
                const newNormal = new THREE.Vector3();
                newNormal.crossVectors(
                    new THREE.Vector3().subVectors(v2, v1),
                    new THREE.Vector3().subVectors(v3, v1)
                ).normalize();
                
                console.log('Recalculated normal:', newNormal);
                
                // Update stored normals and centers
                const localNormal = newNormal.clone();
                const invMatrix = selectedObject.matrixWorld.clone().invert();
                localNormal.transformDirection(invMatrix).normalize();
                selectedFace.normal = localNormal;
                selectedFace.worldNormal = newNormal.clone();
                const localCenter = newCenter.clone();
                selectedObject.worldToLocal(localCenter);
                selectedFace.localCenter = localCenter;
                selectedFace.worldCenter = newCenter.clone();
                
                // Offset the highlight along the normal
                const offset = 0.02;
                const offsetCenter = newCenter.clone().add(newNormal.multiplyScalar(offset));
                
                // Update face highlight position and orientation
                faceHighlight.position.copy(offsetCenter);
                faceHighlight.lookAt(offsetCenter.clone().add(newNormal));
                
                // Recalculate size based on current vertex positions
                let maxDist = 0;
                for (let i = 0; i < uniqueCurrentPositions.length; i++) {
                    for (let j = i + 1; j < uniqueCurrentPositions.length; j++) {
                        const dist = uniqueCurrentPositions[i].distanceTo(uniqueCurrentPositions[j]);
                        if (dist > maxDist) maxDist = dist;
                    }
                }
                
                const newSize = maxDist * 0.75;  // Balanced for better coverage
                faceHighlight.scale.set(newSize, newSize, 1);
                
                console.log('Updated highlight: center=', newCenter, 'offset=', offsetCenter, 'size=', newSize);
            }

            // Update gizmo position with offset away from object center
            if (selectedFace && selectedObject) {
                const toFaceFromCenter = new THREE.Vector3().subVectors(newCenter, selectedObject.position);
                const offsetDir = toFaceFromCenter.lengthSq() > 0 ? toFaceFromCenter.normalize() : selectedFace.worldNormal.clone().normalize();
                const offset = offsetDir.multiplyScalar(GIZMO_FACE_OFFSET);
                transformGizmo.position.copy(newCenter).add(offset);
            } else {
                transformGizmo.position.copy(newCenter);
            }
            alignTransformGizmo();

            // Update face highlight geometry for real-time updates
            updateFaceHighlightAfterTransform();

            // Update vertex helpers to reflect new positions
            if (selectionMode !== 'object') {
                updateVertexHelpers(selectedObject);
            }

            console.log('=== End Moving Face ===');
        }
        
        /**
         * Moves the two vertices that make up a selected edge
         * Edges can be shared by multiple faces, so we find ALL vertices at those positions
         * 
         * @param {THREE.Vector3} movement - The world-space movement vector
         */
        /**
         * Moves the two vertices that make up a selected edge
         * Uses stored indices to track vertices even after they move
         * 
         * @param {THREE.Vector3} movement - The world-space movement vector
         */
        function moveEdgeVertices(movement) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            if (!selectedEdge || !selectedEdge.indices) {
                console.error('No edge selected or no indices stored!');
                console.error('selectedEdge:', selectedEdge);
                return;
            }

            // Moving edge vertices

            // Use stored indices - with safety checks
            const startIndices = selectedEdge.indices.start || [];
            const endIndices = selectedEdge.indices.end || [];

            if (startIndices.length === 0 && endIndices.length === 0) {
                console.error('No vertex indices found for edge!');
                return;
            }

            const allIndices = [...startIndices, ...endIndices];

            console.log(`Moving ${allIndices.length} vertices (${startIndices.length} start, ${endIndices.length} end)`);

            // Convert world-space movement to local space
            const invMatrix = selectedObject.matrixWorld.clone().invert();
            const localMovement = movement.clone();
            localMovement.applyMatrix4(invMatrix);
            localMovement.sub(new THREE.Vector3().setFromMatrixPosition(invMatrix));

            console.log('Movement (world):', movement, '(local):', localMovement);
            
            // Move all edge vertices
            allIndices.forEach(index => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, index);
                const before = v.clone();
                v.add(localMovement);
                positionAttr.setXYZ(index, v.x, v.y, v.z);
                console.log(`  Moved vertex ${index}: ${before.toArray().map(n => n.toFixed(3))} -> ${v.toArray().map(n => n.toFixed(3))}`);
            });

            // Apply symmetry if enabled
            if (symmetryEnabled) {
                applySymmetricTransform(geometry, allIndices, localMovement);
            }

            // Mark as needing update
            positionAttr.needsUpdate = true;

            // Recompute normals and update wireframe
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);

            // Update edge highlight to follow the moved edge
            const newStart = selectedEdge.start.clone().add(movement);
            const newEnd = selectedEdge.end.clone().add(movement);
            selectedEdge.start.copy(newStart);
            selectedEdge.end.copy(newEnd);

            // Update local positions (with safety checks)
            if (selectedEdge.localStart && selectedEdge.localEnd) {
                selectedEdge.localStart.add(localMovement);
                selectedEdge.localEnd.add(localMovement);
            } else {
                // Recalculate if missing
                selectedEdge.localStart = newStart.clone();
                selectedEdge.localEnd = newEnd.clone();
                selectedObject.worldToLocal(selectedEdge.localStart);
                selectedObject.worldToLocal(selectedEdge.localEnd);
            }
            
            // Update sphere positions
            const sphere1 = edgeHighlight.userData.sphere1;
            const sphere2 = edgeHighlight.userData.sphere2;
            sphere1.position.copy(newStart);
            sphere2.position.copy(newEnd);
            
            // Move gizmo to new edge center
            const newEdgeCenter = new THREE.Vector3()
                .addVectors(newStart, newEnd)
                .multiplyScalar(0.5);
            transformGizmo.position.copy(newEdgeCenter);
            
            console.log('Edge moved to:', newStart, newEnd);
            alignTransformGizmo();

            // Update vertex helpers to reflect new positions
            if (selectionMode !== 'object') {
                updateVertexHelpers(selectedObject);
            }

            console.log('=== End Moving Edge ===');
        }
        
        /**
         * Moves a single vertex (but all instances of it, since vertices are shared)
         * 
         * @param {THREE.Vector3} movement - The world-space movement vector
         */
        /**
         * Moves a single vertex (but all instances of it, since vertices are shared)
         * 
         * @param {THREE.Vector3} movement - The world-space movement vector
         */
        function moveVertex(movement) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            // Handle multiple selected vertices
            const verticesToProcess = selectedVertices.length > 0 ? selectedVertices :
                                     selectedVertex ? [selectedVertex] : [];

            if (verticesToProcess.length === 0) {
                console.log('No vertices to move');
                return;
            }

            selectedObject.updateMatrixWorld();

            // Collect ALL indices to move (including duplicates at same positions)
            const allIndicesToMove = new Set();
            const threshold = 0.001;

            verticesToProcess.forEach(vertex => {
                const worldCurrent = vertex.pos.clone();
                const localPos = worldCurrent.clone();
                selectedObject.worldToLocal(localPos);

                // Find ALL instances of this vertex position in the geometry
                for (let i = 0; i < positionAttr.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                    if (v.distanceTo(localPos) < threshold) {
                        allIndicesToMove.add(i);
                    }
                }
            });

            console.log(`Moving ${allIndicesToMove.size} vertex instances for ${verticesToProcess.length} selected vertices`);

            // Convert world-space movement to local space
            const worldMovement = movement.clone();
            const localMovement = new THREE.Vector3();

            // Create a test point to transform the movement vector
            const testPoint = new THREE.Vector3();
            const movedPoint = testPoint.clone().add(worldMovement);
            selectedObject.worldToLocal(testPoint);
            selectedObject.worldToLocal(movedPoint);
            localMovement.subVectors(movedPoint, testPoint);

            // Move all vertex instances
            allIndicesToMove.forEach(index => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, index);
                v.add(localMovement);
                positionAttr.setXYZ(index, v.x, v.y, v.z);
            });

            // Apply symmetry if enabled
            if (symmetryEnabled) {
                applySymmetricTransform(geometry, Array.from(allIndicesToMove), localMovement);
            }

            // Mark as needing update
            positionAttr.needsUpdate = true;

            // Recompute normals and update wireframe
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);

            // Update all selected vertex positions and the primary vertex
            verticesToProcess.forEach(vertex => {
                vertex.pos.add(movement);
            });

            // Update highlights for the primary vertex (last selected)
            if (selectedVertex) {
                vertexHighlight.position.copy(selectedVertex.pos);
                transformGizmo.position.copy(selectedVertex.pos);
                alignTransformGizmo();
            }

            // Update vertex helpers to reflect new positions
            if (selectionMode !== 'object') {
                updateVertexHelpers(selectedObject);
                // Restore selection colors after recreating helpers
                updateVertexHighlights();
            }
        }
        
        /**
         * Rotates face vertices around the face center
         * 
         * @param {string} axis - 'x', 'y', or 'z'
         * @param {number} angle - Rotation angle in radians
         */
        function rotateFaceVertices(axis, angle) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            if (!selectedFace || !selectedFace.vertexIndices) return;
            
            console.log(`Rotating face around ${axis} by ${angle} radians`);
            
            // Get face center in local space
            const faceCenter = new THREE.Vector3();
            selectedFace.vertexIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                faceCenter.add(v);
            });
            faceCenter.divideScalar(selectedFace.vertexIndices.length);
            
            // Create rotation matrix
            const rotationMatrix = new THREE.Matrix4();
            if (axis === 'x') {
                rotationMatrix.makeRotationX(angle);
            } else if (axis === 'y') {
                rotationMatrix.makeRotationY(angle);
            } else if (axis === 'z') {
                rotationMatrix.makeRotationZ(angle);
            }
            
            // Find all vertex indices at the face positions
            const positionsToRotate = [];
            selectedFace.vertexIndices.forEach(idx => {
                const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                positionsToRotate.push(pos);
            });
            
            const allIndicesToRotate = new Set();
            const threshold = 0.0001;
            
            for (let i = 0; i < positionAttr.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                for (let targetPos of positionsToRotate) {
                    if (v.distanceTo(targetPos) < threshold) {
                        allIndicesToRotate.add(i);
                        break;
                    }
                }
            }
            
            // Rotate all vertices around the face center
            allIndicesToRotate.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                // Translate to origin (face center)
                v.sub(faceCenter);
                // Rotate
                v.applyMatrix4(rotationMatrix);
                // Translate back
                v.add(faceCenter);
                // Update geometry
                positionAttr.setXYZ(idx, v.x, v.y, v.z);
            });

            positionAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);
            
            // Update highlight
            updateFaceHighlightAfterTransform();
        }
        
        /**
         * Scales face vertices from the face center
         * 
         * @param {string} axis - 'x', 'y', or 'z'
         * @param {number} scaleChange - Amount to change scale
         */
        function scaleFaceVertices(axis, scaleChange) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            if (!selectedFace || !selectedFace.vertexIndices) return;
            
            console.log(`Scaling face along ${axis} by ${scaleChange}`);
            
            // Get face center in local space
            const faceCenter = new THREE.Vector3();
            selectedFace.vertexIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                faceCenter.add(v);
            });
            faceCenter.divideScalar(selectedFace.vertexIndices.length);
            
            // Find all vertex indices at the face positions
            const positionsToScale = [];
            selectedFace.vertexIndices.forEach(idx => {
                const pos = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                positionsToScale.push(pos);
            });
            
            const allIndicesToScale = new Set();
            const threshold = 0.0001;
            
            for (let i = 0; i < positionAttr.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                for (let targetPos of positionsToScale) {
                    if (v.distanceTo(targetPos) < threshold) {
                        allIndicesToScale.add(i);
                        break;
                    }
                }
            }
            
            // Scale all vertices from the face center
            allIndicesToScale.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                // Get vector from center to vertex
                const direction = new THREE.Vector3().subVectors(v, faceCenter);

                // If using normal alignment, transform the direction to the gizmo's local space
                const shouldUseNormalAlignment = (selectionMode === 'face' || selectionMode === 'edge') ||
                                                (selectionMode === 'object' && useNormalAlignment);
                if (shouldUseNormalAlignment && transformGizmo) {
                    // Get the gizmo's rotation matrix
                    const gizmoMatrix = new THREE.Matrix4().makeRotationFromQuaternion(transformGizmo.quaternion);
                    const inverseGizmoMatrix = gizmoMatrix.clone().invert();

                    // Transform direction to gizmo space
                    direction.applyMatrix4(inverseGizmoMatrix);

                    // Scale along the specified axis in gizmo space
                    if (axis === 'x') {
                        direction.x *= (1 + scaleChange);
                    } else if (axis === 'y') {
                        direction.y *= (1 + scaleChange);
                    } else if (axis === 'z') {
                        direction.z *= (1 + scaleChange);
                    }

                    // Transform back to object space
                    direction.applyMatrix4(gizmoMatrix);
                } else {
                    // Scale along the specified axis in object space
                    if (axis === 'x') {
                        direction.x *= (1 + scaleChange);
                    } else if (axis === 'y') {
                        direction.y *= (1 + scaleChange);
                    } else if (axis === 'z') {
                        direction.z *= (1 + scaleChange);
                    }
                }
                
                // New position = center + scaled direction
                const newPos = new THREE.Vector3().addVectors(faceCenter, direction);
                positionAttr.setXYZ(idx, newPos.x, newPos.y, newPos.z);
            });

            positionAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);
            
            // Update highlight
            updateFaceHighlightAfterTransform();
        }
        
        /**
         * Rotates edge vertices around the edge center
         */
        function rotateEdgeVertices(axis, angle) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            if (!selectedEdge || !selectedEdge.indices) {
                console.error('No edge selected or no indices stored!');
                return;
            }
            
            console.log('=== Rotating Edge ===');
            console.log(`Rotating edge around ${axis} by ${angle} radians`);
            
            // Get CURRENT positions from stored indices
            const startIndices = selectedEdge.indices.start;
            const endIndices = selectedEdge.indices.end;
            
            console.log('Using stored indices:', startIndices, endIndices);
            
            if (!startIndices || !endIndices || startIndices.length === 0 || endIndices.length === 0) {
                console.error('No valid indices stored for edge!');
                return;
            }
            
            // Get current world positions
            const currentLocalStart = new THREE.Vector3().fromBufferAttribute(positionAttr, startIndices[0]);
            const currentLocalEnd = new THREE.Vector3().fromBufferAttribute(positionAttr, endIndices[0]);
            
            // Calculate edge center in local space
            const localCenter = new THREE.Vector3()
                .addVectors(currentLocalStart, currentLocalEnd)
                .multiplyScalar(0.5);
            
            console.log('Local center:', localCenter);
            
            // Create rotation matrix
            const rotationMatrix = new THREE.Matrix4();
            if (axis === 'x') {
                rotationMatrix.makeRotationX(angle);
            } else if (axis === 'y') {
                rotationMatrix.makeRotationY(angle);
            } else if (axis === 'z') {
                rotationMatrix.makeRotationZ(angle);
            }
            
            console.log(`Rotation matrix created for ${axis} axis`);
            
            // Rotate start vertices around the edge center
            startIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const before = v.clone();
                // Translate to origin (edge center)
                v.sub(localCenter);
                // Rotate
                v.applyMatrix4(rotationMatrix);
                // Translate back
                v.add(localCenter);
                // Update geometry
                positionAttr.setXYZ(idx, v.x, v.y, v.z);
                console.log(`  Rotated start vertex ${idx}: ${before.toArray().map(n => n.toFixed(3))} -> ${v.toArray().map(n => n.toFixed(3))}`);
            });
            
            // Rotate end vertices around the edge center
            endIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const before = v.clone();
                v.sub(localCenter);
                v.applyMatrix4(rotationMatrix);
                v.add(localCenter);
                positionAttr.setXYZ(idx, v.x, v.y, v.z);
                console.log(`  Rotated end vertex ${idx}: ${before.toArray().map(n => n.toFixed(3))} -> ${v.toArray().map(n => n.toFixed(3))}`);
            });
            
            positionAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);

            console.log('Geometry updated, wireframe refreshed');

            // Update highlight
            updateEdgeHighlightAfterTransform();
            
            console.log('=== End Rotating Edge ===');
        }
        
        /**
         * Scales edge along its direction (makes it longer/shorter)
         * This is the ONLY way edges should scale
         * 
         * @param {number} scaleChange - Amount to change scale (cumulative)
         */
        function scaleEdgeAlongDirection(scaleChange) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            if (!selectedEdge) {
                console.error('No edge selected!');
                return;
            }
            
            console.log('=== Scaling Edge Along Direction ===');
            console.log('Scale change:', scaleChange);
            
            // CRITICAL FIX: Re-find the current edge vertices from the stored indices
            // After previous scaling, the positions changed but we still have the original indices
            if (!selectedEdge.indices) {
                console.error('No edge indices stored! Re-selecting edge...');
                // We need to store indices during selection
                return;
            }
            
            const invMatrix = selectedObject.matrixWorld.clone().invert();
            
            // Get CURRENT positions of the edge vertices from the stored indices
            const startIndices = selectedEdge.indices.start;
            const endIndices = selectedEdge.indices.end;
            
            console.log('Using stored indices:', startIndices, endIndices);
            
            if (!startIndices || !endIndices || startIndices.length === 0 || endIndices.length === 0) {
                console.error('No valid indices stored for edge!');
                return;
            }
            
            // Get current world positions of first start and end vertex
            const currentLocalStart = new THREE.Vector3().fromBufferAttribute(positionAttr, startIndices[0]);
            const currentLocalEnd = new THREE.Vector3().fromBufferAttribute(positionAttr, endIndices[0]);
            
            const currentWorldStart = currentLocalStart.clone().applyMatrix4(selectedObject.matrixWorld);
            const currentWorldEnd = currentLocalEnd.clone().applyMatrix4(selectedObject.matrixWorld);
            
            console.log('Current world start:', currentWorldStart);
            console.log('Current world end:', currentWorldEnd);
            
            // Calculate edge center in local space
            const localCenter = new THREE.Vector3()
                .addVectors(currentLocalStart, currentLocalEnd)
                .multiplyScalar(0.5);
            
            console.log('Local center:', localCenter);
            
            // Scale multiplier - much more aggressive
            const scaleFactor = 1 + (scaleChange * 10); // 10x more sensitive
            console.log('Scale factor:', scaleFactor);
            
            if (scaleFactor <= 0.1) {
                console.log('Scale factor too small, clamping to 0.1');
                return; // Don't allow edge to collapse
            }
            
            // Move start vertices away from center
            startIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const dirFromCenter = new THREE.Vector3().subVectors(v, localCenter);
                const scaled = new THREE.Vector3().addVectors(localCenter, dirFromCenter.multiplyScalar(scaleFactor));
                positionAttr.setXYZ(idx, scaled.x, scaled.y, scaled.z);
                console.log(`  Scaled start vertex ${idx}: factor=${scaleFactor.toFixed(3)}`);
            });
            
            // Move end vertices away from center
            endIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const dirFromCenter = new THREE.Vector3().subVectors(v, localCenter);
                const scaled = new THREE.Vector3().addVectors(localCenter, dirFromCenter.multiplyScalar(scaleFactor));
                positionAttr.setXYZ(idx, scaled.x, scaled.y, scaled.z);
                console.log(`  Scaled end vertex ${idx}: factor=${scaleFactor.toFixed(3)}`);
            });
            
            // Mark as needing update
            positionAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);

            console.log('Geometry updated');

            // Update selectedEdge with new positions
            selectedEdge.start.copy(currentWorldStart);
            selectedEdge.end.copy(currentWorldEnd);
            
            // Update edge highlight and gizmo
            updateEdgeHighlightAfterTransform();
            
            console.log('=== End Scaling Edge ===');
        }
        
        /**
         * OLD FUNCTION - Scales edge vertices from the edge center
         * This is being replaced by scaleEdgeAlongDirection
         */
        function scaleEdgeVertices(axis, scaleChange) {
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            if (!selectedEdge) return;
            
            console.log(`=== Scaling Edge ===`);
            console.log(`Scaling edge along ${axis} by ${scaleChange}`);
            
            // Get edge center in world space, convert to local
            const edgeCenter = new THREE.Vector3()
                .addVectors(selectedEdge.start, selectedEdge.end)
                .multiplyScalar(0.5);
            
            const invMatrix = selectedObject.matrixWorld.clone().invert();
            const localCenter = edgeCenter.clone().applyMatrix4(invMatrix);
            
            // Find all vertices at edge endpoints
            const localStart = selectedEdge.start.clone().applyMatrix4(invMatrix);
            const localEnd = selectedEdge.end.clone().applyMatrix4(invMatrix);
            
            console.log('Local center:', localCenter);
            console.log('Local start:', localStart);
            console.log('Local end:', localEnd);
            
            const threshold = 0.01; // Larger threshold
            const verticesToScale = [];
            
            for (let i = 0; i < positionAttr.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, i);
                const distToStart = v.distanceTo(localStart);
                const distToEnd = v.distanceTo(localEnd);
                
                if (distToStart < threshold) {
                    verticesToScale.push({index: i, type: 'start'});
                    console.log(`Vertex ${i} matches START for scaling (dist: ${distToStart.toFixed(4)})`);
                } else if (distToEnd < threshold) {
                    verticesToScale.push({index: i, type: 'end'});
                    console.log(`Vertex ${i} matches END for scaling (dist: ${distToEnd.toFixed(4)})`);
                }
            }
            
            console.log(`Found ${verticesToScale.length} vertices to scale`);
            
            if (verticesToScale.length === 0) {
                console.error('ERROR: No vertices found for edge scaling!');
                return;
            }
            
            // Scale vertices
            verticesToScale.forEach(({index}) => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, index);
                const before = v.clone();
                const direction = new THREE.Vector3().subVectors(v, localCenter);
                
                if (axis === 'x') {
                    direction.x *= (1 + scaleChange);
                } else if (axis === 'y') {
                    direction.y *= (1 + scaleChange);
                } else if (axis === 'z') {
                    direction.z *= (1 + scaleChange);
                }
                
                const newPos = new THREE.Vector3().addVectors(localCenter, direction);
                positionAttr.setXYZ(index, newPos.x, newPos.y, newPos.z);
                
                console.log(`  Scaled vertex ${index}: ${before.toArray().map(n => n.toFixed(3))} -> ${newPos.toArray().map(n => n.toFixed(3))}`);
            });
            
            positionAttr.needsUpdate = true;
            geometry.computeVertexNormals();
            geometry.computeBoundingSphere();
            updateWireframe(selectedObject);

            // Update edge highlight
            updateEdgeHighlightAfterTransform();

            console.log('=== End Scaling Edge ===');
        }
        
        /**
         * Updates face highlight after rotation/scale
         */
        function updateFaceHighlightAfterTransform() {
            if (!selectedObject || !selectedFace || !selectedFace.vertexIndices) {
                return;
            }

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            selectedObject.updateMatrixWorld();

            const vertexIndices = selectedFace.vertexIndices.slice();
            if (vertexIndices.length < 3) {
                console.warn('Not enough vertices to refresh face highlight');
                return;
            }

            const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, vertexIndices[0]);
            const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, vertexIndices[1]);
            const v3 = new THREE.Vector3().fromBufferAttribute(positionAttr, vertexIndices[2]);

            const localNormal = new THREE.Vector3()
                .crossVectors(
                    new THREE.Vector3().subVectors(v2, v1),
                    new THREE.Vector3().subVectors(v3, v1)
                )
                .normalize();

            if (localNormal.lengthSq() === 0) {
                console.warn('Degenerate face normal during highlight update');
                return;
            }

            const faceInfo = buildFaceVertexEntries(vertexIndices, positionAttr, selectedObject, localNormal);
            const worldVertices = faceInfo.orderedEntries.map(entry => entry.world.clone());
            const newGeometry = buildFaceHighlightGeometry(worldVertices, faceInfo.worldNormal);

            if (newGeometry) {
                if (faceHighlight.geometry) {
                    faceHighlight.geometry.dispose();
                }
                faceHighlight.geometry = newGeometry;
                faceHighlight.position.set(0, 0, 0);
                faceHighlight.rotation.set(0, 0, 0);
                faceHighlight.scale.set(1, 1, 1);
                faceHighlight.visible = true;
            }

            selectedFace.normal = faceInfo.localNormal.clone();
            selectedFace.worldNormal = faceInfo.worldNormal.clone();
            selectedFace.localCenter = faceInfo.centerLocal.clone();
            selectedFace.worldCenter = faceInfo.centerWorld.clone();
            selectedFace.vertexIndices = faceInfo.orderedEntries.flatMap(entry => entry.indices.slice());
            selectedFace.loopIndices = faceInfo.orderedEntries.map(entry => entry.index);

            // Offset gizmo away from object center so it sits outside the object
            const toFaceFromCenter = new THREE.Vector3().subVectors(faceInfo.centerWorld, selectedObject.position);
            const offsetDir = toFaceFromCenter.lengthSq() > 0 ? toFaceFromCenter.normalize() : faceInfo.worldNormal.clone().normalize();
            const offset = offsetDir.multiplyScalar(GIZMO_FACE_OFFSET);
            transformGizmo.position.copy(faceInfo.centerWorld).add(offset);
            alignTransformGizmo();
        }
        
        /**
         * Updates edge highlight after rotation/scale
         * Uses stored indices to find current vertex positions
         */
        function updateEdgeHighlightAfterTransform() {
            if (!selectedEdge || !selectedEdge.indices) {
                console.error('Cannot update edge highlight - no edge or indices');
                return;
            }
            
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            selectedObject.updateMatrixWorld();
            
            console.log('=== Updating Edge Highlight ===');
            
            // Get CURRENT positions from the stored indices
            const startIndices = selectedEdge.indices.start;
            const endIndices = selectedEdge.indices.end;
            
            if (!startIndices || !endIndices || startIndices.length === 0 || endIndices.length === 0) {
                console.error('No valid indices to update edge highlight');
                return;
            }
            
            // Get current local positions (use first vertex of each end)
            const currentLocalStart = new THREE.Vector3().fromBufferAttribute(positionAttr, startIndices[0]);
            const currentLocalEnd = new THREE.Vector3().fromBufferAttribute(positionAttr, endIndices[0]);
            
            // Convert to world space
            const newStart = currentLocalStart.clone().applyMatrix4(selectedObject.matrixWorld);
            const newEnd = currentLocalEnd.clone().applyMatrix4(selectedObject.matrixWorld);
            
            console.log('Updated edge positions:', {
                newStart,
                newEnd,
                startIndices: startIndices,
                endIndices: endIndices
            });
            
            // Update selectedEdge with new positions
            selectedEdge.start.copy(newStart);
            selectedEdge.end.copy(newEnd);
            selectedEdge.localStart.copy(currentLocalStart);
            selectedEdge.localEnd.copy(currentLocalEnd);
            if (selectedEdge.localNormal) {
                const updatedWorldNormal = selectedEdge.localNormal.clone().transformDirection(selectedObject.matrixWorld).normalize();
                if (updatedWorldNormal.lengthSq() > 0) {
                    selectedEdge.worldNormal = updatedWorldNormal;
                }
            }
            
            // Update sphere positions
            const sphere1 = edgeHighlight.userData.sphere1;
            const sphere2 = edgeHighlight.userData.sphere2;
            sphere1.position.copy(newStart);
            sphere2.position.copy(newEnd);
            
            console.log('Spheres updated to:', newStart, newEnd);
            
            // Update gizmo position
            const edgeCenter = new THREE.Vector3()
                .addVectors(newStart, newEnd)
                .multiplyScalar(0.5);
            
            transformGizmo.position.copy(edgeCenter);
            alignTransformGizmo();
            
            // If in scale mode, re-orient the edge scale gizmo
            if (transformMode === 'scale' && selectionMode === 'edge') {
                const direction = new THREE.Vector3()
                    .subVectors(newEnd, newStart)
                    .normalize();
                
                const edgeGizmo = transformGizmo.userData.gizmos.edgeScale;
                if (edgeGizmo) {
                    edgeGizmo.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        direction
                    );
                }
            }
            
            console.log('=== End Updating Edge Highlight ===');
        }

        /**
         * ============================================================================
         * DEBUG TOOLS
         * ============================================================================
         */

        /**
         * Exports geometry data to clipboard for debugging
         */
        function exportGeometry() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            const vertexCount = positionAttr.count;

            console.log('\n' + '='.repeat(80));
            console.log('GEOMETRY DEBUG EXPORT');
            console.log('='.repeat(80));
            console.log('Object:', selectedObject.name || selectedObject.uuid);
            console.log('Vertex Count:', vertexCount);
            console.log('Triangle Count:', vertexCount / 3);

            // Build detailed vertex and triangle data
            const vertices = [];
            for (let i = 0; i < vertexCount; i++) {
                vertices.push({
                    index: i,
                    x: positionAttr.getX(i),
                    y: positionAttr.getY(i),
                    z: positionAttr.getZ(i)
                });
            }

            const triangles = [];
            for (let i = 0; i < vertexCount; i += 3) {
                triangles.push({
                    index: i / 3,
                    v0: i,
                    v1: i + 1,
                    v2: i + 2,
                    vertices: [
                        [positionAttr.getX(i), positionAttr.getY(i), positionAttr.getZ(i)],
                        [positionAttr.getX(i+1), positionAttr.getY(i+1), positionAttr.getZ(i+1)],
                        [positionAttr.getX(i+2), positionAttr.getY(i+2), positionAttr.getZ(i+2)]
                    ]
                });
            }

            const exportData = {
                objectName: selectedObject.name || selectedObject.uuid,
                vertexCount: vertexCount,
                triangleCount: vertexCount / 3,
                vertices: vertices,
                triangles: triangles
            };

            // Log to console
            console.log('\nVERTICES:');
            vertices.forEach(v => {
                console.log(`  [${v.index}] (${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)})`);
            });

            console.log('\nTRIANGLES:');
            triangles.forEach(t => {
                console.log(`  Triangle ${t.index}: [${t.v0}, ${t.v1}, ${t.v2}]`);
                console.log(`    v0: [${t.vertices[0].join(', ')}]`);
                console.log(`    v1: [${t.vertices[1].join(', ')}]`);
                console.log(`    v2: [${t.vertices[2].join(', ')}]`);
            });

            // Copy to clipboard
            const jsonString = JSON.stringify(exportData, null, 2);
            navigator.clipboard.writeText(jsonString).then(() => {
                console.log('\nÃ¢Å“â€œ Geometry data copied to clipboard');
                console.log('='.repeat(80) + '\n');
                alert('Geometry data copied to clipboard!\nCheck console for detailed output.');
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                console.log('\nÃ¢Å“â€” Failed to copy to clipboard');
                console.log('='.repeat(80) + '\n');
                alert('Failed to copy to clipboard. Check console for data.');
            });
        }

        /**
         * Exports geometry to vicVECTOR entity format
         * Exports full 3D BufferGeometry for THREE.js import
         */
        function exportToVicVector() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            // Clone and center the geometry
            const geometry = selectedObject.geometry.clone();
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();

            const center = new THREE.Vector3();
            geometry.boundingBox.getCenter(center);
            geometry.translate(-center.x, -center.y, -center.z);

            // Scale to vicVECTOR world units (approximately 25x smaller)
            const scaleToGame = 0.04;
            geometry.scale(scaleToGame, scaleToGame, scaleToGame);

            const positionAttr = geometry.attributes.position;
            const vertexCount = positionAttr.count;

            console.log('\n' + '='.repeat(80));
            console.log('EXPORTING TO VICVECTOR 3D FORMAT');
            console.log('='.repeat(80));
            console.log('Object:', selectedObject.name || selectedObject.uuid);
            console.log('Vertex count:', vertexCount);
            console.log('Triangle count:', vertexCount / 3);

            // Extract all vertices as Float32Array
            const positions = [];
            for (let i = 0; i < vertexCount; i++) {
                positions.push(
                    Math.round(positionAttr.getX(i) * 1000) / 1000, // Round to 3 decimals
                    Math.round(positionAttr.getY(i) * 1000) / 1000,
                    Math.round(positionAttr.getZ(i) * 1000) / 1000
                );
            }

            console.log('Extracted', positions.length / 3, 'vertices');
            console.log('Bounding sphere radius:', geometry.boundingSphere.radius.toFixed(3));

            // Generate entity definition in vicVECTOR format with customGeometry
            const entityId = (selectedObject.name || 'custom_shape').toLowerCase().replace(/\s+/g, '_');
            const entityName = selectedObject.name || 'Custom Shape';

            // Format positions array in chunks of 9 values (3 vertices = 1 triangle) for readability
            let positionsStr = '[\n';
            for (let i = 0; i < positions.length; i += 9) {
                positionsStr += '                        ';
                positionsStr += positions.slice(i, i + 9).join(', ');
                if (i + 9 < positions.length) {
                    positionsStr += ',';
                }
                positionsStr += '\n';
            }
            positionsStr += '                    ]';

            const entityDefinition = `    ${entityId}: {
        id: '${entityId}',
        name: '${entityName}',
        stats: {
            baseHealth: 20,
            baseSpeed: 1.0,
            collisionDamage: 10,
            collisionDamageMultiplier: 1.0,
            scoreValue: 20,
            xpValue: 15,
            aggroRadius: 300,
            collisionRadius: ${Math.round(geometry.boundingSphere.radius * 50 * 10) / 10},
        },
        behavior: {
            aiType: 'ChaseAndShoot',
            aiParams: {
                preferredDistance: 300,
            }
        },
        weapon: {
            shootInterval: 2000,
            projectileType: 'enemy_bullet_basic',
            projectileDamage: { min: 3, max: 5 },
            muzzlePoints: [{ x: 0, y: -${Math.round(geometry.boundingSphere.radius * 50 * 10) / 10} }]
        },
        graphics: {
            type: 'customGeometry',
            customGeometry: {
                positions: ${positionsStr},
                vertexCount: ${vertexCount},
                triangleCount: ${vertexCount / 3}
            },
            color: '#FF0000',
            fillColor: '#FFFFFF'
        },
        sounds: {}
    },`;

            // Copy to clipboard
            navigator.clipboard.writeText(entityDefinition).then(() => {
                console.log('\nÃ¢Å“â€œ Entity definition copied to clipboard');
                console.log('='.repeat(80) + '\n');
                console.log('PREVIEW (first 500 chars):');
                console.log(entityDefinition.substring(0, 500) + '...');
                console.log('='.repeat(80) + '\n');
                alert(`Ã¢Å“â€œ vicVECTOR 3D entity exported!\n\nEntity ID: ${entityId}\nVertices: ${vertexCount}\nTriangles: ${vertexCount / 3}\n\nPaste into gameData.js enemyTypes section.\n\nNOTE: You'll need to update vicVECTOR.html createEnemy() to support customGeometry.`);
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                console.log('\nÃ¢Å“â€” Failed to copy to clipboard');
                console.log('='.repeat(80) + '\n');
                alert('Failed to copy to clipboard. Check console for entity definition.');
            });
        }

        /**
         * Generates binary STL data from a Three.js geometry
         */
        function generateBinarySTL(geometry) {
            const triangles = geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3;
            const bufferSize = 80 + 4 + (50 * triangles); // Header + triangle count + (50 bytes per triangle)
            const buffer = new ArrayBuffer(bufferSize);
            const view = new DataView(buffer);

            // Write 80-byte header (all zeros is fine)
            for (let i = 0; i < 80; i++) {
                view.setUint8(i, 0);
            }

            // Write triangle count
            view.setUint32(80, triangles, true); // true = little endian

            const positions = geometry.attributes.position.array;
            const indices = geometry.index ? geometry.index.array : null;

            let offset = 84; // Start after header and count

            for (let i = 0; i < triangles; i++) {
                let i0, i1, i2;

                if (indices) {
                    i0 = indices[i * 3];
                    i1 = indices[i * 3 + 1];
                    i2 = indices[i * 3 + 2];
                } else {
                    i0 = i * 3;
                    i1 = i * 3 + 1;
                    i2 = i * 3 + 2;
                }

                const v0 = new THREE.Vector3(positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2]);
                const v1 = new THREE.Vector3(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
                const v2 = new THREE.Vector3(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);

                // Calculate normal
                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                // Write normal (12 bytes: 3 floats)
                view.setFloat32(offset, normal.x, true); offset += 4;
                view.setFloat32(offset, normal.y, true); offset += 4;
                view.setFloat32(offset, normal.z, true); offset += 4;

                // Write vertices (36 bytes: 9 floats)
                view.setFloat32(offset, v0.x, true); offset += 4;
                view.setFloat32(offset, v0.y, true); offset += 4;
                view.setFloat32(offset, v0.z, true); offset += 4;

                view.setFloat32(offset, v1.x, true); offset += 4;
                view.setFloat32(offset, v1.y, true); offset += 4;
                view.setFloat32(offset, v1.z, true); offset += 4;

                view.setFloat32(offset, v2.x, true); offset += 4;
                view.setFloat32(offset, v2.y, true); offset += 4;
                view.setFloat32(offset, v2.z, true); offset += 4;

                // Write attribute byte count (2 bytes, always 0)
                view.setUint16(offset, 0, true); offset += 2;
            }

            return buffer;
        }

        /**
         * Exports the selected geometry as an STL file
         */
        function exportSTL() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            // Get object name for filename
            const objectName = (selectedObject.name || 'model').toLowerCase().replace(/\s+/g, '_');

            // Clone and prepare geometry
            const geometry = selectedObject.geometry.clone();
            geometry.computeVertexNormals();

            // Generate binary STL
            const stlData = generateBinarySTL(geometry);

            // Create download
            const blob = new Blob([stlData], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${objectName}.stl`;
            link.click();
            URL.revokeObjectURL(url);

            const vertexCount = geometry.attributes.position.count;
            const triangleCount = vertexCount / 3;

            console.log('\n' + '='.repeat(80));
            console.log('EXPORTED STL FILE');
            console.log('='.repeat(80));
            console.log('Filename:', `${objectName}.stl`);
            console.log('Vertices:', vertexCount);
            console.log('Triangles:', triangleCount);
            console.log('='.repeat(80) + '\n');

            alert(`âœ“ STL exported!\n\nFilename: ${objectName}.stl\nVertices: ${vertexCount}\nTriangles: ${triangleCount}\n\nFile saved to your Downloads folder.`);
        }

        /**
         * Imports an STL file and adds it to the scene
         */
        function importSTL() {
            const fileInput = document.getElementById('import-stl-input');
            fileInput.click();
        }

        // Handle STL file selection
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('import-stl-input');
            if (fileInput) {
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const loader = new STLLoader();
                            let geometry;

                            // Check if ASCII or Binary STL
                            const view = new Uint8Array(e.target.result);
                            const header = String.fromCharCode.apply(null, view.slice(0, 5));

                            if (header === 'solid') {
                                // ASCII STL
                                const textDecoder = new TextDecoder();
                                const text = textDecoder.decode(e.target.result);
                                geometry = loader.parse(text);
                            } else {
                                // Binary STL
                                geometry = loader.parse(e.target.result);
                            }

                            // Center the geometry
                            geometry.computeBoundingBox();
                            const box = geometry.boundingBox;
                            const center = box.getCenter(new THREE.Vector3());
                            geometry.translate(-center.x, -center.y, -center.z);

                            // Compute normals
                            geometry.computeVertexNormals();
                            geometry.computeBoundingSphere();

                            // Create material
                            const material = new THREE.MeshPhongMaterial({
                                color: 0x7c3aed,
                                transparent: true,
                                opacity: 0.8,
                                side: THREE.DoubleSide
                            });

                            // Create mesh
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(0, 0, 0);

                            // Add wireframe
                            const edges = new THREE.EdgesGeometry(geometry);
                            const line = new THREE.LineSegments(
                                edges,
                                new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 })
                            );
                            mesh.add(line);

                            // Add edge visualization
                            const edgeVisualization = new THREE.LineSegments(
                                edges,
                                new THREE.LineBasicMaterial({
                                    color: 0x888888,
                                    linewidth: 1,
                                    transparent: true,
                                    opacity: 0.3
                                })
                            );
                            mesh.add(edgeVisualization);

                            // Store references
                            mesh.userData.wireframe = line;
                            mesh.userData.edgeVisualization = edgeVisualization;
                            mesh.userData.type = 'object';
                            mesh.name = file.name.replace('.stl', '');

                            // Add to scene
                            scene.add(mesh);
                            objects.push(mesh);

                            const vertexCount = geometry.attributes.position.count;
                            const triangleCount = vertexCount / 3;

                            console.log('\n' + '='.repeat(80));
                            console.log('IMPORTED STL FILE');
                            console.log('='.repeat(80));
                            console.log('Filename:', file.name);
                            console.log('Vertices:', vertexCount);
                            console.log('Triangles:', triangleCount);
                            console.log('='.repeat(80) + '\n');

                            alert(`âœ“ STL imported!\n\nFilename: ${file.name}\nVertices: ${vertexCount}\nTriangles: ${triangleCount}\n\nObject added to scene.`);

                            // Clear the file input so the same file can be imported again
                            fileInput.value = '';
                        } catch (error) {
                            console.error('Error loading STL:', error);
                            alert('Failed to load STL file: ' + error.message);
                            fileInput.value = '';
                        }
                    };

                    reader.readAsArrayBuffer(file);
                });
            }
        });

        // Global variable to store point visualization objects
        let pointVisualizationGroup = null;
        let vertexLabels = [];

        /**
         * Shows all vertices on the selected object as numbered spheres with labels
         */
        function showAllPoints() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            // Clear previous visualization
            if (pointVisualizationGroup) {
                scene.remove(pointVisualizationGroup);
                pointVisualizationGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }

            // Clear previous labels
            vertexLabels.forEach(label => {
                if (label.element && label.element.parentNode) {
                    label.element.parentNode.removeChild(label.element);
                }
            });
            vertexLabels = [];

            pointVisualizationGroup = new THREE.Group();
            pointVisualizationGroup.name = 'PointVisualization';

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            const vertexCount = positionAttr.count;

            console.log('\n' + '='.repeat(80));
            console.log('SHOWING ALL POINTS');
            console.log('='.repeat(80));
            console.log('Object:', selectedObject.name || selectedObject.uuid);
            console.log('Total vertices:', vertexCount);

            // Create a sphere for each vertex
            const sphereGeom = new THREE.SphereGeometry(0.05, 8, 8);

            for (let i = 0; i < vertexCount; i++) {
                const x = positionAttr.getX(i);
                const y = positionAttr.getY(i);
                const z = positionAttr.getZ(i);

                // Create a unique color based on vertex index
                const hue = (i / vertexCount) * 360;
                const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);

                const sphereMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });

                const sphere = new THREE.Mesh(sphereGeom, sphereMat);

                // Transform to world space
                const worldPos = new THREE.Vector3(x, y, z);
                worldPos.applyMatrix4(selectedObject.matrixWorld);
                sphere.position.copy(worldPos);

                sphere.userData.vertexIndex = i;
                sphere.userData.localPos = new THREE.Vector3(x, y, z);

                pointVisualizationGroup.add(sphere);

                // Create HTML label
                const labelDiv = document.createElement('div');
                labelDiv.className = 'vertex-label';
                labelDiv.textContent = `${i}`;
                labelDiv.style.display = 'none'; // Will be positioned in animate loop
                document.body.appendChild(labelDiv);

                vertexLabels.push({
                    element: labelDiv,
                    position: worldPos.clone(),
                    index: i
                });

                console.log(`  [${i}] (${x.toFixed(3)}, ${y.toFixed(3)}, ${z.toFixed(3)}) -> World (${worldPos.x.toFixed(3)}, ${worldPos.y.toFixed(3)}, ${worldPos.z.toFixed(3)})`);
            }

            scene.add(pointVisualizationGroup);

            // Find unique positions
            const uniquePositions = [];
            const duplicateGroups = [];
            const posThreshold = 0.001;

            for (let i = 0; i < vertexCount; i++) {
                const x = positionAttr.getX(i);
                const y = positionAttr.getY(i);
                const z = positionAttr.getZ(i);
                const pos = new THREE.Vector3(x, y, z);

                let foundGroup = false;
                for (const group of duplicateGroups) {
                    if (group.position.distanceTo(pos) < posThreshold) {
                        group.indices.push(i);
                        foundGroup = true;
                        break;
                    }
                }

                if (!foundGroup) {
                    duplicateGroups.push({
                        position: pos,
                        indices: [i]
                    });
                    uniquePositions.push(pos);
                }
            }

            console.log('\nÃ¢Å“â€œ All points visualized (colored spheres)');
            console.log(`Total vertices: ${vertexCount}`);
            console.log(`Unique positions: ${uniquePositions.length}`);
            console.log(`Average vertices per position: ${(vertexCount / uniquePositions.length).toFixed(1)}`);
            console.log('\nDuplicate vertex groups:');
            duplicateGroups.forEach((group, idx) => {
                if (group.indices.length > 1) {
                    console.log(`  Position ${idx} (${group.position.x.toFixed(3)}, ${group.position.y.toFixed(3)}, ${group.position.z.toFixed(3)}): ${group.indices.length} vertices [${group.indices.join(', ')}]`);
                }
            });
            console.log('='.repeat(80) + '\n');

            alert(`Visualized ${vertexCount} vertices as colored spheres with labels.\n\nUnique positions: ${uniquePositions.length}\nDuplicate vertices: ${vertexCount - uniquePositions.length}\n\nCheck console for detailed breakdown.`);
        }

        /**
         * Hides all point visualizations
         */
        function hideAllPoints() {
            // Remove 3D visualization
            if (pointVisualizationGroup) {
                scene.remove(pointVisualizationGroup);
                pointVisualizationGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                pointVisualizationGroup = null;
            }

            // Remove HTML labels
            vertexLabels.forEach(label => {
                if (label.element && label.element.parentNode) {
                    label.element.parentNode.removeChild(label.element);
                }
            });
            vertexLabels = [];

            console.log('All point visualizations hidden');
        }

        /**
         * ============================================================================
         * FACE EXTRUSION SYSTEM
         * ============================================================================
         * 
         * This system allows inward extrusion of faces with the following capabilities:
         * 
         * 1. INWARD EXTRUSION: Push a face into the object
         *    - If it goes all the way through Ã¢â€ â€™ automatic punch-through (creates hole)
         *    - If it stops partway Ã¢â€ â€™ creates cavity
         * 
         * 2. TAPER: Scale the face as it extrudes
         *    - Scale < 1.0 = narrowing (cone shape)
         *    - Scale > 1.0 = widening (flared shape)
         *    - Scale at distance = 0 = inset (creates inner face without moving)
         * 
         * 3. ROTATION: Twist the face as it extrudes
         *    - Creates spiral/twisted geometry
         * 
         * PORTING NOTES:
         * - All geometry manipulation uses BufferGeometry.attributes.position
         * - No CSG operations - pure vertex manipulation
         * - Compatible with your existing "punch-through extrude" system
         * - Can be integrated into any THREE.js editor
         * 
         * KEY FUNCTIONS:
         * - startFaceExtrusion(): Initiates extrusion mode
         * - performFaceExtrusion(): Executes the extrusion (creates new geometry)
         * - updateExtrusionPreview(): Real-time preview during dragging
         * - detectPunchThrough(): Raycasts to find opposite face
         */
        
        /**
         * Starts face extrusion mode
         * 
         * REQUIREMENTS:
         * - A face must be selected (selectedFace must exist)
         * - Selection mode must be 'face'
         * 
         * WHAT IT DOES:
         * 1. Validates face selection
         * 2. Stores original face data (vertices, normal, indices)
         * 3. Creates preview geometry
         * 4. Switches to extrusion interaction mode
         * 
         * PORTING: This is the entry point - wire this to a button/hotkey
         */
        function startFaceExtrusion() {
            console.log('=== Starting Face Extrusion ===');
            
            // VALIDATION: Ensure we have a face selected
            if (selectionMode !== 'face' || !selectedFace || !selectedObject) {
                console.error('Cannot extrude: No face selected or not in face mode');
                alert('Please select a face first (switch to Face mode and click a face)');
                return;
            }
            
            
            console.log('Face selected with', selectedFace.vertexIndices.length, 'vertex indices');
            
            // STEP 1: Store original face data
            // This preserves the state before extrusion so we can create connecting geometry
            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            
            // Get unique vertex positions (remove duplicates from the vertex indices)
            const uniquePositions = [];
            const uniqueIndices = [];
            const seenPositions = new Map();
            
            selectedFace.vertexIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;
                
                if (!seenPositions.has(key)) {
                    seenPositions.set(key, uniquePositions.length);
                    uniquePositions.push(v.clone());
                    uniqueIndices.push(idx);
                }
            });
            
            console.log('Found', uniquePositions.length, 'unique vertices in face');

            // STEP 1.5: Sort vertices into perimeter order
            // This is critical! Vertices must be ordered around the face edge, not randomly
            console.log('Sorting vertices into perimeter order...');
            console.log('Before sort (with indices):', uniquePositions.map((v, i) => `[${uniqueIndices[i]}]: (${v.x.toFixed(2)}, ${v.y.toFixed(2)}, ${v.z.toFixed(2)})`));

            // Calculate face center first (needed for sorting)
            const tempCenter = new THREE.Vector3();
            uniquePositions.forEach(v => tempCenter.add(v));
            tempCenter.divideScalar(uniquePositions.length);

            // Calculate face normal
            const tempNormal = selectedFace.normal.clone();

            // Sort vertices by angle around the face center
            // This orders them in a consistent clockwise/counter-clockwise loop
            const sortedData = uniquePositions.map((pos, idx) => {
                // Vector from center to vertex
                const toVertex = new THREE.Vector3().subVectors(pos, tempCenter);

                // Choose an arbitrary reference vector in the face plane
                const refVector = new THREE.Vector3(1, 0, 0);
                if (Math.abs(tempNormal.x) > 0.9) {
                    refVector.set(0, 1, 0); // If normal is along X, use Y as reference
                }

                // Project reference vector onto face plane
                const refInPlane = refVector.clone().sub(
                    tempNormal.clone().multiplyScalar(refVector.dot(tempNormal))
                ).normalize();

                // Calculate angle from reference vector
                const angle = Math.atan2(
                    toVertex.clone().cross(refInPlane).dot(tempNormal),
                    toVertex.dot(refInPlane)
                );

                return { pos, idx: uniqueIndices[idx], angle };
            });

            // Sort by angle
            sortedData.sort((a, b) => a.angle - b.angle);

            // Extract sorted positions and indices
            const sortedPositions = sortedData.map(d => d.pos);
            const sortedIndices = sortedData.map(d => d.idx);

            console.log('After sort (with indices):', sortedData.map(d => `[${d.idx}]: (${d.pos.x.toFixed(2)}, ${d.pos.y.toFixed(2)}, ${d.pos.z.toFixed(2)}) @ ${d.angle.toFixed(2)}rad`));
            console.log('\nÃ¢Å¡Â  EXPECTED ORDER (for top face): Should form a loop like [16,17,20,21] or [21,20,17,16]');
            console.log('Ã¢Å¡Â  Side faces will connect: bottom[i]Ã¢â€ â€™bottom[i+1] and top[i]Ã¢â€ â€™top[i+1]');

            // Replace with sorted versions
            uniquePositions.length = 0;
            uniquePositions.push(...sortedPositions);
            uniqueIndices.length = 0;
            uniqueIndices.push(...sortedIndices);

            // STEP 2: Calculate face properties
            const faceCenter = tempCenter; // Already calculated
            let faceNormal = tempNormal; // Already calculated

            console.log('Face center (local):', faceCenter);
            console.log('Face normal (before correction):', faceNormal);

            // CRITICAL FIX: Ensure normal points OUTWARD from geometry center
            // This fixes the reversed extrusion bug when extruding from previously extruded faces
            geometry.computeBoundingBox();
            const geometryCenter = new THREE.Vector3();
            geometry.boundingBox.getCenter(geometryCenter);

            // Vector from geometry center to face center
            const centerToFace = new THREE.Vector3().subVectors(faceCenter, geometryCenter);

            // Check if normal points in same general direction as centerToFace
            // If dot product is negative, normal points inward - flip it!
            const dotProduct = faceNormal.dot(centerToFace);
            console.log('Geometry center:', geometryCenter);
            console.log('Center to face vector:', centerToFace);
            console.log('Dot product (normal Ã‚Â· centerToFace):', dotProduct.toFixed(4));

            if (dotProduct < 0) {
                console.log('Ã¢Å¡Â  Normal points INWARD - flipping to point OUTWARD');
                faceNormal.negate();
            } else {
                console.log('Ã¢Å“â€œ Normal points OUTWARD');
            }

            console.log('Face normal (after correction):', faceNormal);
            
            // STEP 3: Store extrusion data
            // This object contains everything needed for the extrusion operation
            extrusionData = {
                object: selectedObject,
                geometry: geometry,
                originalVertexIndices: uniqueIndices, // Original face vertex indices
                originalPositions: uniquePositions,    // Original vertex positions (local space)
                faceCenter: faceCenter,                // Center point of face
                faceNormal: faceNormal,                // Normal direction (for extrusion)
                extrudeDistance: 0,                    // How far to extrude (negative = inward)
                taperScale: 1.0,                       // Scale factor for taper (1.0 = no taper)
                rotationAngle: 0,                      // Rotation in radians
                newVertexIndices: [],                  // Will store newly created vertices
                isPunchThrough: false                  // Whether extrusion goes all the way through
            };
            
            // STEP 4: Enter extrusion mode
            isExtruding = true;

            console.log('Extrusion mode active. Ready to extrude!');
            console.log('Extrusion data:', extrusionData);
            console.log('=== Face Extrusion Started ===');

            // Show extrusion panel
            const extrusionPanel = document.getElementById('extrusion-panel');
            if (extrusionPanel) {
                extrusionPanel.style.display = 'block';
                extrusionPanel.style.right = 'auto';
                extrusionPanel.style.bottom = 'auto';

                const controlsPanel = document.getElementById('controls');
                if (controlsPanel) {
                    const controlsRect = controlsPanel.getBoundingClientRect();
                    let desiredLeft = controlsRect.right + 20;
                    let desiredTop = controlsRect.top;

                    extrusionPanel.style.left = `${desiredLeft}px`;
                    extrusionPanel.style.top = `${desiredTop}px`;

                    let panelRect = extrusionPanel.getBoundingClientRect();
                    if (panelRect.right > window.innerWidth - 20) {
                        desiredLeft = Math.max(20, window.innerWidth - panelRect.width - 20);
                        extrusionPanel.style.left = `${desiredLeft}px`;
                        panelRect = extrusionPanel.getBoundingClientRect();
                    }
                    if (panelRect.bottom > window.innerHeight - 20) {
                        desiredTop = Math.max(20, window.innerHeight - panelRect.height - 20);
                        extrusionPanel.style.top = `${desiredTop}px`;
                    }
                } else {
                    extrusionPanel.style.left = '280px';
                    extrusionPanel.style.top = '20px';
                }
            }

            // Reset sliders to defaults
            document.getElementById('depth-slider').value = 0.5;
            document.getElementById('scale-slider').value = 1.0;
            document.getElementById('rotation-slider').value = 0;
            updateSliderValues();

            // Create preview (initially hidden)
            createExtrusionPreview();
        }

        /**
         * ============================================================================
         * PREVIEW MODE FUNCTIONS
         * ============================================================================
         */

        function updatePreviewSliderValues() {
            // Edge settings
            const edgeWidthSlider = document.getElementById('edge-width-slider');
            const edgeGlowSlider = document.getElementById('edge-glow-slider');
            const edgeThresholdSlider = document.getElementById('edge-threshold-slider');
            const faceAlphaSlider = document.getElementById('face-alpha-slider');
            const animSpeedSlider = document.getElementById('anim-speed-slider');

            if (edgeWidthSlider) {
                const edgeWidth = parseFloat(edgeWidthSlider.value);
                const edgeWidthValue = document.getElementById('edge-width-value');
                if (edgeWidthValue) edgeWidthValue.textContent = edgeWidth.toFixed(1);
            }

            if (edgeGlowSlider) {
                const edgeGlow = parseFloat(edgeGlowSlider.value);
                const edgeGlowValue = document.getElementById('edge-glow-value');
                if (edgeGlowValue) edgeGlowValue.textContent = edgeGlow.toFixed(2);
            }

            if (edgeThresholdSlider) {
                const edgeThreshold = parseInt(edgeThresholdSlider.value);
                const edgeThresholdValue = document.getElementById('edge-threshold-value');
                if (edgeThresholdValue) edgeThresholdValue.textContent = edgeThreshold;
            }

            if (faceAlphaSlider) {
                const faceAlpha = parseFloat(faceAlphaSlider.value);
                const faceAlphaValue = document.getElementById('face-alpha-value');
                if (faceAlphaValue) faceAlphaValue.textContent = faceAlpha.toFixed(2);
            }

            if (animSpeedSlider) {
                const animSpeed = parseFloat(animSpeedSlider.value);
                const animSpeedValue = document.getElementById('anim-speed-value');
                if (animSpeedValue) animSpeedValue.textContent = animSpeed.toFixed(1);
            }

            // Face material settings
            const faceRoughnessSlider = document.getElementById('face-roughness-slider');
            const faceMetalnessSlider = document.getElementById('face-metalness-slider');

            if (faceRoughnessSlider) {
                const faceRoughness = parseFloat(faceRoughnessSlider.value);
                const faceRoughnessValue = document.getElementById('face-roughness-value');
                if (faceRoughnessValue) faceRoughnessValue.textContent = faceRoughness.toFixed(2);
            }

            if (faceMetalnessSlider) {
                const faceMetalness = parseFloat(faceMetalnessSlider.value);
                const faceMetalnessValue = document.getElementById('face-metalness-value');
                if (faceMetalnessValue) faceMetalnessValue.textContent = faceMetalness.toFixed(2);
            }

            // Basic material settings
            const roughnessSlider = document.getElementById('roughness-slider');
            const metalnessSlider = document.getElementById('metalness-slider');

            if (roughnessSlider) {
                const roughness = parseFloat(roughnessSlider.value);
                const roughnessValue = document.getElementById('roughness-value');
                if (roughnessValue) roughnessValue.textContent = roughness.toFixed(2);
            }

            if (metalnessSlider) {
                const metalness = parseFloat(metalnessSlider.value);
                const metalnessValue = document.getElementById('metalness-value');
                if (metalnessValue) metalnessValue.textContent = metalness.toFixed(2);
            }
        }

        function optimizeGeometry(geometry) {
            console.log('Ã°Å¸â€Â§ Optimizing geometry - merging coplanar triangles...');

            // Extract triangle data
            const posArray = geometry.attributes.position.array;
            const triangles = [];

            for (let i = 0; i < posArray.length; i += 9) {
                const v0 = new THREE.Vector3(posArray[i], posArray[i+1], posArray[i+2]);
                const v1 = new THREE.Vector3(posArray[i+3], posArray[i+4], posArray[i+5]);
                const v2 = new THREE.Vector3(posArray[i+6], posArray[i+7], posArray[i+8]);

                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                const center = new THREE.Vector3().add(v0).add(v1).add(v2).divideScalar(3);

                triangles.push({
                    id: i / 9,
                    vertices: [v0, v1, v2],
                    normal: normal,
                    center: center,
                    used: false
                });
            }

            console.log(`  Starting with ${triangles.length} triangles`);
            console.log(`  Threshold: 0.9999 (~0.8 degrees)`);

            const threshold = 0.9999; // Very high threshold for coplanar detection (~0.8 degrees)
            let totalMerges = 0;

            // Simple single-pass merge (multi-pass needs restructuring)
            const newPositions = [];
            let mergedPairs = 0;

            // Try to merge each triangle with coplanar neighbors
            for (let i = 0; i < triangles.length; i++) {
                if (triangles[i].used) continue;

                const tri1 = triangles[i];
                let merged = false;

                // Look for a coplanar triangle that shares an edge
                for (let j = i + 1; j < triangles.length; j++) {
                    if (triangles[j].used) continue;

                    const tri2 = triangles[j];

                    // Check if coplanar (normals pointing same direction)
                    const dotProduct = tri1.normal.dot(tri2.normal);
                    if (dotProduct < threshold) {
                        if (j === i + 1 && dotProduct > 0.99) {
                            console.log(`    Triangle ${tri1.id} and ${tri2.id} almost coplanar: dot=${dotProduct.toFixed(4)}`);
                        }
                        continue;
                    }

                    // Check if on same plane (distance between centers along normal)
                    const centerToCenterVec = new THREE.Vector3().subVectors(tri2.center, tri1.center);
                    const distToPlane = Math.abs(centerToCenterVec.dot(tri1.normal));
                    if (distToPlane > 0.01) {
                        if (j === i + 1 && distToPlane < 0.1) {
                            console.log(`    Triangle ${tri1.id} and ${tri2.id} close planes: dist=${distToPlane.toFixed(4)}`);
                        }
                        continue;
                    }

                    // Check if they share an edge (2 common vertices)
                    const sharedVerts = [];
                    for (const v1 of tri1.vertices) {
                        for (const v2 of tri2.vertices) {
                            if (v1.distanceTo(v2) < 0.001) {
                                sharedVerts.push(v1);
                                break;
                            }
                        }
                    }

                    if (sharedVerts.length >= 1 && j === i + 1) {
                        console.log(`    Triangle ${tri1.id} and ${tri2.id} share ${sharedVerts.length} vertices`);
                    }

                    if (sharedVerts.length === 2) {
                        // They share an edge - merge into a quad
                        console.log(`    Ã¢Å“â€œ Merging triangle ${tri1.id} and ${tri2.id} into quad`);

                        // Collect all 4 unique vertices
                        const allVerts = [...tri1.vertices, ...tri2.vertices];
                        const uniqueVerts = [];
                        for (const v of allVerts) {
                            if (!uniqueVerts.some(uv => uv.distanceTo(v) < 0.001)) {
                                uniqueVerts.push(v);
                            }
                        }

                        if (uniqueVerts.length === 4) {
                            // Sort vertices in order around the center
                            const center = new THREE.Vector3();
                            uniqueVerts.forEach(v => center.add(v));
                            center.divideScalar(4);

                            const refVector = new THREE.Vector3(1, 0, 0);
                            if (Math.abs(tri1.normal.x) > 0.9) {
                                refVector.set(0, 1, 0);
                            }
                            const refInPlane = refVector.clone().sub(
                                tri1.normal.clone().multiplyScalar(refVector.dot(tri1.normal))
                            ).normalize();

                            const sortedVerts = uniqueVerts.map(v => {
                                const toVertex = new THREE.Vector3().subVectors(v, center);
                                const angle = Math.atan2(
                                    toVertex.clone().cross(refInPlane).dot(tri1.normal),
                                    toVertex.dot(refInPlane)
                                );
                                return { vertex: v, angle };
                            }).sort((a, b) => a.angle - b.angle).map(d => d.vertex);

                            // Create 2 triangles with consistent winding
                            const v0 = sortedVerts[0];
                            const v1 = sortedVerts[1];
                            const v2 = sortedVerts[2];
                            const v3 = sortedVerts[3];

                            // Triangle 1: v0, v1, v2
                            newPositions.push(v0.x, v0.y, v0.z);
                            newPositions.push(v1.x, v1.y, v1.z);
                            newPositions.push(v2.x, v2.y, v2.z);

                            // Triangle 2: v0, v2, v3
                            newPositions.push(v0.x, v0.y, v0.z);
                            newPositions.push(v2.x, v2.y, v2.z);
                            newPositions.push(v3.x, v3.y, v3.z);

                            tri1.used = true;
                            tri2.used = true;
                            merged = true;
                            mergedPairs++;
                            break;
                        } else {
                            console.log(`    Ã¢Å“â€” Merge failed: found ${uniqueVerts.length} unique vertices (expected 4)`);
                        }
                    }
                }

                // If we couldn't merge, add the original triangle
                if (!merged && !tri1.used) {
                    tri1.vertices.forEach(v => {
                        newPositions.push(v.x, v.y, v.z);
                    });
                    tri1.used = true;
                }
            }

            const finalTriCount = newPositions.length / 9;
            console.log(`  Ã¢Å“â€œ Optimized to ${finalTriCount} triangles (merged ${mergedPairs} pairs)`);

            // Create new geometry
            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            newGeometry.computeVertexNormals();

            return newGeometry;
        }

        function updatePreviewVisibility() {
            const renderMode = document.querySelector('input[name="render-mode"]:checked').value;

            const edgeSettings = document.getElementById('edge-settings');
            const faceSettings = document.getElementById('face-settings');
            const materialSettings = document.getElementById('material-settings');

            // Show/hide relevant settings based on render mode
            if (renderMode === 'wireframe') {
                edgeSettings.style.display = 'block';
                faceSettings.style.display = 'block';
                materialSettings.style.display = 'none';
            } else if (renderMode === 'silhouette') {
                edgeSettings.style.display = 'block';
                faceSettings.style.display = 'none';
                materialSettings.style.display = 'none';
            } else if (renderMode === 'basic') {
                edgeSettings.style.display = 'none';
                faceSettings.style.display = 'none';
                materialSettings.style.display = 'block';
            }

            applyPreviewSettings();
        }

        function restoreEditMaterial() {
            if (!selectedObject) return;

            console.log('Restoring original edit material');

            // Remove preview materials/wireframes
            if (selectedObject.userData.previewMaterials) {
                selectedObject.userData.previewMaterials.forEach(mat => {
                    if (mat.dispose) mat.dispose();
                });
                selectedObject.userData.previewMaterials = null;
            }

            // Store reference to original wireframe before clearing children
            const originalWireframe = selectedObject.userData.wireframe;
            const originalEdgeVisualization = selectedObject.userData.edgeVisualization;

            // Clear preview children (wireframes, etc) but keep original edit mode wireframes
            const childrenToRemove = [];
            for (let i = 0; i < selectedObject.children.length; i++) {
                const child = selectedObject.children[i];
                // Don't remove the original edit mode wireframe
                if (child !== originalWireframe && child !== originalEdgeVisualization) {
                    childrenToRemove.push(child);
                }
            }
            childrenToRemove.forEach(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                selectedObject.remove(child);
            });

            // Restore original material
            if (selectedObject.userData.originalMaterial) {
                selectedObject.material = selectedObject.userData.originalMaterial;
                selectedObject.material.visible = true;
            }

            // Make sure original wireframe is visible in edit mode
            if (originalWireframe) {
                originalWireframe.visible = true;
            }
            if (originalEdgeVisualization) {
                originalEdgeVisualization.visible = true;
            }

            console.log('Ã¢Å“â€œ Edit material restored (including white wireframe)');
        }

        function applyPreviewSettings() {
            if (!selectedObject) {
                console.warn('No object selected for preview');
                return;
            }

            // Store original material if not already stored
            if (!selectedObject.userData.originalMaterial) {
                selectedObject.userData.originalMaterial = selectedObject.material;
            }

            const renderMode = document.querySelector('input[name="render-mode"]:checked').value;
            const edgeColor = document.getElementById('edge-color-picker').value;
            const faceColor = document.getElementById('face-color-picker').value;
            const edgeColorHex = parseInt(edgeColor.substring(1), 16);
            const faceColorHex = parseInt(faceColor.substring(1), 16);

            console.log(`Applying ${renderMode} rendering to selected object`);

            // Clear old animation userData
            selectedObject.userData.animateEdges = false;
            selectedObject.userData.animSpeed = 1.0;
            selectedObject.userData.wireframe = null;

            // Remove existing materials/wireframes
            if (selectedObject.userData.previewMaterials) {
                selectedObject.userData.previewMaterials.forEach(mat => {
                    if (mat.dispose) mat.dispose();
                });
            }

            // Clear children (remove old wireframes)
            while (selectedObject.children.length > 0) {
                const child = selectedObject.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
                selectedObject.remove(child);
            }

            const geometry = selectedObject.geometry;

            if (renderMode === 'wireframe') {
                // Wireframe mode: Line2 thick wireframe with optional face fill (vicVECTOR style)
                const faceVisible = document.getElementById('face-visible-checkbox').checked;
                const faceAlpha = parseFloat(document.getElementById('face-alpha-slider').value);
                const edgeWidth = parseFloat(document.getElementById('edge-width-slider').value);
                const edgeGlow = parseFloat(document.getElementById('edge-glow-slider').value);
                const edgeThreshold = parseInt(document.getElementById('edge-threshold-slider').value);
                const faceRoughness = parseFloat(document.getElementById('face-roughness-slider').value);
                const faceMetalness = parseFloat(document.getElementById('face-metalness-slider').value);

                // Add black core for hidden line removal
                const coreMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    roughness: faceRoughness,
                    metalness: faceMetalness
                });
                const coreMesh = new THREE.Mesh(geometry, coreMaterial);
                selectedObject.add(coreMesh);

                selectedObject.userData.previewMaterials = [coreMaterial];

                if (faceVisible) {
                    // Add semi-transparent fill on top
                    const fillMaterial = new THREE.MeshBasicMaterial({
                        color: faceColorHex,
                        transparent: faceAlpha < 1.0,
                        opacity: faceAlpha,
                        side: THREE.DoubleSide,
                        depthTest: true
                    });
                    const fillMesh = new THREE.Mesh(geometry, fillMaterial);
                    selectedObject.add(fillMesh);
                    selectedObject.userData.previewMaterials.push(fillMaterial);
                }

                // Add thick wireframe using Line2 (vicVECTOR style) with glow
                // Calculate brightened color for glow effect (LineMaterial doesn't support emissive)
                let glowColor = new THREE.Color(edgeColorHex);
                if (edgeGlow > 0) {
                    // Brighten the color based on glow value
                    glowColor.multiplyScalar(1 + edgeGlow * 2);
                }

                const wireframeMaterial = new LineMaterial({
                    color: glowColor.getHex(),
                    linewidth: edgeWidth,
                    alphaToCoverage: true,
                    transparent: true,
                    opacity: 1.0,
                    resolution: new THREE.Vector2(window.innerWidth, window.innerHeight)
                });

                // Optimize geometry first - merge coplanar triangles to clean up topology
                // This eliminates internal edges from multi-extrusion geometry
                const optimizedGeometry = optimizeGeometry(geometry.clone());

                // Use threshold angle to filter out edges between nearly coplanar faces
                // This removes internal edges in flat surfaces (e.g., quads made of 2 triangles)
                const edgesGeom = new THREE.EdgesGeometry(optimizedGeometry, edgeThreshold);

                // Apply selective edge visibility if hidden edges are defined
                const hiddenEdges = selectedObject.userData.hiddenEdges;
                let edgePositions;

                if (hiddenEdges && hiddenEdges.size > 0) {
                    // Filter edges based on hidden edge set
                    const edgeArray = edgesGeom.attributes.position.array;
                    const positionAttr = geometry.attributes.position;
                    const visiblePositions = [];
                    const precision = 1e-6;

                    for (let i = 0; i < edgeArray.length; i += 6) {
                        const v1Pos = new THREE.Vector3(edgeArray[i], edgeArray[i+1], edgeArray[i+2]);
                        const v2Pos = new THREE.Vector3(edgeArray[i+3], edgeArray[i+4], edgeArray[i+5]);

                        // Find vertex indices
                        let v1Idx = -1, v2Idx = -1;
                        for (let j = 0; j < positionAttr.count; j++) {
                            const px = positionAttr.getX(j);
                            const py = positionAttr.getY(j);
                            const pz = positionAttr.getZ(j);

                            if (v1Idx === -1 && Math.abs(px - v1Pos.x) < precision &&
                                Math.abs(py - v1Pos.y) < precision && Math.abs(pz - v1Pos.z) < precision) {
                                v1Idx = j;
                            }
                            if (v2Idx === -1 && Math.abs(px - v2Pos.x) < precision &&
                                Math.abs(py - v2Pos.y) < precision && Math.abs(pz - v2Pos.z) < precision) {
                                v2Idx = j;
                            }

                            if (v1Idx !== -1 && v2Idx !== -1) break;
                        }

                        // Check if this edge is hidden
                        const edgeKey = makeEdgeKey(v1Idx, v2Idx);
                        if (!hiddenEdges.has(edgeKey)) {
                            // Edge is visible - add it
                            visiblePositions.push(
                                edgeArray[i], edgeArray[i+1], edgeArray[i+2],
                                edgeArray[i+3], edgeArray[i+4], edgeArray[i+5]
                            );
                        }
                    }

                    edgePositions = new Float32Array(visiblePositions);
                } else {
                    // No hidden edges - use all edges
                    edgePositions = edgesGeom.attributes.position.array;
                }

                const lineGeom = new LineGeometry().setPositions(edgePositions);
                const wireframe = new Line2(lineGeom, wireframeMaterial);
                selectedObject.add(wireframe);

                // Clean up
                edgesGeom.dispose();
                optimizedGeometry.dispose();

                selectedObject.userData.previewMaterials.push(wireframeMaterial);

                // Store animation data
                const animateEdges = document.getElementById('animate-edges-checkbox').checked;
                const animSpeed = parseFloat(document.getElementById('anim-speed-slider').value);
                selectedObject.userData.animateEdges = animateEdges;
                selectedObject.userData.animSpeed = animSpeed;
                selectedObject.userData.wireframe = wireframe;
                selectedObject.userData.baseEdgeColor = edgeColorHex;
                selectedObject.userData.edgeGlow = edgeGlow;

                // Hide main object material
                selectedObject.material.visible = false;

            } else if (renderMode === 'silhouette') {
                // Silhouette mode: black core + backside outline (vicVECTOR style)
                const faceRoughness = parseFloat(document.getElementById('face-roughness-slider').value);
                const faceMetalness = parseFloat(document.getElementById('face-metalness-slider').value);
                const edgeGlow = parseFloat(document.getElementById('edge-glow-slider').value);

                const fillMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    roughness: faceRoughness,
                    metalness: faceMetalness
                });
                const fillMesh = new THREE.Mesh(geometry, fillMaterial);
                selectedObject.add(fillMesh);

                // Outline using backside technique with optional glow
                // Calculate brightened color for glow effect
                let outlineColor = new THREE.Color(edgeColorHex);
                if (edgeGlow > 0) {
                    // Brighten the color based on glow value
                    outlineColor.multiplyScalar(1 + edgeGlow * 2);
                }

                const outlineMaterial = new THREE.MeshBasicMaterial({
                    color: outlineColor.getHex(),
                    side: THREE.BackSide
                });

                const outlineMesh = new THREE.Mesh(geometry, outlineMaterial);
                outlineMesh.scale.multiplyScalar(1.03);
                selectedObject.add(outlineMesh);

                selectedObject.userData.previewMaterials = [fillMaterial, outlineMaterial];

                // Hide main object material
                selectedObject.material.visible = false;

            } else if (renderMode === 'basic') {
                // Basic mode: simple MeshStandardMaterial
                const materialColor = document.getElementById('material-color-picker').value;
                const materialColorHex = parseInt(materialColor.substring(1), 16);
                const roughness = parseFloat(document.getElementById('roughness-slider').value);
                const metalness = parseFloat(document.getElementById('metalness-slider').value);

                const material = new THREE.MeshStandardMaterial({
                    color: materialColorHex,
                    roughness: roughness,
                    metalness: metalness,
                    flatShading: true
                });
                selectedObject.material = material;
                selectedObject.userData.previewMaterials = [material];
            }

            console.log('Ã¢Å“â€œ Preview applied');
        }

        /**
         * ============================================================================
         * END PREVIEW MODE FUNCTIONS
         * ============================================================================
         */

        function updateSliderValues() {
            const depth = parseFloat(document.getElementById('depth-slider').value);
            const scale = parseFloat(document.getElementById('scale-slider').value);
            const rotation = parseInt(document.getElementById('rotation-slider').value);

            document.getElementById('depth-value').textContent = depth.toFixed(2);
            document.getElementById('scale-value').textContent = scale.toFixed(2);
            document.getElementById('rotation-value').textContent = rotation + 'Ã‚Â°';
        }

        function createExtrusionPreview() {
            if (!extrusionData) return;

            // Remove old preview
            if (extrusionPreviewMesh) {
                scene.remove(extrusionPreviewMesh);
                extrusionPreviewMesh.geometry.dispose();
                extrusionPreviewMesh.material.dispose();
                extrusionPreviewMesh = null;
            }
            if (extrusionPreviewLines) {
                scene.remove(extrusionPreviewLines);
                extrusionPreviewLines.geometry.dispose();
                extrusionPreviewLines.material.dispose();
                extrusionPreviewLines = null;
            }
            if (extrusionPreviewPoints) {
                scene.remove(extrusionPreviewPoints);
                extrusionPreviewPoints.geometry.dispose();
                extrusionPreviewPoints.material.dispose();
                extrusionPreviewPoints = null;
            }
            if (extrusionPreviewLines) {
                scene.remove(extrusionPreviewLines);
                extrusionPreviewLines.geometry.dispose();
                extrusionPreviewLines.material.dispose();
                extrusionPreviewLines = null;
            }
            if (extrusionPreviewPoints) {
                scene.remove(extrusionPreviewPoints);
                extrusionPreviewPoints.geometry.dispose();
                extrusionPreviewPoints.material.dispose();
                extrusionPreviewPoints = null;
            }

            const depth = parseFloat(document.getElementById('depth-slider').value);
            const scale = parseFloat(document.getElementById('scale-slider').value);
            const rotation = parseInt(document.getElementById('rotation-slider').value) * (Math.PI / 180);

            const { originalPositions, faceCenter, faceNormal, object } = extrusionData;

            // Calculate extruded vertices
            const extrudedVertices = [];
            originalPositions.forEach(origPos => {
                let extrudedPos = origPos.clone();

                // Move along normal by depth
                extrudedPos.add(faceNormal.clone().multiplyScalar(depth));

                // Apply taper (scale from face center)
                if (scale !== 1.0) {
                    const offsetFromCenter = extrudedPos.clone().sub(faceCenter);
                    offsetFromCenter.multiplyScalar(scale);
                    extrudedPos.copy(faceCenter).add(offsetFromCenter);
                }

                // Apply rotation around face normal
                if (rotation !== 0) {
                    const offsetFromCenter = extrudedPos.clone().sub(faceCenter);
                    offsetFromCenter.applyAxisAngle(faceNormal, rotation);
                    extrudedPos.copy(faceCenter).add(offsetFromCenter);
                }

                extrudedVertices.push(extrudedPos);
            });

            // Check for punch-through (if depth is negative/inward)
            let isPunchThrough = false;
            let punchThroughDistance = null;

            if (depth < 0) {
                // Raycast from face center along negative normal to find opposite face
                const raycaster = new THREE.Raycaster();
                const rayOrigin = faceCenter.clone();
                const rayDirection = faceNormal.clone().negate(); // Inward direction

                raycaster.set(rayOrigin, rayDirection);
                const intersects = raycaster.intersectObject(object, false);

                if (intersects.length > 0) {
                    const hitDistance = intersects[0].distance;
                    console.log(`Punch-through check: extrusion depth ${Math.abs(depth)}, distance to opposite face ${hitDistance.toFixed(3)}`);

                    if (Math.abs(depth) >= hitDistance) {
                        isPunchThrough = true;
                        punchThroughDistance = hitDistance;
                        console.log('Ã¢Å¡Â  PUNCH-THROUGH DETECTED!');
                    }
                }
            }

            // Build preview geometry
            const previewPositions = [];
            const numVerts = originalPositions.length;

            // Top face (extruded)
            for (let i = 1; i < numVerts - 1; i++) {
                previewPositions.push(
                    extrudedVertices[0].x, extrudedVertices[0].y, extrudedVertices[0].z,
                    extrudedVertices[i].x, extrudedVertices[i].y, extrudedVertices[i].z,
                    extrudedVertices[i + 1].x, extrudedVertices[i + 1].y, extrudedVertices[i + 1].z
                );
            }

            // Side faces
            for (let i = 0; i < numVerts; i++) {
                const next = (i + 1) % numVerts;
                const v1 = originalPositions[i];
                const v2 = originalPositions[next];
                const v3 = extrudedVertices[i];
                const v4 = extrudedVertices[next];

                // Triangle 1
                previewPositions.push(v1.x, v1.y, v1.z);
                previewPositions.push(v2.x, v2.y, v2.z);
                previewPositions.push(v3.x, v3.y, v3.z);

                // Triangle 2
                previewPositions.push(v2.x, v2.y, v2.z);
                previewPositions.push(v4.x, v4.y, v4.z);
                previewPositions.push(v3.x, v3.y, v3.z);
            }

            const previewGeometry = new THREE.BufferGeometry();
            previewGeometry.setAttribute('position', new THREE.Float32BufferAttribute(previewPositions, 3));
            previewGeometry.computeVertexNormals();

            // Material: green for normal, red for punch-through
            const previewMaterial = new THREE.MeshBasicMaterial({
                color: isPunchThrough ? 0xff4444 : 0x44ff44,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthTest: true
            });

            extrusionPreviewMesh = new THREE.Mesh(previewGeometry, previewMaterial);

            // Apply object's transform to preview
            extrusionPreviewMesh.position.copy(object.position);
            extrusionPreviewMesh.rotation.copy(object.rotation);
            extrusionPreviewMesh.scale.copy(object.scale);

            scene.add(extrusionPreviewMesh);

            // Build line preview (edges)
            const linePositions = [];
            for (let i = 0; i < numVerts; i++) {
                const next = (i + 1) % numVerts;
                const baseA = originalPositions[i];
                const baseB = originalPositions[next];
                const topA = extrudedVertices[i];
                const topB = extrudedVertices[next];

                // Base perimeter
                linePositions.push(baseA.x, baseA.y, baseA.z, baseB.x, baseB.y, baseB.z);
                // Top perimeter
                linePositions.push(topA.x, topA.y, topA.z, topB.x, topB.y, topB.z);
                // Vertical connector
                linePositions.push(baseA.x, baseA.y, baseA.z, topA.x, topA.y, topA.z);
            }

            const lineGeometry = new THREE.BufferGeometry();
            lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
            extrusionPreviewLines = new THREE.LineSegments(
                lineGeometry,
                new THREE.LineBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.9,
                    depthTest: false
                })
            );
            extrusionPreviewLines.position.copy(object.position);
            extrusionPreviewLines.rotation.copy(object.rotation);
            extrusionPreviewLines.scale.copy(object.scale);
            extrusionPreviewLines.renderOrder = 1001;
            scene.add(extrusionPreviewLines);

            // Build point preview (extruded vertices)
            const pointGeometry = new THREE.BufferGeometry();
            const pointPositions = [];
            extrudedVertices.forEach(v => {
                pointPositions.push(v.x, v.y, v.z);
            });
            pointGeometry.setAttribute('position', new THREE.Float32BufferAttribute(pointPositions, 3));
            extrusionPreviewPoints = new THREE.Points(
                pointGeometry,
                new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 8,
                    sizeAttenuation: false,
                    transparent: true,
                    opacity: 0.9,
                    depthTest: false
                })
            );
            extrusionPreviewPoints.position.copy(object.position);
            extrusionPreviewPoints.rotation.copy(object.rotation);
            extrusionPreviewPoints.scale.copy(object.scale);
            extrusionPreviewPoints.renderOrder = 1002;
            scene.add(extrusionPreviewPoints);

            // Store punch-through info for later use
            extrusionData.isPunchThrough = isPunchThrough;
            extrusionData.punchThroughDistance = punchThroughDistance;
        }

        function applyExtrusion() {
            if (!extrusionData) return;

            const depth = parseFloat(document.getElementById('depth-slider').value);
            const scale = parseFloat(document.getElementById('scale-slider').value);
            const rotation = parseInt(document.getElementById('rotation-slider').value) * (Math.PI / 180);

            // Remove preview mesh
            if (extrusionPreviewMesh) {
                scene.remove(extrusionPreviewMesh);
                extrusionPreviewMesh.geometry.dispose();
                extrusionPreviewMesh.material.dispose();
                extrusionPreviewMesh = null;
            }
            if (extrusionPreviewLines) {
                scene.remove(extrusionPreviewLines);
                extrusionPreviewLines.geometry.dispose();
                extrusionPreviewLines.material.dispose();
                extrusionPreviewLines = null;
            }
            if (extrusionPreviewPoints) {
                scene.remove(extrusionPreviewPoints);
                extrusionPreviewPoints.geometry.dispose();
                extrusionPreviewPoints.material.dispose();
                extrusionPreviewPoints = null;
            }

            // Hide panel
            document.getElementById('extrusion-panel').style.display = 'none';

            // Perform the extrusion
            performFaceExtrusion(depth, scale, rotation);
        }

        function cancelExtrusion() {
            // Remove preview mesh
            if (extrusionPreviewMesh) {
                scene.remove(extrusionPreviewMesh);
                extrusionPreviewMesh.geometry.dispose();
                extrusionPreviewMesh.material.dispose();
                extrusionPreviewMesh = null;
            }

            // Hide panel
            document.getElementById('extrusion-panel').style.display = 'none';

            // Reset state
            isExtruding = false;
            extrusionData = null;

            console.log('Extrusion cancelled');
        }

        // ====================================================================
        // BEVEL TOOL
        // ====================================================================

        function startBevel() {
            console.log('=== Starting Bevel ===');
            console.log('Selection mode:', selectionMode);
            console.log('Selected edge:', selectedEdge);

            // VALIDATION: Ensure we have an edge selected
            if (selectionMode === 'edge' && selectedEdge && selectedObject) {
                console.log('Starting EDGE bevel');
                startEdgeBevel();
            } else {
                console.error('Cannot bevel: No edge selected');
                alert('Please select an edge first (Edge mode)');
                return;
            }
        }

        function startEdgeBevel() {
            console.log('Edge bevel started');

            if (!selectedObject || !selectedEdge) {
                console.error('No edge data available for bevel');
                return;
            }

            const geometry = selectedObject.geometry;
            if (!geometry || !geometry.attributes?.position) {
                console.error('Geometry has no position attribute');
                return;
            }

            const positionAttr = geometry.attributes.position;
            const edge = selectedEdge;

            const edgeIndex1 = edge.index1 ?? (edge.indices?.start?.[0]);
            const edgeIndex2 = edge.index2 ?? (edge.indices?.end?.[0]);

            if (edgeIndex1 === undefined || edgeIndex2 === undefined) {
                console.error('Edge vertex indices could not be determined', edge);
                alert('Cannot bevel: failed to determine edge indices');
                return;
            }

            // Gather adjacent face data in object space
            const localStart = edge.localStart.clone();
            const localEnd = edge.localEnd.clone();
            const adjacentFaces = collectAdjacentFaces(
                geometry,
                positionAttr,
                edgeIndex1,
                edgeIndex2,
                localStart,
                localEnd
            );

            if (adjacentFaces.length !== 2) {
                console.error(`Expected 2 adjacent faces, found ${adjacentFaces.length}`);
                alert(`Cannot bevel: edge should have exactly 2 adjacent faces (found ${adjacentFaces.length})`);
                return;
            }

            console.log('Found adjacent faces:', adjacentFaces);

            const edgeDir = new THREE.Vector3().subVectors(localEnd, localStart).normalize();
            const edgeLength = localStart.distanceTo(localEnd);

            console.log('Edge direction (local):', edgeDir);
            console.log('Edge length:', edgeLength.toFixed(4));

            // For each face, determine inset direction and maximum inset distance
            const faceInfo = adjacentFaces.map(face => {
                const insetDir = new THREE.Vector3().crossVectors(edgeDir, face.normal).normalize();
                const toThird = new THREE.Vector3().subVectors(face.thirdVertex, localStart);

                if (insetDir.dot(toThird) < 0) {
                    insetDir.negate();
                }

                const distStart = insetDir.dot(new THREE.Vector3().subVectors(face.thirdVertex, localStart));
                const distEnd = insetDir.dot(new THREE.Vector3().subVectors(face.thirdVertex, localEnd));
                const maxInset = Math.max(0, Math.min(distStart, distEnd));

                return {
                    triangleIndex: face.triangleIndex,
                    indices: face.indices,
                    normal: face.normal.clone(),
                    thirdVertex: face.thirdVertex.clone(),
                    thirdVertexIndex: face.thirdVertexIndex,
                    insetDir,
                    maxInset
                };
            });

            const maxWidth = Math.min(faceInfo[0].maxInset, faceInfo[1].maxInset);

            if (maxWidth <= 1e-5) {
                console.error('Bevel width is effectively zero', { faceInfo });
                alert('Cannot bevel: there is no room to inset this edge.');
                return;
            }

            // Store bevel state
            bevelData = {
                type: 'edge',
                object: selectedObject,
                geometry: geometry,
                edge: edge,
                localStart: localStart.clone(),
                localEnd: localEnd.clone(),
                edgeDir,
                edgeLength,
                faceInfo,
                maxWidth
            };

            console.log('Bevel data prepared:', bevelData);

            // Configure UI sliders based on available inset distance
            const widthSlider = document.getElementById('bevel-width-slider');
            const currentWidth = parseFloat(widthSlider.value);
            widthSlider.min = 0;
            widthSlider.max = Math.max(maxWidth, 0.001).toFixed(3);

            if (currentWidth > maxWidth) {
                const newWidth = Math.max(maxWidth * 0.75, maxWidth - 0.01, 0.001);
                widthSlider.value = newWidth.toFixed(3);
            }

            updateBevelSliderValues();

            // Show bevel panel and generate preview
            document.getElementById('bevel-panel').style.display = 'block';
            createBevelPreview();

            function collectAdjacentFaces(geometry, positionAttr, idx1, idx2, localStartPos, localEndPos) {
                const faces = [];
                const isIndexed = !!geometry.index;
                const EPS = 1e-5;

                const matchesEdgeVertex = (index, position) => {
                    if (index === idx1 || index === idx2) return true;
                    if (!position) return false;
                    return (
                        position.distanceTo(localStartPos) < EPS ||
                        position.distanceTo(localEndPos) < EPS
                    );
                };

                const pushFace = (triangleIndex, i0, i1, i2) => {
                    const v0 = new THREE.Vector3().fromBufferAttribute(positionAttr, i0);
                    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, i1);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, i2);

                    const vertices = [v0, v1, v2];
                    const indices = [i0, i1, i2];

                    let thirdVertex = null;
                    let thirdVertexIndex = -1;
                    let edgeMatches = 0;

                    for (let j = 0; j < 3; j++) {
                        if (matchesEdgeVertex(indices[j], vertices[j])) {
                            edgeMatches++;
                        } else {
                            thirdVertex = vertices[j].clone();
                            thirdVertexIndex = indices[j];
                        }
                    }

                    if (edgeMatches === 2 && thirdVertex) {
                        const normal = new THREE.Vector3().crossVectors(
                            new THREE.Vector3().subVectors(v1, v0),
                            new THREE.Vector3().subVectors(v2, v0)
                        ).normalize();

                        faces.push({
                            triangleIndex,
                            indices,
                            normal,
                            thirdVertex,
                            thirdVertexIndex
                        });
                    }
                };

                if (isIndexed) {
                    const indices = geometry.index.array;
                    const triangleCount = indices.length / 3;
                    for (let i = 0; i < triangleCount; i++) {
                        pushFace(i, indices[i * 3], indices[i * 3 + 1], indices[i * 3 + 2]);
                        if (faces.length === 2) break;
                    }
                } else {
                    const triangleCount = positionAttr.count / 3;
                    for (let i = 0; i < triangleCount; i++) {
                        const base = i * 3;
                        pushFace(i, base, base + 1, base + 2);
                        if (faces.length === 2) break;
                    }
                }

                return faces;
            }
        }

        function startFaceBevel() {
            console.log('Face bevel started');

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;

            // Get unique vertex positions from the selected face
            const uniquePositions = [];
            const seenPositions = new Map();

            selectedFace.vertexIndices.forEach(idx => {
                const v = new THREE.Vector3().fromBufferAttribute(positionAttr, idx);
                const key = `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`;

                if (!seenPositions.has(key)) {
                    seenPositions.set(key, v);
                    uniquePositions.push(v);
                }
            });

            // Calculate face center
            const faceCenter = new THREE.Vector3();
            uniquePositions.forEach(v => faceCenter.add(v));
            faceCenter.divideScalar(uniquePositions.length);

            // Calculate face normal
            const v0 = uniquePositions[0];
            const v1 = uniquePositions[1];
            const v2 = uniquePositions[2];
            const faceNormal = new THREE.Vector3();
            faceNormal.crossVectors(
                new THREE.Vector3().subVectors(v1, v0),
                new THREE.Vector3().subVectors(v2, v0)
            ).normalize();

            // Sort vertices in counter-clockwise order around face center
            // This ensures proper perimeter order for beveling
            const sortedPositions = uniquePositions.slice();
            sortedPositions.sort((a, b) => {
                const vecA = new THREE.Vector3().subVectors(a, faceCenter);
                const vecB = new THREE.Vector3().subVectors(b, faceCenter);

                // Project onto face plane
                const refVector = new THREE.Vector3(1, 0, 0);
                if (Math.abs(faceNormal.x) > 0.9) {
                    refVector.set(0, 1, 0);
                }
                const refInPlane = refVector.clone().sub(
                    faceNormal.clone().multiplyScalar(refVector.dot(faceNormal))
                ).normalize();

                const angleA = Math.atan2(
                    vecA.clone().cross(refInPlane).dot(faceNormal),
                    vecA.dot(refInPlane)
                );
                const angleB = Math.atan2(
                    vecB.clone().cross(refInPlane).dot(faceNormal),
                    vecB.dot(refInPlane)
                );

                return angleA - angleB;
            });

            console.log('Sorted vertices for perimeter order:', sortedPositions.length);

            // Store bevel data (use sorted positions for correct perimeter order)
            bevelData = {
                type: 'face',
                object: selectedObject,
                geometry: geometry,
                originalPositions: sortedPositions,
                faceCenter: faceCenter,
                faceNormal: faceNormal,
                originalVertexIndices: selectedFace.vertexIndices
            };

            console.log('Bevel data:', bevelData);

            // Show bevel panel
            document.getElementById('bevel-panel').style.display = 'block';

            // Create initial preview
            createBevelPreview();
        }

        function updateBevelSliderValues() {
            const width = parseFloat(document.getElementById('bevel-width-slider').value);
            const segments = parseInt(document.getElementById('bevel-segments-slider').value);

            document.getElementById('bevel-width-value').textContent = width.toFixed(2);
            document.getElementById('bevel-segments-value').textContent = segments;
        }

        function createBevelPreview() {
            // Remove old preview
            if (bevelPreviewMesh) {
                scene.remove(bevelPreviewMesh);
                bevelPreviewMesh.geometry.dispose();
                bevelPreviewMesh.material.dispose();
                bevelPreviewMesh = null;
            }

            if (!bevelData) return;

            const widthSlider = document.getElementById('bevel-width-slider');
            const rawWidth = parseFloat(widthSlider.value);
            const segments = Math.max(1, parseInt(document.getElementById('bevel-segments-slider').value));

            let clampedWidth = rawWidth;
            if (bevelData.type === 'edge') {
                clampedWidth = Math.min(rawWidth, bevelData.maxWidth);
                if (clampedWidth < 0) clampedWidth = 0;

                if (Math.abs(clampedWidth - rawWidth) > 1e-4) {
                    widthSlider.value = clampedWidth.toFixed(3);
                    updateBevelSliderValues();
                }
            }

            console.log('Creating bevel preview:', { width: clampedWidth, segments });

            // Create edge bevel preview
            createEdgeBevelPreview(clampedWidth, segments);
        }

        function createEdgeBevelPreview(width, segments) {
            if (!bevelData || bevelData.type !== 'edge') return;
            if (width <= 1e-5) {
                console.log('Bevel preview skipped (width too small)');
                return;
            }

            const { object } = bevelData;
            const bevelMesh = buildEdgeBevelMesh(width, segments);
            if (!bevelMesh) return;

            const previewPositions = [];

            const pushTriangle = (triangle) => {
                previewPositions.push(
                    triangle[0].x, triangle[0].y, triangle[0].z,
                    triangle[1].x, triangle[1].y, triangle[1].z,
                    triangle[2].x, triangle[2].y, triangle[2].z
                );
            };

            bevelMesh.triangles.forEach(pushTriangle);

            if (previewPositions.length === 0) {
                console.warn('No preview geometry generated for bevel');
                return;
            }

            const previewGeometry = new THREE.BufferGeometry();
            previewGeometry.setAttribute('position', new THREE.Float32BufferAttribute(previewPositions, 3));
            previewGeometry.computeVertexNormals();

            const previewMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6b00,
                transparent: true,
                opacity: 0.55,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            bevelPreviewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
            object.updateMatrixWorld(true);
            bevelPreviewMesh.matrixAutoUpdate = false;
            bevelPreviewMesh.matrix.copy(object.matrixWorld);
            bevelPreviewMesh.updateMatrixWorld(true);
            bevelPreviewMesh.matrixWorldNeedsUpdate = true;
            scene.add(bevelPreviewMesh);

            console.log('Created edge bevel preview with', previewPositions.length / 9, 'triangles');
        }

        function buildEdgeBevelMesh(width, segments) {
            if (!bevelData || bevelData.type !== 'edge') return null;

            segments = Math.max(1, segments);

            const { localStart, localEnd, faceInfo, edgeDir } = bevelData;

            const face0 = faceInfo[0];
            const face1 = faceInfo[1];

            const offset0 = face0.insetDir.clone().multiplyScalar(width);
            const offset1 = face1.insetDir.clone().multiplyScalar(width);

            const face0Start = localStart.clone().add(offset0);
            const face0End = localEnd.clone().add(offset0);
            const face1Start = localStart.clone().add(offset1);
            const face1End = localEnd.clone().add(offset1);

            const ringStart = [];
            const ringEnd = [];

            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                ringStart.push(face0Start.clone().lerp(face1Start, t));
                ringEnd.push(face0End.clone().lerp(face1End, t));
            }

            let bevelNormal = face0.normal.clone().add(face1.normal).normalize();
            if (bevelNormal.lengthSq() < 1e-6) {
                bevelNormal = new THREE.Vector3().crossVectors(edgeDir, face0.insetDir).normalize();
                if (bevelNormal.lengthSq() < 1e-6) {
                    bevelNormal = face0.normal.clone();
                }
            }

            const uniqueTriangles = new Map();

            const pushUniqueOriented = (a, b, c, expectedNormal) => {
                const oriented = orientTriangle(a, b, c, expectedNormal).map(v => v.clone());
                const key = oriented
                    .map(v => `${v.x.toFixed(6)},${v.y.toFixed(6)},${v.z.toFixed(6)}`)
                    .sort()
                    .join('|');

                if (!uniqueTriangles.has(key)) {
                    uniqueTriangles.set(key, oriented);
                }
            };

            // Face 0 triangles (replace original face)
            pushUniqueOriented(localStart.clone(), face0Start.clone(), face0.thirdVertex.clone(), face0.normal);
            pushUniqueOriented(face0Start.clone(), face0End.clone(), face0.thirdVertex.clone(), face0.normal);
            pushUniqueOriented(face0End.clone(), localEnd.clone(), face0.thirdVertex.clone(), face0.normal);

            // Face 1 triangles
            pushUniqueOriented(localEnd.clone(), face1End.clone(), face1.thirdVertex.clone(), face1.normal);
            pushUniqueOriented(face1End.clone(), face1Start.clone(), face1.thirdVertex.clone(), face1.normal);
            pushUniqueOriented(face1Start.clone(), localStart.clone(), face1.thirdVertex.clone(), face1.normal);

            // Bevel surface triangles
            for (let i = 1; i <= segments; i++) {
                const a0 = ringStart[i - 1].clone();
                const a1 = ringStart[i].clone();
                const b0 = ringEnd[i - 1].clone();
                const b1 = ringEnd[i].clone();

                pushUniqueOriented(a0, a1, b0, bevelNormal);
                pushUniqueOriented(a1, b1, b0, bevelNormal);
            }

            const startSideVertices = {
                face0: ringStart[0].clone(),
                face1: ringStart[ringStart.length - 1].clone()
            };

            const endSideVertices = {
                face0: ringEnd[0].clone(),
                face1: ringEnd[ringEnd.length - 1].clone()
            };

            return {
                triangles: Array.from(uniqueTriangles.values()),
                startSideVertices,
                endSideVertices,
                ringStart: ringStart.map(v => v.clone()),
                ringEnd: ringEnd.map(v => v.clone())
            };
        }

        function orientTriangle(a, b, c, expectedNormal) {
            const ab = new THREE.Vector3().subVectors(b, a);
            const ac = new THREE.Vector3().subVectors(c, a);
            const triNormal = new THREE.Vector3().crossVectors(ab, ac);
            if (triNormal.dot(expectedNormal) < 0) {
                return [a, c, b];
            }
            return [a, b, c];
        }

        // Note: createIndexedGeometryFromTriangles is imported from meshTopology.js

        function buildMeshSnapshot(geometry) {
            const positions = [];
            const posAttr = geometry.attributes.position;

            for (let i = 0; i < posAttr.count; i++) {
                positions.push(new THREE.Vector3(
                    posAttr.getX(i),
                    posAttr.getY(i),
                    posAttr.getZ(i)
                ));
            }

            const vertexToTriangles = Array.from({ length: posAttr.count }, () => []);
            const triangles = [];

            if (geometry.index) {
                const indexArray = geometry.index.array;
                const triangleCount = indexArray.length / 3;

                for (let t = 0; t < triangleCount; t++) {
                    const a = indexArray[t * 3];
                    const b = indexArray[t * 3 + 1];
                    const c = indexArray[t * 3 + 2];

                    const vA = positions[a];
                    const vB = positions[b];
                    const vC = positions[c];

                    const normal = new THREE.Vector3()
                        .crossVectors(
                            vB.clone().sub(vA),
                            vC.clone().sub(vA)
                        ).normalize();

                    triangles.push({
                        indices: [a, b, c],
                        normal
                    });

                    vertexToTriangles[a].push(t);
                    vertexToTriangles[b].push(t);
                    vertexToTriangles[c].push(t);
                }
            } else {
                const triangleCount = posAttr.count / 3;

                for (let t = 0; t < triangleCount; t++) {
                    const a = t * 3;
                    const b = t * 3 + 1;
                    const c = t * 3 + 2;

                    const vA = positions[a];
                    const vB = positions[b];
                    const vC = positions[c];

                    const normal = new THREE.Vector3()
                        .crossVectors(
                            vB.clone().sub(vA),
                            vC.clone().sub(vA)
                        ).normalize();

                    triangles.push({
                        indices: [a, b, c],
                        normal
                    });

                    vertexToTriangles[a].push(t);
                    vertexToTriangles[b].push(t);
                    vertexToTriangles[c].push(t);
                }
            }

            return { positions, triangles, vertexToTriangles };
        }

        function orderTrianglesAroundVertex(snapshot, vertexIndex) {
            const fan = snapshot.vertexToTriangles[vertexIndex];
            if (!fan || fan.length <= 1) return fan ? fan.slice() : [];

            const basePos = snapshot.positions[vertexIndex];
            const normalAccumulator = new THREE.Vector3();

            fan.forEach(triIdx => {
                normalAccumulator.add(snapshot.triangles[triIdx].normal);
            });

            if (normalAccumulator.lengthSq() < 1e-8) {
                const firstTri = snapshot.triangles[fan[0]];
                const otherIndices = firstTri.indices.filter(idx => idx !== vertexIndex);
                if (otherIndices.length >= 2) {
                    const edge1 = snapshot.positions[otherIndices[0]].clone().sub(basePos);
                    const edge2 = snapshot.positions[otherIndices[1]].clone().sub(basePos);
                    normalAccumulator.copy(edge1.cross(edge2));
                }
            }

            if (normalAccumulator.lengthSq() < 1e-8) {
                normalAccumulator.set(0, 1, 0);
            }

            normalAccumulator.normalize();

            const triData = fan.map(triIdx => {
                const tri = snapshot.triangles[triIdx];
                const otherVerts = tri.indices.filter(idx => idx !== vertexIndex);
                const midpoint = snapshot.positions[otherVerts[0]].clone()
                    .add(snapshot.positions[otherVerts[1]])
                    .multiplyScalar(0.5)
                    .sub(basePos);

                if (midpoint.lengthSq() < 1e-8) {
                    midpoint.copy(snapshot.positions[otherVerts[0]]).sub(basePos);
                }

                return {
                    triIdx,
                    vector: midpoint.normalize()
                };
            });

            let reference = triData[0].vector.clone();
            if (reference.lengthSq() < 1e-8) {
                reference.set(1, 0, 0);
            }

            reference.normalize();
            let orthogonal = new THREE.Vector3().crossVectors(normalAccumulator, reference);
            if (orthogonal.lengthSq() < 1e-8) {
                orthogonal = new THREE.Vector3(0, 1, 0).cross(normalAccumulator);
            }
            orthogonal.normalize();

            triData.forEach(item => {
                const vec = item.vector;
                item.angle = Math.atan2(vec.dot(orthogonal), vec.dot(reference));
            });

            triData.sort((a, b) => a.angle - b.angle);
            return triData.map(item => item.triIdx);
        }

        function assignTrianglesToSides(fanOrder, face0TriangleIndex, face1TriangleIndex) {
            if (!fanOrder || fanOrder.length === 0) return null;

            const len = fanOrder.length;
            const idx0 = fanOrder.indexOf(face0TriangleIndex);
            const idx1 = fanOrder.indexOf(face1TriangleIndex);

            if (idx0 === -1 || idx1 === -1) return null;

            const face0Set = new Set();
            const face1Set = new Set();

            face0Set.add(face0TriangleIndex);
            let i = (idx0 + 1) % len;
            while (i !== idx1) {
                face0Set.add(fanOrder[i]);
                i = (i + 1) % len;
                if (face0Set.size > len) break;
            }

            face1Set.add(face1TriangleIndex);
            i = (idx1 + 1) % len;
            while (i !== idx0) {
                face1Set.add(fanOrder[i]);
                i = (i + 1) % len;
                if (face1Set.size > len) break;
            }

            return { face0Set, face1Set };
        }

        function fallbackTriangleSide(triPositions, faceA, faceB) {
            const normal = new THREE.Vector3()
                .crossVectors(
                    triPositions[1].clone().sub(triPositions[0]),
                    triPositions[2].clone().sub(triPositions[0])
                ).normalize();

            const dotA = Math.abs(normal.dot(faceA.normal));
            const dotB = Math.abs(normal.dot(faceB.normal));
            return dotA >= dotB ? 'face0' : 'face1';
        }

        function createFaceBevelPreview(width, segments, depth) {
            const { originalPositions, faceCenter, faceNormal, object } = bevelData;

            console.log('Creating EDGE bevel preview for face perimeter');
            console.log('  Original vertices:', originalPositions.length);
            console.log('  Width:', width, 'Segments:', segments, 'Depth:', depth);

            const numVerts = originalPositions.length;

            // For each vertex, calculate the bevel direction
            // This is the direction we move the vertex to create the bevel
            const bevelDirections = [];

            for (let i = 0; i < numVerts; i++) {
                const prev = (i - 1 + numVerts) % numVerts;
                const next = (i + 1) % numVerts;

                const currPos = originalPositions[i];
                const prevPos = originalPositions[prev];
                const nextPos = originalPositions[next];

                // Get edge vectors FROM current vertex
                const edgeToPrev = new THREE.Vector3().subVectors(prevPos, currPos).normalize();
                const edgeToNext = new THREE.Vector3().subVectors(nextPos, currPos).normalize();

                // Calculate the angle between edges
                let dotProduct = edgeToPrev.dot(edgeToNext);
                dotProduct = Math.max(-1, Math.min(1, dotProduct)); // Clamp to avoid NaN
                const angle = Math.acos(dotProduct);

                // The bisector points inward (average of the two edge directions)
                let bisector = new THREE.Vector3().addVectors(edgeToPrev, edgeToNext);

                // If edges are nearly opposite (180 degrees), bisector will be near zero
                // In this case, use the perpendicular to one edge in the face plane
                if (bisector.length() < 0.01) {
                    console.warn(`  Vertex ${i}: edges nearly opposite, using perpendicular`);
                    bisector.crossVectors(edgeToPrev, faceNormal).normalize();
                } else {
                    bisector.normalize();
                }

                // Ensure bisector points toward face center (inward)
                const toCenter = new THREE.Vector3().subVectors(faceCenter, currPos);
                if (bisector.dot(toCenter) < 0) {
                    bisector.negate();
                }

                // Calculate the actual offset distance based on the angle
                // For a miter joint, we need to compensate for the angle
                const halfAngle = angle / 2;
                const offsetScale = halfAngle > 0.01 ? width / Math.sin(halfAngle) : width;

                bevelDirections.push({
                    dir: bisector,
                    scale: offsetScale
                });

                console.log(`  Vertex ${i}: angle=${(angle * 180 / Math.PI).toFixed(1)}Ã‚Â°, bisector=(${bisector.x.toFixed(3)}, ${bisector.y.toFixed(3)}, ${bisector.z.toFixed(3)}), scale=${offsetScale.toFixed(3)}`);
            }

            // Create two rings of vertices:
            // - Outer ring: original positions
            // - Inner ring(s): beveled positions (with segments for rounding)
            const vertexRings = [];

            // Ring 0: Original positions (outer edge)
            vertexRings.push(originalPositions.map(p => p.clone()));

            // Rings 1 to segments: Intermediate positions for rounded bevel
            for (let seg = 1; seg <= segments; seg++) {
                const t = seg / segments;
                const ring = [];

                for (let i = 0; i < numVerts; i++) {
                    const { dir, scale } = bevelDirections[i];

                    // Move inward along bisector
                    const insetPos = originalPositions[i].clone().add(dir.clone().multiplyScalar(scale * t));

                    // Move along normal for depth
                    const depthOffset = faceNormal.clone().multiplyScalar(depth * t);
                    const finalPos = insetPos.add(depthOffset);

                    ring.push(finalPos);
                }

                vertexRings.push(ring);
            }

            console.log('  Created', vertexRings.length, 'vertex rings');

            // Create preview geometry
            const previewPositions = [];

            // Create quads between each ring pair
            for (let ringIdx = 0; ringIdx < vertexRings.length - 1; ringIdx++) {
                const outerRing = vertexRings[ringIdx];
                const innerRing = vertexRings[ringIdx + 1];

                for (let i = 0; i < numVerts; i++) {
                    const next = (i + 1) % numVerts;

                    const v0 = outerRing[i];      // Current vertex, outer ring
                    const v1 = outerRing[next];   // Next vertex, outer ring
                    const v2 = innerRing[i];      // Current vertex, inner ring
                    const v3 = innerRing[next];   // Next vertex, inner ring

                    // Create quad as two triangles
                    // Triangle 1: v0, v1, v2
                    previewPositions.push(
                        v0.x, v0.y, v0.z,
                        v1.x, v1.y, v1.z,
                        v2.x, v2.y, v2.z
                    );
                    // Triangle 2: v1, v3, v2
                    previewPositions.push(
                        v1.x, v1.y, v1.z,
                        v3.x, v3.y, v3.z,
                        v2.x, v2.y, v2.z
                    );
                }
            }

            // Add center face (innermost ring)
            const centerRing = vertexRings[vertexRings.length - 1];
            for (let i = 1; i < numVerts - 1; i++) {
                previewPositions.push(
                    centerRing[0].x, centerRing[0].y, centerRing[0].z,
                    centerRing[i].x, centerRing[i].y, centerRing[i].z,
                    centerRing[i + 1].x, centerRing[i + 1].y, centerRing[i + 1].z
                );
            }

            // Create preview mesh
            const previewGeometry = new THREE.BufferGeometry();
            previewGeometry.setAttribute('position', new THREE.Float32BufferAttribute(previewPositions, 3));
            previewGeometry.computeVertexNormals();

            const previewMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6b00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });

            bevelPreviewMesh = new THREE.Mesh(previewGeometry, previewMaterial);
            bevelPreviewMesh.position.copy(object.position);
            bevelPreviewMesh.rotation.copy(object.rotation);
            bevelPreviewMesh.scale.copy(object.scale);
            scene.add(bevelPreviewMesh);

            console.log('Created face edge bevel preview with', previewPositions.length / 3, 'vertices');
        }

        function applyBevel() {
            if (!bevelData) return;

            const width = parseFloat(document.getElementById('bevel-width-slider').value);
            const segments = parseInt(document.getElementById('bevel-segments-slider').value);

            let appliedViaTopology = false;

            if (bevelData?.type === 'edge' && selectedObject && selectedEdge?.index1 !== undefined && selectedEdge?.index2 !== undefined) {
                try {
                    const topologyResult = applyEdgeBevelByVertices(
                        selectedObject,
                        selectedEdge.index1,
                        selectedEdge.index2,
                        width,
                        segments,
                        THREE
                    );
                    if (topologyResult?.geometry) {
                        appliedViaTopology = true;
                        updateWireframe(selectedObject);
                        if (selectedObject.userData?.mirror) {
                            rebuildMirrorGeometry(selectedObject);
                        }
                        console.log('MeshEditSession bevel applied:', topologyResult.patch);
                    } else if (topologyResult) {
                        console.log('MeshEditSession bevel preview:', topologyResult.patch ?? topologyResult);
                    }
                } catch (err) {
                    console.warn('MeshEditSession bevel preview failed:', err);
                }
            }

            // Remove preview mesh
            if (bevelPreviewMesh) {
                scene.remove(bevelPreviewMesh);
                bevelPreviewMesh.geometry.dispose();
                bevelPreviewMesh.material.dispose();
                bevelPreviewMesh = null;
            }

            // Hide panel
            document.getElementById('bevel-panel').style.display = 'none';

            // Perform edge bevel
            if (!appliedViaTopology) {
                performEdgeBevel(width, segments);
            } else {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        deselectAll();
                        console.log('Edge bevel complete (mesh topology)');
                    });
                });
            }

            bevelData = null;
        }

        function cancelBevel() {
            // Remove preview mesh
            if (bevelPreviewMesh) {
                scene.remove(bevelPreviewMesh);
                bevelPreviewMesh.geometry.dispose();
                bevelPreviewMesh.material.dispose();
                bevelPreviewMesh = null;
            }

            // Hide panel
            document.getElementById('bevel-panel').style.display = 'none';

            // Reset state
            bevelData = null;

            console.log('Bevel cancelled');
        }

        function mirrorAcrossFace() {
            console.log('\n' + '='.repeat(80));
            console.log('=== MIRROR ACROSS FACE ===');
            console.log('='.repeat(80));

            if (selectionMode !== 'face' || !selectedFace || !selectedObject) {
                alert('Please select a face to use as mirror plane');
                console.error('Mirror operation requires face selection');
                return;
            }

            if (selectedObject.userData?.isMirrorClone) {
                alert('Cannot create a mirror from a mirrored object');
                console.error('Mirror requested on mirror clone');
                return;
            }

            if (!selectedFace.vertexIndices || selectedFace.vertexIndices.length === 0) {
                alert('Selected face has no vertices');
                console.error('Face has no vertex indices');
                return;
            }

            const geometry = selectedObject.geometry;
            const posAttr = geometry.attributes.position;

            if (!posAttr) {
                console.error('Geometry has no position attribute');
                return;
            }

            const faceVertices = [];
            selectedFace.vertexIndices.forEach(idx => {
                faceVertices.push(new THREE.Vector3(
                    posAttr.getX(idx),
                    posAttr.getY(idx),
                    posAttr.getZ(idx)
                ));
            });

            const faceCenter = new THREE.Vector3();
            faceVertices.forEach(v => faceCenter.add(v));
            faceCenter.divideScalar(faceVertices.length);

            const v0 = faceVertices[0];
            const v1 = faceVertices[1];
            const v2 = faceVertices[2];
            const edge1 = new THREE.Vector3().subVectors(v1, v0);
            const edge2 = new THREE.Vector3().subVectors(v2, v0);
            const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2);

            if (faceNormal.lengthSq() === 0) {
                alert('Cannot mirror: face normal is zero length');
                console.error('Mirror failed: zero-length face normal', { faceVertices });
                return;
            }

            faceNormal.normalize();

            console.log('Mirror plane center (local):', faceCenter.toArray().map(n => n.toFixed(3)));
            console.log('Mirror plane normal (local):', faceNormal.toArray().map(n => n.toFixed(3)));

            removeMirrorClone(selectedObject);

            const mirroredPositions = new Float32Array(posAttr.count * 3);
            for (let i = 0; i < posAttr.count; i++) {
                const vx = posAttr.getX(i);
                const vy = posAttr.getY(i);
                const vz = posAttr.getZ(i);

                const toVertexX = vx - faceCenter.x;
                const toVertexY = vy - faceCenter.y;
                const toVertexZ = vz - faceCenter.z;
                const distance = toVertexX * faceNormal.x + toVertexY * faceNormal.y + toVertexZ * faceNormal.z;
                const doubleDist = 2 * distance;

                mirroredPositions[i * 3] = vx - faceNormal.x * doubleDist;
                mirroredPositions[i * 3 + 1] = vy - faceNormal.y * doubleDist;
                mirroredPositions[i * 3 + 2] = vz - faceNormal.z * doubleDist;
            }

            if (!geometry.index) {
                for (let i = 0; i < mirroredPositions.length; i += 9) {
                    const v0x = mirroredPositions[i];
                    const v0y = mirroredPositions[i + 1];
                    const v0z = mirroredPositions[i + 2];

                    mirroredPositions[i] = mirroredPositions[i + 6];
                    mirroredPositions[i + 1] = mirroredPositions[i + 7];
                    mirroredPositions[i + 2] = mirroredPositions[i + 8];

                    mirroredPositions[i + 6] = v0x;
                    mirroredPositions[i + 7] = v0y;
                    mirroredPositions[i + 8] = v0z;
                }
            }

            const mirroredGeometry = geometry.clone();
            mirroredGeometry.setAttribute('position', new THREE.Float32BufferAttribute(mirroredPositions, 3));
            mirroredGeometry.attributes.position.needsUpdate = true;

            if (geometry.index) {
                const sourceIndex = geometry.index.array;
                const mirroredIndex = new sourceIndex.constructor(sourceIndex.length);
                mirroredIndex.set(sourceIndex);
                for (let i = 0; i < mirroredIndex.length; i += 3) {
                    const tmp = mirroredIndex[i + 1];
                    mirroredIndex[i + 1] = mirroredIndex[i + 2];
                    mirroredIndex[i + 2] = tmp;
                }
                mirroredGeometry.setIndex(new THREE.BufferAttribute(mirroredIndex, 1));
                mirroredGeometry.index.needsUpdate = true;
            } else if (mirroredGeometry.index) {
                mirroredGeometry.setIndex(null);
            }

            mirroredGeometry.computeVertexNormals();
            mirroredGeometry.computeBoundingSphere();
            mirroredGeometry.computeBoundingBox();

            const mirrorMaterial = selectedObject.material.clone();
            const mirrorMesh = new THREE.Mesh(mirroredGeometry, mirrorMaterial);
            mirrorMesh.position.copy(selectedObject.position);
            mirrorMesh.quaternion.copy(selectedObject.quaternion);
            mirrorMesh.scale.copy(selectedObject.scale);

            mirrorMesh.userData.type = 'mirror';
            mirrorMesh.userData.isMirrorClone = true;
            mirrorMesh.userData.mirrorSource = selectedObject;

            scene.add(mirrorMesh);
            updateWireframe(mirrorMesh);

            selectedObject.userData.mirror = {
                planeCenter: faceCenter.clone(),
                planeNormal: faceNormal.clone(),
                mesh: mirrorMesh
            };

            console.log('Mirror clone created for object');
            console.log('='.repeat(80) + '\n');
        }

        function removeMirrorClone(sourceObject) {
            const mirrorInfo = sourceObject?.userData?.mirror;
            if (!mirrorInfo || !mirrorInfo.mesh) return;

            const mirrorMesh = mirrorInfo.mesh;

            if (mirrorMesh.userData?.wireframe) {
                mirrorMesh.remove(mirrorMesh.userData.wireframe);
                mirrorMesh.userData.wireframe.geometry.dispose();
                mirrorMesh.userData.wireframe.material.dispose();
                delete mirrorMesh.userData.wireframe;
            }

            if (mirrorMesh.userData?.edgeVisualization) {
                mirrorMesh.remove(mirrorMesh.userData.edgeVisualization);
                mirrorMesh.userData.edgeVisualization.geometry.dispose();
                mirrorMesh.userData.edgeVisualization.material.dispose();
                delete mirrorMesh.userData.edgeVisualization;
            }

            scene.remove(mirrorMesh);

            if (mirrorMesh.geometry) {
                mirrorMesh.geometry.dispose();
            }

            if (mirrorMesh.material) {
                if (Array.isArray(mirrorMesh.material)) {
                    mirrorMesh.material.forEach(mat => mat.dispose && mat.dispose());
                } else if (mirrorMesh.material.dispose) {
                    mirrorMesh.material.dispose();
                }
            }

            delete mirrorMesh.userData.mirrorSource;
            delete sourceObject.userData.mirror;
        }

        function rebuildMirrorGeometry(sourceObject) {
            const mirrorInfo = sourceObject?.userData?.mirror;
            if (!mirrorInfo) return;

            const mirrorMesh = mirrorInfo.mesh;
            if (!mirrorMesh) return;

            const geometry = sourceObject.geometry;
            const posAttr = geometry.attributes.position;
            if (!posAttr) return;

            const planeCenter = mirrorInfo.planeCenter;
            const planeNormal = mirrorInfo.planeNormal;
            if (!planeCenter || !planeNormal) return;

            const mirroredPositions = new Float32Array(posAttr.count * 3);
            for (let i = 0; i < posAttr.count; i++) {
                const vx = posAttr.getX(i);
                const vy = posAttr.getY(i);
                const vz = posAttr.getZ(i);

                const toVertexX = vx - planeCenter.x;
                const toVertexY = vy - planeCenter.y;
                const toVertexZ = vz - planeCenter.z;
                const distance = toVertexX * planeNormal.x + toVertexY * planeNormal.y + toVertexZ * planeNormal.z;
                const doubleDist = 2 * distance;

                mirroredPositions[i * 3] = vx - planeNormal.x * doubleDist;
                mirroredPositions[i * 3 + 1] = vy - planeNormal.y * doubleDist;
                mirroredPositions[i * 3 + 2] = vz - planeNormal.z * doubleDist;
            }

            if (!geometry.index) {
                for (let i = 0; i < mirroredPositions.length; i += 9) {
                    const v0x = mirroredPositions[i];
                    const v0y = mirroredPositions[i + 1];
                    const v0z = mirroredPositions[i + 2];

                    mirroredPositions[i] = mirroredPositions[i + 6];
                    mirroredPositions[i + 1] = mirroredPositions[i + 7];
                    mirroredPositions[i + 2] = mirroredPositions[i + 8];

                    mirroredPositions[i + 6] = v0x;
                    mirroredPositions[i + 7] = v0y;
                    mirroredPositions[i + 8] = v0z;
                }
            }

            const mirrorGeometry = mirrorMesh.geometry;
            let mirrorPosAttr = mirrorGeometry.attributes.position;

            if (!mirrorPosAttr || mirrorPosAttr.count !== posAttr.count) {
                mirrorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(mirroredPositions, 3));
                mirrorPosAttr = mirrorGeometry.attributes.position;
                mirrorPosAttr.needsUpdate = true;
            } else {
                mirrorPosAttr.copyArray(mirroredPositions);
                mirrorPosAttr.needsUpdate = true;
            }

            if (geometry.index) {
                const sourceIndex = geometry.index.array;
                let mirrorIndexArray;
                if (mirrorGeometry.index && mirrorGeometry.index.array.length === sourceIndex.length) {
                    mirrorIndexArray = mirrorGeometry.index.array;
                } else {
                    mirrorIndexArray = new sourceIndex.constructor(sourceIndex.length);
                }

                mirrorIndexArray.set(sourceIndex);
                for (let i = 0; i < mirrorIndexArray.length; i += 3) {
                    const tmp = mirrorIndexArray[i + 1];
                    mirrorIndexArray[i + 1] = mirrorIndexArray[i + 2];
                    mirrorIndexArray[i + 2] = tmp;
                }

                mirrorGeometry.setIndex(new THREE.BufferAttribute(mirrorIndexArray, 1));
                mirrorGeometry.index.needsUpdate = true;
            } else if (mirrorGeometry.index) {
                mirrorGeometry.setIndex(null);
            }

            mirrorGeometry.computeVertexNormals();
            mirrorGeometry.computeBoundingSphere();
            mirrorGeometry.computeBoundingBox();

            updateWireframe(mirrorMesh);
        }

        /**
         * Creates or updates the visual symmetry plane indicator
         */
        function updateSymmetryPlane() {
            // Remove existing plane
            if (symmetryPlane) {
                scene.remove(symmetryPlane);
                symmetryPlane.geometry.dispose();
                symmetryPlane.material.dispose();
                symmetryPlane = null;
            }

            // Create new plane if symmetry is enabled
            if (symmetryEnabled && selectedObject) {
                const size = 10;
                const planeGeometry = new THREE.PlaneGeometry(size, size);
                const planeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });

                symmetryPlane = new THREE.Mesh(planeGeometry, planeMaterial);

                // Position and orient plane based on axis
                if (symmetryAxis === 'x') {
                    symmetryPlane.rotation.y = Math.PI / 2;
                    symmetryPlane.position.set(0, 0, 0);
                } else if (symmetryAxis === 'y') {
                    symmetryPlane.rotation.x = Math.PI / 2;
                    symmetryPlane.position.set(0, 0, 0);
                } else if (symmetryAxis === 'z') {
                    // Z plane is default orientation
                    symmetryPlane.position.set(0, 0, 0);
                }

                scene.add(symmetryPlane);
            }
        }

        /**
         * Finds the mirrored vertex indices for a given vertex
         * Returns an array of vertex indices that are mirror counterparts
         */
        function findMirroredVertices(geometry, vertexIndex, axis, threshold = 0.001) {
            const posAttr = geometry.attributes.position;
            const vertex = new THREE.Vector3(
                posAttr.getX(vertexIndex),
                posAttr.getY(vertexIndex),
                posAttr.getZ(vertexIndex)
            );

            const mirroredVertices = [];
            const axisIndex = axis === 'x' ? 0 : axis === 'y' ? 1 : 2;

            // Calculate mirrored position
            const mirroredPos = vertex.clone();
            mirroredPos.setComponent(axisIndex, -mirroredPos.getComponent(axisIndex));

            // Find all vertices at the mirrored position
            for (let i = 0; i < posAttr.count; i++) {
                const testVert = new THREE.Vector3(
                    posAttr.getX(i),
                    posAttr.getY(i),
                    posAttr.getZ(i)
                );

                if (testVert.distanceTo(mirroredPos) < threshold) {
                    mirroredVertices.push(i);
                }
            }

            return mirroredVertices;
        }

        /**
         * Applies a transformation to a vertex and its mirrored counterparts
         */
        function applySymmetricTransform(geometry, vertexIndices, movement) {
            if (!symmetryEnabled || !geometry) return;

            const posAttr = geometry.attributes.position;
            const allIndicesToMove = new Set(vertexIndices);

            // Find mirrored vertices for each vertex being moved
            vertexIndices.forEach(idx => {
                const mirroredIndices = findMirroredVertices(geometry, idx, symmetryAxis);
                mirroredIndices.forEach(mirIdx => allIndicesToMove.add(mirIdx));
            });

            // Apply mirrored movement to mirrored vertices
            allIndicesToMove.forEach(idx => {
                const mirroredMovement = movement.clone();

                // Check if this is a mirrored vertex (on the opposite side)
                const vertex = new THREE.Vector3(
                    posAttr.getX(idx),
                    posAttr.getY(idx),
                    posAttr.getZ(idx)
                );

                const axisIndex = symmetryAxis === 'x' ? 0 : symmetryAxis === 'y' ? 1 : 2;
                const isOriginalSide = vertexIndices.includes(idx);

                if (!isOriginalSide) {
                    // This is a mirrored vertex - flip the movement on the symmetry axis
                    const comp = mirroredMovement.getComponent(axisIndex);
                    mirroredMovement.setComponent(axisIndex, -comp);
                }

                // Apply movement
                vertex.add(mirroredMovement);
                posAttr.setXYZ(idx, vertex.x, vertex.y, vertex.z);
            });

            posAttr.needsUpdate = true;
        }

        function performEdgeBevel(width, segments) {
            if (!bevelData || bevelData.type !== 'edge') {
                console.error('No bevel data available');
                return;
            }

            segments = Math.max(1, segments);

            const { object, geometry, maxWidth, faceInfo, edge } = bevelData;

            const edgeIndex1 = edge.index1 ?? (edge.indices?.start?.[0]);
            const edgeIndex2 = edge.index2 ?? (edge.indices?.end?.[0]);

            if (edgeIndex1 === undefined || edgeIndex2 === undefined) {
                console.error('Cannot determine edge vertex indices for bevel');
                return;
            }

            const clampedWidth = Math.min(width, maxWidth);
            if (clampedWidth <= 1e-5) {
                console.warn('Bevel width too small, aborting bevel operation');
                return;
            }

            console.log('\n' + '='.repeat(80));
            console.log('=== EDGE BEVEL ===');
            console.log('Parameters:', { requestedWidth: width, appliedWidth: clampedWidth, segments });
            console.log('='.repeat(80));

            const bevelMesh = buildEdgeBevelMesh(clampedWidth, segments);
            if (!bevelMesh || bevelMesh.triangles.length === 0) {
                console.error('Failed to build bevel geometry');
                return;
            }

            const positionAttr = geometry.attributes.position;
            const isIndexed = !!geometry.index;
            const indexArray = isIndexed ? geometry.index.array : null;
            const triangleCount = isIndexed ? indexArray.length / 3 : positionAttr.count / 3;

            const faceA = faceInfo[0];
            const faceB = faceInfo[1];

            const snapshot = buildMeshSnapshot(geometry);
            const startFanOrder = orderTrianglesAroundVertex(snapshot, edgeIndex1);
            const endFanOrder = orderTrianglesAroundVertex(snapshot, edgeIndex2);
            const startAssignment = assignTrianglesToSides(startFanOrder, faceA.triangleIndex, faceB.triangleIndex);
            const endAssignment = assignTrianglesToSides(endFanOrder, faceA.triangleIndex, faceB.triangleIndex);

            const startSideMap = new Map();
            const endSideMap = new Map();

            if (startAssignment) {
                startAssignment.face0Set.forEach(triIdx => startSideMap.set(triIdx, 'face0'));
                startAssignment.face1Set.forEach(triIdx => startSideMap.set(triIdx, 'face1'));
            }

            if (endAssignment) {
                endAssignment.face0Set.forEach(triIdx => endSideMap.set(triIdx, 'face0'));
                endAssignment.face1Set.forEach(triIdx => endSideMap.set(triIdx, 'face1'));
            }

            const startSidePositions = bevelMesh.startSideVertices;
            const endSidePositions = bevelMesh.endSideVertices;

            const getPosition = (vertexIndex) => new THREE.Vector3(
                positionAttr.getX(vertexIndex),
                positionAttr.getY(vertexIndex),
                positionAttr.getZ(vertexIndex)
            );

            const originalStartPos = getPosition(edgeIndex1);
            const originalEndPos = getPosition(edgeIndex2);

            const trianglesToRemove = new Set([faceA.triangleIndex, faceB.triangleIndex]);
            const existingTriangles = [];
            let removedTriangles = 0;

            for (let tri = 0; tri < triangleCount; tri++) {
                if (trianglesToRemove.has(tri)) {
                    removedTriangles++;
                    continue;
                }

                const triIndices = isIndexed
                    ? [
                        indexArray[tri * 3],
                        indexArray[tri * 3 + 1],
                        indexArray[tri * 3 + 2]
                    ]
                    : [
                        tri * 3,
                        tri * 3 + 1,
                        tri * 3 + 2
                    ];

                const includesStart = triIndices.includes(edgeIndex1);
                const includesEnd = triIndices.includes(edgeIndex2);

                const triPositions = triIndices.map(getPosition);

                if (includesStart || includesEnd) {
                    const targetIndex = includesStart ? edgeIndex1 : edgeIndex2;
                    const targetPosition = includesStart ? originalStartPos : originalEndPos;

                    let side = includesStart ? startSideMap.get(tri) : endSideMap.get(tri);
                    if (!side) {
                        side = fallbackTriangleSide(triPositions, faceA, faceB);
                    }

                    const replacementPos = includesStart ? startSidePositions[side] : endSidePositions[side];

                    const replaced = triIndices.map((idx, idxPos) => {
                        if ((includesStart && idx === edgeIndex1) || (includesEnd && idx === edgeIndex2)) {
                            return replacementPos.clone();
                        }
                        return triPositions[idxPos].clone();
                    });

                    existingTriangles.push(replaced);
                } else {
                    existingTriangles.push(triPositions);
                }
            }

            if (removedTriangles < 2) {
                console.warn('Expected to remove 2 adjacent triangles, removed', removedTriangles);
            }

            const allTriangles = [
                ...existingTriangles,
                ...bevelMesh.triangles.map(tri => tri.map(v => v.clone()))
            ];

            const newGeometry = createIndexedGeometryFromTriangles(allTriangles);

            object.geometry.dispose();
            object.geometry = newGeometry;

            updateWireframe(object);

            if (bevelPreviewMesh) {
                scene.remove(bevelPreviewMesh);
                bevelPreviewMesh.geometry.dispose();
                bevelPreviewMesh.material.dispose();
                bevelPreviewMesh = null;
            }

            bevelData = null;

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    deselectAll();
                    console.log('Edge bevel complete');
                });
            });
        }
function performFaceBevel(width, segments, depth) {
            if (!bevelData) {
                console.error('No bevel data available');
                return;
            }

            console.log('\n' + '='.repeat(80));
            console.log('=== FACE EDGE BEVEL ===');
            console.log('='.repeat(80));
            console.log('Parameters:', { width, segments, depth });

            const { object, geometry, originalPositions, faceCenter, faceNormal, originalVertexIndices } = bevelData;

            const numVerts = originalPositions.length;

            // Calculate bevel directions (same as preview)
            const bevelDirections = [];

            for (let i = 0; i < numVerts; i++) {
                const prev = (i - 1 + numVerts) % numVerts;
                const next = (i + 1) % numVerts;

                const currPos = originalPositions[i];
                const prevPos = originalPositions[prev];
                const nextPos = originalPositions[next];

                const edgeToPrev = new THREE.Vector3().subVectors(prevPos, currPos).normalize();
                const edgeToNext = new THREE.Vector3().subVectors(nextPos, currPos).normalize();

                let dotProduct = edgeToPrev.dot(edgeToNext);
                dotProduct = Math.max(-1, Math.min(1, dotProduct));
                const angle = Math.acos(dotProduct);

                let bisector = new THREE.Vector3().addVectors(edgeToPrev, edgeToNext);

                if (bisector.length() < 0.01) {
                    bisector.crossVectors(edgeToPrev, faceNormal).normalize();
                } else {
                    bisector.normalize();
                }

                const toCenter = new THREE.Vector3().subVectors(faceCenter, currPos);
                if (bisector.dot(toCenter) < 0) {
                    bisector.negate();
                }

                const halfAngle = angle / 2;
                const offsetScale = halfAngle > 0.01 ? width / Math.sin(halfAngle) : width;

                bevelDirections.push({
                    dir: bisector,
                    scale: offsetScale
                });
            }

            // Create vertex rings
            const vertexRings = [];
            vertexRings.push(originalPositions.map(p => p.clone()));

            for (let seg = 1; seg <= segments; seg++) {
                const t = seg / segments;
                const ring = [];

                for (let i = 0; i < numVerts; i++) {
                    const { dir, scale } = bevelDirections[i];
                    const insetPos = originalPositions[i].clone().add(dir.clone().multiplyScalar(scale * t));
                    const depthOffset = faceNormal.clone().multiplyScalar(depth * t);
                    const finalPos = insetPos.add(depthOffset);
                    ring.push(finalPos);
                }

                vertexRings.push(ring);
            }

            // Build new geometry
            const newPositions = [];
            const positionAttr = geometry.attributes.position;
            const selectedVertexSet = new Set(originalVertexIndices);

            // Copy existing geometry, excluding selected face triangles
            const isIndexed = !!geometry.index;
            let trianglesSkipped = 0;
            let trianglesCopied = 0;

            if (isIndexed) {
                const indices = geometry.index.array;
                const triangleCount = indices.length / 3;

                for (let i = 0; i < triangleCount; i++) {
                    const idx0 = indices[i * 3];
                    const idx1 = indices[i * 3 + 1];
                    const idx2 = indices[i * 3 + 2];

                    const usesSelectedVertex = selectedVertexSet.has(idx0) || selectedVertexSet.has(idx1) || selectedVertexSet.has(idx2);

                    if (usesSelectedVertex) {
                        trianglesSkipped++;
                        continue;
                    }

                    const v0 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx0);
                    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx1);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx2);

                    newPositions.push(
                        v0.x, v0.y, v0.z,
                        v1.x, v1.y, v1.z,
                        v2.x, v2.y, v2.z
                    );
                    trianglesCopied++;
                }
            }

            console.log(`Copied ${trianglesCopied} triangles, skipped ${trianglesSkipped} triangles`);

            // Add bevel surface (quads between rings)
            let bevelTriangles = 0;

            for (let ringIdx = 0; ringIdx < vertexRings.length - 1; ringIdx++) {
                const outerRing = vertexRings[ringIdx];
                const innerRing = vertexRings[ringIdx + 1];

                for (let i = 0; i < numVerts; i++) {
                    const next = (i + 1) % numVerts;

                    const v0 = outerRing[i];
                    const v1 = outerRing[next];
                    const v2 = innerRing[i];
                    const v3 = innerRing[next];

                    newPositions.push(
                        v0.x, v0.y, v0.z,
                        v1.x, v1.y, v1.z,
                        v2.x, v2.y, v2.z
                    );
                    newPositions.push(
                        v1.x, v1.y, v1.z,
                        v3.x, v3.y, v3.z,
                        v2.x, v2.y, v2.z
                    );
                    bevelTriangles += 2;
                }
            }

            // Add center face (innermost ring)
            const centerRing = vertexRings[vertexRings.length - 1];
            let centerFaceTriangles = 0;
            for (let i = 1; i < numVerts - 1; i++) {
                newPositions.push(
                    centerRing[0].x, centerRing[0].y, centerRing[0].z,
                    centerRing[i].x, centerRing[i].y, centerRing[i].z,
                    centerRing[i + 1].x, centerRing[i + 1].y, centerRing[i + 1].z
                );
                centerFaceTriangles++;
            }

            console.log(`Created ${bevelTriangles} bevel triangles, ${centerFaceTriangles} center face triangles`);

            // Create new geometry
            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            newGeometry.setDrawRange(0, newPositions.length / 3);
            newGeometry.computeVertexNormals();
            newGeometry.computeBoundingBox();
            newGeometry.computeBoundingSphere();

            // Replace geometry
            object.geometry.dispose();
            object.geometry = newGeometry;

            // Update matrices
            object.updateMatrix();
            object.updateMatrixWorld(true);
            object.matrixWorldNeedsUpdate = true;

            // Update wireframe
            const wireframeChild = object.children.find(child => child.type === 'LineSegments');
            if (wireframeChild) {
                const newEdges = new THREE.EdgesGeometry(newGeometry);
                wireframeChild.geometry.dispose();
                wireframeChild.geometry = newEdges;
            }

            console.log('Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ FACE EDGE BEVEL COMPLETE Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ');
            console.log('='.repeat(80) + '\n');

            // Force render update
            renderer.render(scene, camera);

            // Reset state
            bevelData = null;

            // Deselect after completion
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    deselectAll();
                    console.log('Bevel complete - geometry should be interactive');
                });
            });
        }

        /**
         * Performs the actual face extrusion
         * 
         * This is the core function that creates new geometry.
         * 
         * ALGORITHM:
         * 1. Duplicate face vertices
         * 2. Move duplicates along normal by extrudeDistance
         * 3. Apply taper (scale from center)
         * 4. Apply rotation
         * 5. Create side faces connecting original Ã¢â€ â€™ new vertices
         * 6. Check for punch-through (raycast to opposite face)
         * 7. If punch-through: connect to opposite face, remove interior
         * 8. Update geometry indices
         * 
         * PARAMETERS:
         * @param {number} distance - Extrusion distance (negative = inward)
         * @param {number} taper - Scale factor (0.5 = half size, 2.0 = double size)
         * @param {number} rotation - Rotation angle in radians
         * 
         * PORTING: This is the heart of the system - port this carefully
         */
        function performFaceExtrusion(distance, taper, rotation) {
            if (!extrusionData) {
                console.error('No extrusion data available');
                return;
            }

            console.log('\n'.repeat(3) + '='.repeat(80));
            console.log('=== FACE EXTRUSION DEBUG LOG ===');
            console.log('='.repeat(80));
            console.log('Parameters:', { distance, taper, rotation });

            const { object, geometry, originalPositions, faceCenter, faceNormal, originalVertexIndices } = extrusionData;

            console.log('\n--- INITIAL STATE ---');
            console.log('Object:', object.name || object.uuid);
            console.log('Original geometry vertex count:', geometry.attributes.position.count);
            console.log('Selected face vertex count:', originalPositions.length);
            console.log('Face center:', faceCenter.toArray());
            console.log('Face normal:', faceNormal.toArray());
            console.log('\nOriginal face vertices:');
            originalPositions.forEach((v, i) => {
                console.log(`  [${i}] Position: [${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)}]`);
            });

            // STEP 1: Calculate extruded vertex positions
            console.log('\n--- STEP 1: Calculate Extruded Vertices ---');
            const extrudedVertices = [];

            originalPositions.forEach((origPos, i) => {
                // Start with original position
                const extrudedPos = origPos.clone();

                // Move along normal by distance
                extrudedPos.add(faceNormal.clone().multiplyScalar(distance));

                // Apply taper (scale from face center)
                if (taper !== 1.0) {
                    const offsetFromCenter = extrudedPos.clone().sub(faceCenter);
                    offsetFromCenter.multiplyScalar(taper);
                    extrudedPos.copy(faceCenter).add(offsetFromCenter);
                }

                // Apply rotation around face normal
                if (rotation !== 0) {
                    const offsetFromCenter = extrudedPos.clone().sub(faceCenter);
                    offsetFromCenter.applyAxisAngle(faceNormal, rotation);
                    extrudedPos.copy(faceCenter).add(offsetFromCenter);
                }

                extrudedVertices.push(extrudedPos);
                console.log(`  [${i}] Original: [${origPos.x.toFixed(3)}, ${origPos.y.toFixed(3)}, ${origPos.z.toFixed(3)}] => Extruded: [${extrudedPos.x.toFixed(3)}, ${extrudedPos.y.toFixed(3)}, ${extrudedPos.z.toFixed(3)}]`);
            });

            // STEP 1.5: Recalculate punch-through detection with actual distance
            let isPunchThrough = false;
            let punchThroughDistance = null;
            let oppositeFaceVertices = null;
            let oppositeFaceCenter = null;
            let oppositeFaceNormal = null;
            let oppositeFaceTriangleIndices = [];

            // Only check for punch-through if distance is negative (inward extrusion)
            if (distance < 0) {
                console.log('\n--- CHECKING FOR PUNCH-THROUGH ---');
                console.log(`Extrusion distance: ${distance.toFixed(3)} (negative = inward)`);

                // Raycast from INSIDE the geometry to avoid self-intersection
                // Start ray at a small offset along the negative normal
                const rayOrigin = faceCenter.clone().add(faceNormal.clone().multiplyScalar(-0.01));
                const rayDirection = faceNormal.clone().negate(); // Inward direction

                console.log('Ray origin (offset inside):', rayOrigin.toArray().map(n => n.toFixed(3)));
                console.log('Ray direction:', rayDirection.toArray().map(n => n.toFixed(3)));

                const raycaster = new THREE.Raycaster();
                raycaster.set(rayOrigin, rayDirection);
                const intersects = raycaster.intersectObject(object, false);

                if (intersects.length > 0) {
                    const hitDistance = intersects[0].distance;
                    punchThroughDistance = hitDistance;
                    console.log(`Distance to opposite face: ${hitDistance.toFixed(3)}`);
                    console.log(`Extrusion depth: ${Math.abs(distance).toFixed(3)}`);

                    if (Math.abs(distance) >= hitDistance) {
                        isPunchThrough = true;
                        console.log('Ã¢Å¡Â  PUNCH-THROUGH CONFIRMED! Creating through-hole...');
                    } else {
                        console.log('Ã¢Å“â€œ No punch-through - extrusion stops before opposite face');
                    }
                } else {
                    console.log('Ã¢Å“â€œ No opposite face detected - safe to extrude inward');
                }
            }

            // If punch-through detected, find and prepare the opposite face
            if (isPunchThrough) {
                console.log('\n--- PREPARING OPPOSITE FACE FOR PUNCH-THROUGH ---');

                const raycaster = new THREE.Raycaster();
                const rayOrigin = faceCenter.clone();
                const rayDirection = faceNormal.clone().negate();

                raycaster.set(rayOrigin, rayDirection);
                const intersects = raycaster.intersectObject(object, false);

                console.log(`Raycast found ${intersects.length} intersections`);

                // Find the first intersection that is NOT part of the entry face
                let validIntersect = null;
                const isIndexed = !!geometry.index;

                for (let i = 0; i < intersects.length; i++) {
                    const hitFaceIndex = intersects[i].faceIndex;

                    // Check if this triangle uses any of the selected face vertex indices
                    let isEntryFace = false;
                    if (isIndexed) {
                        const indices = geometry.index.array;
                        const idx0 = indices[hitFaceIndex * 3];
                        const idx1 = indices[hitFaceIndex * 3 + 1];
                        const idx2 = indices[hitFaceIndex * 3 + 2];
                        isEntryFace = originalVertexIndices.includes(idx0) ||
                                     originalVertexIndices.includes(idx1) ||
                                     originalVertexIndices.includes(idx2);
                    }

                    if (!isEntryFace) {
                        validIntersect = intersects[i];
                        console.log(`Found valid opposite face at triangle ${hitFaceIndex} (skipped ${i} entry face triangles)`);
                        break;
                    } else {
                        console.log(`Skipping triangle ${hitFaceIndex}: part of entry face`);
                    }
                }

                if (validIntersect) {
                    const hitFaceIndex = validIntersect.faceIndex;
                    console.log(`Hit opposite face at triangle index ${hitFaceIndex}`);

                    // Extract the opposite face vertices
                    // We need to find all triangles that make up this face (similar to original face detection)
                    const positionAttr = geometry.attributes.position;
                    const isIndexed = !!geometry.index;

                    // Get the hit triangle's vertices
                    let hitV0, hitV1, hitV2;
                    if (isIndexed) {
                        const indices = geometry.index.array;
                        const idx0 = indices[hitFaceIndex * 3];
                        const idx1 = indices[hitFaceIndex * 3 + 1];
                        const idx2 = indices[hitFaceIndex * 3 + 2];
                        hitV0 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx0);
                        hitV1 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx1);
                        hitV2 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx2);
                    } else {
                        hitV0 = new THREE.Vector3().fromBufferAttribute(positionAttr, hitFaceIndex * 3);
                        hitV1 = new THREE.Vector3().fromBufferAttribute(positionAttr, hitFaceIndex * 3 + 1);
                        hitV2 = new THREE.Vector3().fromBufferAttribute(positionAttr, hitFaceIndex * 3 + 2);
                    }

                    // Calculate opposite face normal and center from hit triangle
                    const edge1 = new THREE.Vector3().subVectors(hitV1, hitV0);
                    const edge2 = new THREE.Vector3().subVectors(hitV2, hitV0);
                    oppositeFaceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                    oppositeFaceCenter = new THREE.Vector3()
                        .add(hitV0).add(hitV1).add(hitV2)
                        .divideScalar(3);

                    console.log('Opposite face normal (raw):', oppositeFaceNormal.toArray());
                    console.log('Opposite face center:', oppositeFaceCenter.toArray());

                    // CRITICAL CHECK: Opposite face normal should point OPPOSITE to our face normal
                    // If dot product is positive, they point in same direction - we hit our own face!
                    const dotProduct = oppositeFaceNormal.dot(faceNormal);
                    console.log('Dot product (opposite Ã‚Â· original):', dotProduct.toFixed(3));

                    if (dotProduct > 0) {
                        console.log('Ã¢Å¡Â  Opposite face normal points SAME direction - this is the same face!');
                        console.log('Skipping punch-through - cannot punch through own face');
                        isPunchThrough = false;
                    } else {
                        console.log('Ã¢Å“â€œ Opposite face normal points opposite direction - valid opposite face');

                        // Find all triangles that belong to this face (coplanar and connected)
                        const oppositeFaceVertexSet = new Set();
                        oppositeFaceTriangleIndices = [];

                    const triangleCount = isIndexed ? geometry.index.array.length / 3 : positionAttr.count / 3;

                    for (let i = 0; i < triangleCount; i++) {
                        let v0, v1, v2;

                        if (isIndexed) {
                            const indices = geometry.index.array;
                            const idx0 = indices[i * 3];
                            const idx1 = indices[i * 3 + 1];
                            const idx2 = indices[i * 3 + 2];
                            v0 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx0);
                            v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx1);
                            v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx2);
                        } else {
                            v0 = new THREE.Vector3().fromBufferAttribute(positionAttr, i * 3);
                            v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, i * 3 + 1);
                            v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, i * 3 + 2);
                        }

                        // Check if this triangle is coplanar with the hit face
                        const triCenter = new THREE.Vector3().add(v0).add(v1).add(v2).divideScalar(3);
                        const centerToOppCenter = triCenter.clone().sub(oppositeFaceCenter);
                        const distToPlane = Math.abs(centerToOppCenter.dot(oppositeFaceNormal));

                        if (distToPlane < 0.01) {
                            // This triangle is part of the opposite face
                            oppositeFaceTriangleIndices.push(i);
                            oppositeFaceVertexSet.add(v0.toArray().join(','));
                            oppositeFaceVertexSet.add(v1.toArray().join(','));
                            oppositeFaceVertexSet.add(v2.toArray().join(','));
                        }
                    }

                    // Convert vertex set to array of Vector3
                    const oppositeVertexArray = Array.from(oppositeFaceVertexSet).map(str => {
                        const [x, y, z] = str.split(',').map(Number);
                        return new THREE.Vector3(x, y, z);
                    });

                    console.log(`Found ${oppositeFaceTriangleIndices.length} triangles in opposite face with ${oppositeVertexArray.length} unique vertices`);

                    // Sort vertices by angle around opposite face center (same as original face)
                    const sortedData = oppositeVertexArray.map((pos) => {
                        const toVertex = new THREE.Vector3().subVectors(pos, oppositeFaceCenter);
                        const refVector = new THREE.Vector3(1, 0, 0);
                        if (Math.abs(oppositeFaceNormal.x) > 0.9) {
                            refVector.set(0, 1, 0);
                        }
                        const refInPlane = refVector.clone().sub(
                            oppositeFaceNormal.clone().multiplyScalar(refVector.dot(oppositeFaceNormal))
                        ).normalize();
                        const angle = Math.atan2(
                            toVertex.clone().cross(refInPlane).dot(oppositeFaceNormal),
                            toVertex.dot(refInPlane)
                        );
                        return { pos, angle };
                    });
                    sortedData.sort((a, b) => a.angle - b.angle);
                    oppositeFaceVertices = sortedData.map(d => d.pos);

                    console.log('Sorted opposite face vertices:', oppositeFaceVertices.length);
                    oppositeFaceVertices.forEach((v, i) => {
                        console.log(`  [${i}] ${v.toArray().map(n => n.toFixed(3)).join(', ')}`);
                    });

                    // REMOVED: Vertex projection
                    // For punch-through, we DON'T project extruded vertices to the opposite face.
                    // Instead, they stay at their full extrusion depth, and the exit cap connects
                    // them to the opposite face perimeter vertices.
                    console.log('Keeping extruded vertices at full depth (no projection for punch-through)');
                    extrudedVertices.forEach((v, i) => {
                        console.log(`  Exit vertex ${i}: (${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)})`);
                    });
                    }  // End of else block for valid opposite face
                } else {
                    console.log('Ã¢Å¡Â  No valid opposite face found - all intersections were entry face triangles');
                    console.log('Cancelling punch-through');
                    isPunchThrough = false;
                }
            }

            // STEP 2: Build new geometry arrays (EXCLUDING the original selected face and opposite face if punch-through)
            console.log('\n--- STEP 2: Copy Existing Geometry (Excluding Selected Face' + (isPunchThrough ? ' and Opposite Face' : '') + ') ---');
            const newPositions = [];

            // Get the indices of vertices in the selected face
            const selectedVertexSet = new Set(originalVertexIndices);
            console.log('Selected face vertex indices to EXCLUDE:', Array.from(selectedVertexSet));
            console.log('Original face vertex positions to match:');
            originalPositions.forEach((pos, idx) => {
                console.log(`  [${idx}] (${pos.x.toFixed(3)}, ${pos.y.toFixed(3)}, ${pos.z.toFixed(3)})`);
            });

            if (isPunchThrough && oppositeFaceTriangleIndices.length > 0) {
                console.log('Opposite face triangle indices to EXCLUDE:', oppositeFaceTriangleIndices);
            }

            // Copy all existing geometry EXCEPT triangles that are part of the selected face (and opposite face if punch-through)
            const positionAttr = geometry.attributes.position;
            let trianglesSkipped = 0;
            let trianglesCopied = 0;
            let oppositeFaceSkipped = 0;

            // CRITICAL: Check if geometry is indexed or non-indexed
            const isIndexed = !!geometry.index;
            console.log(`Geometry is ${isIndexed ? 'INDEXED' : 'NON-INDEXED'}`);

            if (isIndexed) {
                // INDEXED GEOMETRY (like BoxGeometry)
                const indices = geometry.index.array;
                const triangleCount = indices.length / 3;

                for (let i = 0; i < triangleCount; i++) {
                    const idx0 = indices[i * 3];
                    const idx1 = indices[i * 3 + 1];
                    const idx2 = indices[i * 3 + 2];

                    // Check if this triangle uses ANY of the selected face vertex indices
                    const usesSelectedVertex = selectedVertexSet.has(idx0) || selectedVertexSet.has(idx1) || selectedVertexSet.has(idx2);

                    if (usesSelectedVertex) {
                        // This triangle is part of the selected face - skip it
                        console.log(`  Skipping triangle ${i}: uses selected face vertex indices [${idx0}, ${idx1}, ${idx2}]`);
                        trianglesSkipped++;
                        continue;
                    }

                    // Skip opposite face triangles if punch-through
                    if (isPunchThrough && oppositeFaceTriangleIndices.includes(i)) {
                        console.log(`  Skipping triangle ${i}: it's part of the opposite face (punch-through exit)`);
                        oppositeFaceSkipped++;
                        continue;
                    }

                    // Copy this triangle (converting from indexed to non-indexed)
                    const v0 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx0);
                    const v1 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx1);
                    const v2 = new THREE.Vector3().fromBufferAttribute(positionAttr, idx2);

                    newPositions.push(
                        v0.x, v0.y, v0.z,
                        v1.x, v1.y, v1.z,
                        v2.x, v2.y, v2.z
                    );
                    trianglesCopied++;
                }
            } else {
                // NON-INDEXED GEOMETRY
                const existingVertCount = positionAttr.count;

                for (let i = 0; i < existingVertCount; i += 3) {
                    const triangleIndex = i / 3;

                    // Skip opposite face triangles if punch-through
                    if (isPunchThrough && oppositeFaceTriangleIndices.includes(triangleIndex)) {
                        console.log(`  Skipping triangle ${triangleIndex}: it's part of the opposite face (punch-through exit)`);
                        oppositeFaceSkipped++;
                        continue;
                    }

                    const v0 = new THREE.Vector3(positionAttr.getX(i), positionAttr.getY(i), positionAttr.getZ(i));
                    const v1 = new THREE.Vector3(positionAttr.getX(i+1), positionAttr.getY(i+1), positionAttr.getZ(i+1));
                    const v2 = new THREE.Vector3(positionAttr.getX(i+2), positionAttr.getY(i+2), positionAttr.getZ(i+2));

                    // Check if all 3 vertices are in our selected face
                    const tolerance = 0.001; // Slightly larger tolerance for floating point comparison
                    let v0Matches = false, v1Matches = false, v2Matches = false;

                    for (const origPos of originalPositions) {
                        if (v0.distanceTo(origPos) < tolerance) v0Matches = true;
                        if (v1.distanceTo(origPos) < tolerance) v1Matches = true;
                        if (v2.distanceTo(origPos) < tolerance) v2Matches = true;
                    }

                    // If ALL 3 vertices match, this triangle is part of the selected face - skip it
                    if (v0Matches && v1Matches && v2Matches) {
                        console.log(`  Skipping triangle ${triangleIndex}: it's part of the selected face`);
                        trianglesSkipped++;
                    } else {
                        // Copy this triangle
                        newPositions.push(
                            v0.x, v0.y, v0.z,
                            v1.x, v1.y, v1.z,
                            v2.x, v2.y, v2.z
                        );
                        trianglesCopied++;
                    }
                }
            }
            console.log(`Copied ${trianglesCopied} triangles, skipped ${trianglesSkipped} triangles (selected face)` +
                (isPunchThrough ? `, ${oppositeFaceSkipped} triangles (opposite face)` : ''));

            const numVerts = originalPositions.length;

            // STEP 2.5: Leave entry opening (NO bottom face)
            // CRITICAL: We do NOT add the original face back - it's deleted to create an opening
            // This leaves behind the edge/vertex data but removes the face triangles
            let bottomFaceTriangles = 0;
            console.log('\n--- STEP 2.5: Entry Opening Created ---');
            console.log(`Ã¢Å“â€œ Entry opening created by removing ${trianglesSkipped} triangles from selected face`);
            console.log(`  Edges and vertices preserved for connection to side walls`);
            if (isPunchThrough) {
                console.log(`  Exit opening created by removing ${oppositeFaceSkipped} triangles from opposite face`);
            }

            // STEP 3: Add extruded top face (SKIP if punch-through)
            let topFaceTriangles = 0;
            if (!isPunchThrough) {
                console.log('\n--- STEP 3: Add Extruded Top Face ---');
                console.log(`Creating top face with ${numVerts} vertices as ${numVerts - 2} triangles (fan triangulation)`);
                for (let i = 1; i < numVerts - 1; i++) {
                    console.log(`  Triangle ${topFaceTriangles}: [0]Ã¢â€ â€™[${i+1}]Ã¢â€ â€™[${i}]`);
                    newPositions.push(
                        extrudedVertices[0].x, extrudedVertices[0].y, extrudedVertices[0].z,
                        extrudedVertices[i + 1].x, extrudedVertices[i + 1].y, extrudedVertices[i + 1].z,
                        extrudedVertices[i].x, extrudedVertices[i].y, extrudedVertices[i].z
                    );
                    topFaceTriangles++;
                }
            } else {
                console.log('\n--- STEP 3: SKIPPED Top Face (Punch-Through) ---');
                console.log('Ã¢Å“â€œ Exit hole created by removing opposite face triangles');
                console.log(`  ${oppositeFaceSkipped} triangles removed from exit face`);
                console.log('Tunnel walls connect entry to exit via side faces');
            }

            // STEP 4: Add side faces (quads as two triangles each)
            console.log('\n--- STEP 4: Add Side Faces ---');
            console.log(`Creating ${numVerts} side quads (${numVerts * 2} triangles)`);
            console.log('Remember: originalPositions are in SORTED order from step 1.5');
            console.log('Each side face connects originalPositions[i] to extrudedVertices[i]');
            let sideFaceTriangles = 0;
            for (let i = 0; i < numVerts; i++) {
                const next = (i + 1) % numVerts;

                const v1 = originalPositions[i];      // Bottom vertex
                const v2 = originalPositions[next];   // Bottom next vertex
                const v3 = extrudedVertices[i];       // Top vertex
                const v4 = extrudedVertices[next];    // Top next vertex

                console.log(`  Quad ${i}: Connecting bottom[${i}](${v1.x.toFixed(2)},${v1.y.toFixed(2)},${v1.z.toFixed(2)})Ã¢â€ â€™bottom[${next}](${v2.x.toFixed(2)},${v2.y.toFixed(2)},${v2.z.toFixed(2)}) with top[${i}](${v3.x.toFixed(2)},${v3.y.toFixed(2)},${v3.z.toFixed(2)})Ã¢â€ â€™top[${next}](${v4.x.toFixed(2)},${v4.y.toFixed(2)},${v4.z.toFixed(2)})`);

                // Calculate normals for both triangles to verify consistent winding
                const edge1_tri1 = new THREE.Vector3().subVectors(v3, v1);
                const edge2_tri1 = new THREE.Vector3().subVectors(v2, v1);
                const normal1 = new THREE.Vector3().crossVectors(edge1_tri1, edge2_tri1).normalize();

                const edge1_tri2 = new THREE.Vector3().subVectors(v3, v2);
                const edge2_tri2 = new THREE.Vector3().subVectors(v4, v2);
                const normal2 = new THREE.Vector3().crossVectors(edge1_tri2, edge2_tri2).normalize();

                const dotProduct = normal1.dot(normal2);
                console.log(`    Triangle normals dot product: ${dotProduct.toFixed(3)} (should be close to 1.0 for consistent winding)`);
                if (dotProduct < 0.9) {
                    console.warn(`    Ã¢Å¡Â Ã¯Â¸Â WARNING: Inconsistent normals detected on quad ${i}! Normals point in different directions.`);
                }

                // Triangle 1: v1, v3, v2 (counter-clockwise from outside)
                newPositions.push(v1.x, v1.y, v1.z);
                newPositions.push(v3.x, v3.y, v3.z);
                newPositions.push(v2.x, v2.y, v2.z);

                // Triangle 2: v2, v3, v4 (counter-clockwise from outside)
                newPositions.push(v2.x, v2.y, v2.z);
                newPositions.push(v3.x, v3.y, v3.z);
                newPositions.push(v4.x, v4.y, v4.z);

                sideFaceTriangles += 2;
            }

            // STEP 4.5: Add exit cap if punch-through (connect tunnel to opposite face opening)
            let exitCapTriangles = 0;
            if (isPunchThrough && oppositeFaceVertices && oppositeFaceVertices.length > 0) {
                console.log('\n--- STEP 4.5: Add Exit Cap (Punch-Through) ---');
                console.log(`Connecting ${numVerts} extruded vertices to ${oppositeFaceVertices.length} opposite face vertices`);

                // We need to connect the extruded vertices (tunnel exit) to the opposite face vertices (hole perimeter)
                // This creates a ring of triangles around the exit hole
                for (let i = 0; i < numVerts; i++) {
                    const next = (i + 1) % numVerts;

                    // Match each extruded vertex to the closest opposite face vertex
                    // For now, assume 1:1 mapping in order
                    const exitV1 = extrudedVertices[i];
                    const exitV2 = extrudedVertices[next];
                    const oppV1 = oppositeFaceVertices[i % oppositeFaceVertices.length];
                    const oppV2 = oppositeFaceVertices[next % oppositeFaceVertices.length];

                    console.log(`  Exit cap ${i}: exit[${i}](${exitV1.x.toFixed(2)},${exitV1.y.toFixed(2)},${exitV1.z.toFixed(2)}) Ã¢â€ â€™ opp[${i}](${oppV1.x.toFixed(2)},${oppV1.y.toFixed(2)},${oppV1.z.toFixed(2)})`);

                    // Triangle 1: exitV1, exitV2, oppV1 (counter-clockwise from inside tunnel)
                    newPositions.push(exitV1.x, exitV1.y, exitV1.z);
                    newPositions.push(exitV2.x, exitV2.y, exitV2.z);
                    newPositions.push(oppV1.x, oppV1.y, oppV1.z);

                    // Triangle 2: exitV2, oppV2, oppV1 (counter-clockwise from inside tunnel)
                    newPositions.push(exitV2.x, exitV2.y, exitV2.z);
                    newPositions.push(oppV2.x, oppV2.y, oppV2.z);
                    newPositions.push(oppV1.x, oppV1.y, oppV1.z);

                    exitCapTriangles += 2;
                }
                console.log(`Created ${exitCapTriangles} exit cap triangles`);
            }

            // STEP 5: Create new geometry and replace
            console.log('\n--- STEP 5: Create New Geometry ---');
            const finalVertexCount = newPositions.length / 3;
            const finalTriangleCount = finalVertexCount / 3;
            console.log(`Total vertices in new geometry: ${finalVertexCount}`);
            console.log(`Total triangles in new geometry: ${finalTriangleCount}`);
            console.log(`Breakdown:`);
            console.log(`  - Existing geometry (minus selected face${isPunchThrough ? ' and opposite face' : ''}): ${trianglesCopied} triangles`);
            if (isPunchThrough) {
                console.log(`  - Entry hole: created by removing ${trianglesSkipped} triangles`);
                console.log(`  - Exit hole: created by removing ${oppositeFaceSkipped} triangles`);
                console.log(`  - Tunnel walls (side faces): ${sideFaceTriangles} triangles`);
                console.log(`  - Exit cap (connects tunnel to exit hole): ${exitCapTriangles} triangles`);
            } else {
                console.log(`  - Entry opening: created by removing ${trianglesSkipped} triangles (no bottom face)`);
                console.log(`  - Top face (extruded): ${topFaceTriangles} triangles`);
                console.log(`  - Side walls: ${sideFaceTriangles} triangles`);
            }
            console.log(`  - TOTAL: ${trianglesCopied + bottomFaceTriangles + topFaceTriangles + sideFaceTriangles + exitCapTriangles} triangles`);

            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));

            // Set draw range for non-indexed geometry (required for raycasting)
            newGeometry.setDrawRange(0, newPositions.length / 3);

            newGeometry.computeVertexNormals();

            // Validate geometry
            const posAttr = newGeometry.attributes.position;
            const normalAttr = newGeometry.attributes.normal;
            console.log('Validating new geometry...');
            console.log('  Position attribute:', posAttr ? `${posAttr.count} vertices` : 'MISSING');
            console.log('  Normal attribute:', normalAttr ? `${normalAttr.count} normals` : 'MISSING');

            // Check for NaN, Infinity, and degenerate triangles
            let hasInvalidData = false;
            let degenerateCount = 0;

            // Check first few vertices for NaN/Infinity
            for (let i = 0; i < Math.min(3, posAttr.count); i++) {
                const x = posAttr.getX(i);
                const y = posAttr.getY(i);
                const z = posAttr.getZ(i);
                if (!isFinite(x) || !isFinite(y) || !isFinite(z)) {
                    console.error(`  Ã¢Å¡Â  Invalid position at vertex ${i}: (${x}, ${y}, ${z})`);
                    hasInvalidData = true;
                }
            }

            // Check for degenerate triangles (zero area)
            const triangleCount = posAttr.count / 3;
            const sampleSize = Math.min(10, triangleCount); // Check first 10 triangles
            for (let i = 0; i < sampleSize; i++) {
                const i0 = i * 3;
                const i1 = i * 3 + 1;
                const i2 = i * 3 + 2;

                const v0 = new THREE.Vector3(posAttr.getX(i0), posAttr.getY(i0), posAttr.getZ(i0));
                const v1 = new THREE.Vector3(posAttr.getX(i1), posAttr.getY(i1), posAttr.getZ(i1));
                const v2 = new THREE.Vector3(posAttr.getX(i2), posAttr.getY(i2), posAttr.getZ(i2));

                // Calculate triangle area using cross product
                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const crossProduct = new THREE.Vector3().crossVectors(edge1, edge2);
                const area = crossProduct.length() / 2;

                if (area < 0.0001) {
                    degenerateCount++;
                    if (degenerateCount <= 3) { // Only log first 3
                        console.warn(`  Ã¢Å¡Â  Degenerate triangle ${i}: area=${area.toFixed(6)}`);
                    }
                }
            }

            if (degenerateCount > 0) {
                console.warn(`  Found ${degenerateCount} degenerate triangles (may affect raycasting)`);
            }

            // Replace the object's geometry
            object.geometry.dispose(); // Clean up old geometry
            object.geometry = newGeometry;

            // CRITICAL: Mark geometry attributes as needing update for raycasting
            newGeometry.attributes.position.needsUpdate = true;
            if (newGeometry.attributes.normal) {
                newGeometry.attributes.normal.needsUpdate = true;
            }

            // CRITICAL: Update bounding box/sphere for raycasting BEFORE computing normals
            // This ensures the bounds are accurate for the new geometry
            newGeometry.computeBoundingBox();
            newGeometry.computeBoundingSphere();

            console.log('Ã¢Å“â€œ Geometry bounds computed');
            console.log('  Bounding sphere center:', newGeometry.boundingSphere.center);
            console.log('  Bounding sphere radius:', newGeometry.boundingSphere.radius);
            console.log('  Bounding box min:', newGeometry.boundingBox.min);
            console.log('  Bounding box max:', newGeometry.boundingBox.max);

            // Verify bounding sphere is valid
            if (newGeometry.boundingSphere.radius === 0 || !isFinite(newGeometry.boundingSphere.radius)) {
                console.error('Ã¢Å¡Â  INVALID BOUNDING SPHERE - raycasting will fail!');
                console.log('Attempting to fix...');
                // Force recalculation
                newGeometry.computeBoundingBox();
                newGeometry.boundingBox.getCenter(newGeometry.boundingSphere.center);
                newGeometry.boundingSphere.radius = newGeometry.boundingBox.min.distanceTo(newGeometry.boundingBox.max) / 2;
            }

            // CRITICAL: Update object matrices and mark for update
            object.updateMatrix();
            object.updateMatrixWorld(true);
            object.matrixWorldNeedsUpdate = true;

            // Force geometry to refresh on GPU
            newGeometry.attributes.position.needsUpdate = true;
            if (newGeometry.attributes.normal) {
                newGeometry.attributes.normal.needsUpdate = true;
            }

            console.log('Ã¢Å“â€œ Geometry replaced and bounds updated');
            console.log('  Position attribute count:', newGeometry.attributes.position.count);
            console.log('  DrawRange:', newGeometry.drawRange);
            console.log('  Has index:', !!newGeometry.index);
            console.log('  Has invalid data:', hasInvalidData);

            // Log object world position for debugging
            const worldPos = new THREE.Vector3();
            object.getWorldPosition(worldPos);
            console.log('  Object world position:', worldPos);

            // STEP 6: Update wireframe
            console.log('\n--- STEP 6: Update Wireframe ---');
            const wireframeChild = object.children.find(child => child.type === 'LineSegments');
            if (wireframeChild) {
                const newEdges = new THREE.EdgesGeometry(newGeometry);
                wireframeChild.geometry.dispose(); // Clean up old edges
                wireframeChild.geometry = newEdges;
                console.log('Ã¢Å“â€œ Wireframe updated');
            } else {
                console.log('Ã¢Å¡Â  No wireframe child found');
            }

            console.log('\n' + '='.repeat(80));
            if (isPunchThrough) {
                console.log('Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ PUNCH-THROUGH EXTRUSION COMPLETE Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ');
                console.log('Through-hole created with entry and exit openings');
            } else {
                console.log('Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ EXTRUSION COMPLETE Ã¢Å“â€œÃ¢Å“â€œÃ¢Å“â€œ');
            }
            console.log('='.repeat(80) + '\n');

            // CRITICAL FIX: Force material update and render to ensure raycasting works
            console.log('--- Forcing Render Update for Raycasting ---');

            // Mark material as needing update
            if (object.material) {
                object.material.needsUpdate = true;
            }

            // Force multiple render cycles to ensure GPU buffers are fully updated
            // This is critical for non-indexed geometry raycasting
            renderer.render(scene, camera);
            renderer.render(scene, camera);

            // Wait a frame, then force one more update
            requestAnimationFrame(() => {
                // Re-compute bounds one more time to be absolutely sure
                object.geometry.computeBoundingBox();
                object.geometry.computeBoundingSphere();
                object.updateMatrixWorld(true);

                renderer.render(scene, camera);

                // Test raycast after final update
                console.log('Testing raycast after multi-frame update...');
                const testRaycaster = new THREE.Raycaster();
                testRaycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const testIntersects = testRaycaster.intersectObject(object, false);
                console.log('Test raycast result:', testIntersects.length, 'intersects');
                if (testIntersects.length > 0) {
                    console.log('Ã¢Å“â€œ Raycasting working!');
                    console.log('First intersection:', {
                        point: testIntersects[0].point,
                        distance: testIntersects[0].distance,
                        faceIndex: testIntersects[0].faceIndex
                    });
                } else {
                    console.log('Ã¢Å¡Â  Raycasting may be limited - checking geometry...');
                    console.log('  Geometry vertices:', object.geometry.attributes.position.count);
                    console.log('  Bounding sphere:', object.geometry.boundingSphere);
                    console.log('  Material side:', object.material.side, '(2 = DoubleSide)');
                    console.log('  First 3 vertices:');
                    for (let i = 0; i < 3 && i < object.geometry.attributes.position.count; i++) {
                        const x = object.geometry.attributes.position.getX(i);
                        const y = object.geometry.attributes.position.getY(i);
                        const z = object.geometry.attributes.position.getZ(i);
                        console.log(`    [${i}]: (${x}, ${y}, ${z})`);
                    }
                }
            });

            // Store reference for debugging
            window.lastExtrudedObject = object;
            console.log('Object stored as window.lastExtrudedObject for debugging');

            // Reset extrusion state
            isExtruding = false;
            extrusionData = null;

            // CRITICAL: Wait two frames before deselecting to ensure full GPU sync
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    deselectAll();
                    console.log('Deselection complete - geometry should be fully interactive now');
                });
            });
        }
        
        function deselectAll() {
            if (selectedObject) {
                selectedObject.material.emissive.setHex(0x000000);
            }
            selectedObject = null;
            selectedFace = null;
            selectedEdge = null;
            selectedVertex = null;
            selectedVertices = []; // Clear multi-selection
            transformGizmo.visible = false;
            updateGizmoAxisLabels();
            clearSelectionHighlights();

            // Reset vertex helper colors to red
            vertexHelpers.forEach(helper => {
                helper.material.color.setHex(0xff0000);
            });

            updateSelectionInfo();
        }
        
        function updateSelectionInfo() {
            const statusEl = document.getElementById('selection-status');

            // Add alignment mode indicator (only shows for face/edge/vertex mode)
            const alignmentMode = useNormalAlignment ?
                '<span style="color: #ffaa44; font-size: 10px;">Gizmo: NORMAL</span>' :
                '<span style="color: #60a5fa; font-size: 10px;">Gizmo: WORLD</span>';

            if (selectionMode === 'object' && selectedObject) {
                const pos = selectedObject.position;
                statusEl.innerHTML = `
                    <div class="face-selected">Object Selected</div>
                    <div style="margin-top: 8px; font-size: 11px;">
                        Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})
                    </div>
                `;
            } else if (selectionMode === 'face' && (selectedFace || selectedFaces.length > 0)) {
                // Handle both single face and multiple faces
                if (selectedFaces.length > 0) {
                    // Multiple faces selected (from box select)
                    const firstFace = selectedFaces[0];
                    const faceLabel = selectedFaces.length === 1 ? 'Face' : 'Faces';
                    const vertexCount = firstFace.vertexIndices ? firstFace.vertexIndices.length :
                                       firstFace.indices ? firstFace.indices.length : 0;
                    statusEl.innerHTML = `
                        <div class="face-selected">${selectedFaces.length} ${faceLabel} Selected</div>
                        <div style="margin-top: 4px;">${alignmentMode}</div>
                        <div style="margin-top: 8px; font-size: 11px;">
                            Vertices: ${vertexCount}${firstFace.triangleCount ? ` (${firstFace.triangleCount} triangles)` : ''}<br>
                            ${selectedFaces.length > 1 ? 'Use primary face for extrusion' : 'Ready for extrusion'}
                        </div>
                    `;
                } else if (selectedFace) {
                    // Single face selected
                    const faceData = selectedFace;
                    statusEl.innerHTML = `
                        <div class="face-selected">Face Selected</div>
                        <div style="margin-top: 4px;">${alignmentMode}</div>
                        <div style="margin-top: 8px; font-size: 11px;">
                            Face Index: ${faceData.faceIndex}<br>
                            Vertices: ${faceData.vertexIndices.length} (${faceData.vertexIndices.join(', ')})
                        </div>
                    `;
                }
            } else if (selectionMode === 'edge' && selectedEdge) {
                const start = selectedEdge.start;
                const end = selectedEdge.end;
                statusEl.innerHTML = `
                    <div class="face-selected">Edge Selected</div>
                    <div style="margin-top: 4px;">${alignmentMode}</div>
                    <div style="margin-top: 8px; font-size: 11px;">
                        Start: (${start.x.toFixed(2)}, ${start.y.toFixed(2)}, ${start.z.toFixed(2)})<br>
                        End: (${end.x.toFixed(2)}, ${end.y.toFixed(2)}, ${end.z.toFixed(2)})
                    </div>
                `;
            } else if (selectionMode === 'vertex' && (selectedVertex || selectedVertices.length > 0)) {
                // Handle both single vertex and multiple vertices
                if (selectedVertices.length > 0) {
                    // Multiple vertices selected (from box select or shift+click)
                    const firstVertex = selectedVertices[0];
                    const pos = firstVertex.pos || firstVertex.worldPos;  // Check 'pos' first (standard format)

                    // Check if we also have complete faces selected
                    const faceInfo = selectedFaces.length > 0 ?
                        `<br><span style="color: #60a5fa;">${selectedFaces.length} complete face${selectedFaces.length > 1 ? 's' : ''} selected</span>` : '';

                    statusEl.innerHTML = `
                        <div class="face-selected">${selectedVertices.length} Vertices Selected</div>
                        <div style="margin-top: 4px;">${alignmentMode}</div>
                        <div style="margin-top: 8px; font-size: 11px;">
                            First Index: ${firstVertex.index}<br>
                            Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})
                            ${faceInfo}
                            <br><span style="color: #60a5fa;">Shift+Click to add/remove vertices</span>
                        </div>
                    `;
                } else if (selectedVertex) {
                    // Single vertex selected (legacy single-click)
                    const pos = selectedVertex.pos;
                    statusEl.innerHTML = `
                        <div class="face-selected">Vertex Selected</div>
                        <div style="margin-top: 4px;">${alignmentMode}</div>
                        <div style="margin-top: 8px; font-size: 11px;">
                            Index: ${selectedVertex.index}<br>
                            Position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})
                        </div>
                    `;
                }
            } else {
                statusEl.innerHTML = '<div class="no-selection">Nothing selected</div>';
            }
        }
        
        function setSelectionMode(mode) {
            const previousMode = selectionMode;
            selectionMode = mode;

            // Button update removed - buttons no longer exist
            // const modeButtons = ['object-mode-btn', 'face-mode-btn', 'edge-mode-btn', 'vertex-mode-btn'];
            // modeButtons.forEach(btnId => {
            //     const btn = document.getElementById(btnId);
            //     if (btn) btn.classList.remove('active');
            // });
            // const activeBtn = document.getElementById(`${mode}-mode-btn`);
            // if (activeBtn) activeBtn.classList.add('active');

            // Update vertex helpers - show in any edit mode except object mode
            if (mode !== 'object' && selectedObject) {
                updateVertexHelpers(selectedObject);
                // updateFaceEdgeSelectionHelpers(selectedObject); // Disabled - too cluttered
            } else {
                // updateFaceEdgeSelectionHelpers(null); // Disabled - too cluttered
                // Clear vertex helpers when in object mode
                vertexHelpers.forEach(helper => {
                    if (helper.parent) {
                        helper.parent.remove(helper);
                    }
                    helper.geometry.dispose();
                    helper.material.dispose();
                });
                vertexHelpers = [];
            }

            // Only clear selections when CHANGING modes (not when staying in same mode)
            if (previousMode !== mode) {
                deselectAll();
                console.log('Selection mode changed from', previousMode, 'to:', mode);
            } else {
                console.log('Staying in same mode:', mode, '- preserving selection');
            }
        }
        
        function setTransformMode(mode) {
            transformMode = mode;
            
            // Button update removed - buttons no longer exist
            // const transformButtons = ['select-btn', 'translate-btn', 'rotate-btn', 'scale-btn'];
            // transformButtons.forEach(btnId => {
            //     document.getElementById(btnId).classList.remove('active');
            // });
            // document.getElementById(`${mode}-btn`).classList.add('active');
            
            // Switch gizmo visual based on mode AND selection type
            if (mode !== 'select' && transformGizmo.userData.gizmos) {
                // Remove current gizmo
                const currentMode = transformGizmo.userData.currentMode;
                if (currentMode && transformGizmo.userData.gizmos[currentMode]) {
                    transformGizmo.remove(transformGizmo.userData.gizmos[currentMode]);
                }
                
                // For edges in scale mode, use special edge scale gizmo
                let gizmoToUse = mode;
                if (mode === 'scale' && selectionMode === 'edge') {
                    gizmoToUse = 'edgeScale';
                    
                    // Orient the edge scale gizmo along the edge direction
                    if (selectedEdge) {
                        const direction = new THREE.Vector3()
                            .subVectors(selectedEdge.end, selectedEdge.start)
                            .normalize();
                        
                        const edgeGizmo = transformGizmo.userData.gizmos.edgeScale;
                        edgeGizmo.quaternion.setFromUnitVectors(
                            new THREE.Vector3(0, 1, 0),
                            direction
                        );
                    }
                }
                
                // Add new gizmo
                if (transformGizmo.userData.gizmos[gizmoToUse]) {
                    transformGizmo.add(transformGizmo.userData.gizmos[gizmoToUse]);
                    transformGizmo.userData.currentMode = gizmoToUse;
                }
            }
            
            // Show/hide gizmo
            if (selectedObject && mode !== 'select') {
                transformGizmo.visible = true;
                
                // Position gizmo based on selection mode
                if (selectionMode === 'object') {
                    transformGizmo.position.copy(selectedObject.position);
                } else if (selectionMode === 'face' && faceHighlight.visible) {
                    transformGizmo.position.copy(faceHighlight.position);
                } else if (selectionMode === 'edge' && edgeHighlight.visible) {
                    // Calculate edge center from the edge highlight geometry
                    if (selectedEdge) {
                        const edgeCenter = new THREE.Vector3()
                            .addVectors(selectedEdge.start, selectedEdge.end)
                            .multiplyScalar(0.5);
                        transformGizmo.position.copy(edgeCenter);
                    }
                } else if (selectionMode === 'vertex' && vertexHighlight.visible) {
                    transformGizmo.position.copy(vertexHighlight.position);
                }
            } else {
                transformGizmo.visible = false;
            }
            alignTransformGizmo();
            
            console.log('Transform mode changed to:', mode, 'Gizmo type:', transformGizmo.userData.currentMode, 'Visible:', transformGizmo.visible);
        }
        
        function addCube() {
            const newCube = createCube(
                Math.random() * 2 - 1,
                0.5,
                Math.random() * 2 - 1
            );
            selectObject(newCube);
        }
        
        function addCylinder() {
            const newCylinder = createCylinder(
                Math.random() * 2 - 1,
                0.5,
                Math.random() * 2 - 1
            );
            selectObject(newCylinder);
        }

        function addCone() {
            const newCone = createCone(
                Math.random() * 2 - 1,
                0.5,
                Math.random() * 2 - 1
            );
            selectObject(newCone);
        }
        
        function deleteSelected() {
            if (selectedObject) {
                if (selectedObject.userData?.mirror) {
                    removeMirrorClone(selectedObject);
                } else if (selectedObject.userData?.mirrorSource) {
                    const sourceObject = selectedObject.userData.mirrorSource;
                    if (sourceObject?.userData?.mirror) {
                        removeMirrorClone(sourceObject);
                    }
                }

                scene.remove(selectedObject);
                objects = objects.filter(obj => obj !== selectedObject);
                deselectAll();
            }
        }
        
        function setCameraView(view) {
            // Save current 3D view before switching to ortho views
            if (view !== '3d') {
                saved3DView.theta = controls.theta;
                saved3DView.phi = controls.phi;
                saved3DView.radius = controls.radius;
                saved3DView.target.copy(controls.target);
            }

            // XY-Plane coordinate system views
            // Grid on XY plane, camera normally at +Z looking down
            // Spherical coordinates: phi = angle from +Y axis, theta = angle in XZ plane from +X
            // x = radius * sin(phi) * cos(theta)
            // y = radius * cos(phi)
            // z = radius * sin(phi) * sin(theta)
            switch(view) {
                case 'front':
                    // Look from +Y toward origin (front of ship facing North/+Y)
                    // Camera at (0, radius, 0): phi = 0
                    controls.theta = 0;
                    controls.phi = 0;
                    controls.radius = 8;
                    break;
                case 'side':
                    // Look from -X toward origin (left side view, seeing right side of model)
                    // Camera at (-radius, 0, 0): phi = Ï€/2, theta = Ï€
                    controls.theta = Math.PI;
                    controls.phi = Math.PI / 2;
                    controls.radius = 8;
                    break;
                case 'top':
                    // Look from +Z down at XY plane (top-down view)
                    // Camera at (0, 0, radius): phi = Ï€/2, theta = Ï€/2
                    controls.theta = Math.PI / 2;
                    controls.phi = Math.PI / 2;
                    controls.radius = 8;
                    break;
                case '3d':
                    // Restore saved 3D view
                    controls.theta = saved3DView.theta;
                    controls.phi = saved3DView.phi;
                    controls.radius = saved3DView.radius;
                    controls.target.copy(saved3DView.target);
                    break;
            }
            updateCameraPosition();
        }

        function centerSelectedObject() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            // Save state for undo
            saveToHistory();

            // Move object to grid center
            selectedObject.position.set(0, 0, 0);

            // Update gizmo position if visible
            if (transformGizmo.visible) {
                transformGizmo.position.copy(selectedObject.position);
            }

            // Update mirror if exists
            if (selectedObject.userData?.mirror) {
                const mirrorMesh = selectedObject.userData.mirror.mesh;
                if (mirrorMesh) {
                    mirrorMesh.position.copy(selectedObject.position);
                }
            }
        }

        function toggleCutTool() {
            if (!selectedObject) {
                alert('Please select an object first');
                return;
            }

            if (!cutToolActive) {
                // Check if edge is selected
                if (selectionMode !== 'edge' || !selectedEdge) {
                    alert('Please select an edge first!\n\nThe cut plane will be generated from the two faces adjacent to the edge.');
                    return;
                }

                // Activate cut tool
                cutToolActive = true;
                cutKeepSide = 1;
                cutDistance = 0;

                const btn = document.getElementById('cut-tool-btn');
                btn.classList.add('active');
                btn.textContent = 'Execute Cut';

                // Show distance slider
                document.getElementById('cut-distance-slider-group').style.display = 'block';
                document.getElementById('cut-distance-slider').value = 0;
                document.getElementById('cut-distance-value').textContent = '0.00';

                // Show preview
                updateCutPlanePreview();

                alert('Cut Tool Active!\n\nAdjust distance slider to offset the cut plane.\nTAB: Flip which side to keep\nClick "Execute Cut" when ready');
            } else {
                // Execute cut
                const cutPlane = calculateCutPlane();
                if (cutPlane) {
                    cutMeshWithPlane(cutPlane);
                }
                deactivateCutTool();
            }
        }

        function deactivateCutTool() {
            cutToolActive = false;
            cutDistance = 0;

            const btn = document.getElementById('cut-tool-btn');
            btn.classList.remove('active');
            btn.textContent = 'Cut Tool';

            // Hide distance slider
            document.getElementById('cut-distance-slider-group').style.display = 'none';

            // Remove plane helper
            if (cutPlaneHelper) {
                scene.remove(cutPlaneHelper);
                cutPlaneHelper.geometry.dispose();
                cutPlaneHelper.material.dispose();
                cutPlaneHelper = null;
            }
        }

        // Removed: addCutPointMarker - no longer needed with edge-based cut

        function calculateCutPlane() {
            if (!selectedEdge || !selectedObject) return null;

            const geometry = selectedObject.geometry;
            const positionAttr = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;

            if (!indices) {
                alert('Cut tool requires indexed geometry');
                return null;
            }

            // Get edge vertices in local space
            const edgeStart = selectedEdge.start.clone();
            const edgeEnd = selectedEdge.end.clone();
            selectedObject.worldToLocal(edgeStart);
            selectedObject.worldToLocal(edgeEnd);

            // Edge direction
            const edgeDir = new THREE.Vector3().subVectors(edgeEnd, edgeStart).normalize();

            // Find the two faces adjacent to this edge
            const adjacentFaces = [];
            const edgeIndices = selectedEdge.indices;

            if (!edgeIndices || !edgeIndices.start || !edgeIndices.end) {
                alert('Edge data incomplete');
                return null;
            }

            const startIdx = edgeIndices.start[0];
            const endIdx = edgeIndices.end[0];
            const threshold = 0.0001;

            // Search all triangles for faces sharing this edge
            for (let i = 0; i < indices.length; i += 3) {
                const a = indices[i];
                const b = indices[i + 1];
                const c = indices[i + 2];

                const vA = new THREE.Vector3().fromBufferAttribute(positionAttr, a);
                const vB = new THREE.Vector3().fromBufferAttribute(positionAttr, b);
                const vC = new THREE.Vector3().fromBufferAttribute(positionAttr, c);

                // Check if this triangle shares both edge vertices
                let matchCount = 0;
                if (vA.distanceTo(edgeStart) < threshold || vA.distanceTo(edgeEnd) < threshold) matchCount++;
                if (vB.distanceTo(edgeStart) < threshold || vB.distanceTo(edgeEnd) < threshold) matchCount++;
                if (vC.distanceTo(edgeStart) < threshold || vC.distanceTo(edgeEnd) < threshold) matchCount++;

                if (matchCount >= 2) {
                    // This face shares the edge
                    const normal = new THREE.Vector3()
                        .crossVectors(
                            new THREE.Vector3().subVectors(vB, vA),
                            new THREE.Vector3().subVectors(vC, vA)
                        )
                        .normalize();
                    adjacentFaces.push(normal);
                }

                if (adjacentFaces.length >= 2) break;
            }

            if (adjacentFaces.length < 2) {
                alert('Could not find two adjacent faces for this edge');
                return null;
            }

            // Calculate bisector normal (average of the two face normals)
            const bisectorNormal = new THREE.Vector3()
                .addVectors(adjacentFaces[0], adjacentFaces[1])
                .normalize();

            // Make sure bisector is perpendicular to the edge
            const perpNormal = bisectorNormal.clone().sub(
                edgeDir.clone().multiplyScalar(bisectorNormal.dot(edgeDir))
            ).normalize();

            // Flip based on keep side
            if (cutKeepSide === -1) {
                perpNormal.negate();
            }

            // Plane point: edge midpoint + offset along perpendicular direction
            const edgeMidpoint = new THREE.Vector3().addVectors(edgeStart, edgeEnd).multiplyScalar(0.5);
            const planePoint = edgeMidpoint.clone().add(perpNormal.clone().multiplyScalar(cutDistance));

            // Convert to world space
            const worldNormal = perpNormal.clone().transformDirection(selectedObject.matrixWorld).normalize();
            const worldPoint = planePoint.clone().applyMatrix4(selectedObject.matrixWorld);

            return new THREE.Plane().setFromNormalAndCoplanarPoint(worldNormal, worldPoint);
        }

        // Removed: addCutPointMarker - no longer used with edge-based cut tool

        function updateCutPlanePreview() {
            // Remove old plane helper
            if (cutPlaneHelper) {
                scene.remove(cutPlaneHelper);
                cutPlaneHelper.geometry.dispose();
                cutPlaneHelper.material.dispose();
                cutPlaneHelper = null;
            }

            if (!cutToolActive || !selectedEdge) return;

            const plane = calculateCutPlane();
            if (!plane) {
                console.warn('Could not calculate cut plane for preview');
                return;
            }

            // Get plane position - use the plane's coplanar point (includes distance offset)
            const edgeMidpoint = selectedEdge.start.clone().lerp(selectedEdge.end, 0.5);
            const normal = plane.normal.clone();

            // Calculate the actual plane position with offset
            const planePoint = edgeMidpoint.clone().add(normal.clone().multiplyScalar(cutDistance));

            console.log('Cut plane preview - Point:', planePoint, 'Normal:', normal, 'Distance:', cutDistance);

            // Create a smaller, more visible plane with grid
            const planeSize = 3;
            const planeGeom = new THREE.PlaneGeometry(planeSize, planeSize, 8, 8);

            // Color indicates which side will be kept
            const keepColor = cutKeepSide === 1 ? 0x00ff00 : 0xff0000; // Green = keep, Red = discard
            const planeMat = new THREE.MeshBasicMaterial({
                color: keepColor,
                transparent: true,
                opacity: 0.4,
                side: THREE.DoubleSide,
                depthTest: true,
                wireframe: false
            });
            cutPlaneHelper = new THREE.Mesh(planeGeom, planeMat);

            // Add wireframe overlay
            const wireframeGeom = new THREE.EdgesGeometry(planeGeom);
            const wireframeMat = new THREE.LineBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const wireframe = new THREE.LineSegments(wireframeGeom, wireframeMat);
            cutPlaneHelper.add(wireframe);

            // Add arrow to show "keep" direction
            const arrowHelper = new THREE.ArrowHelper(
                normal,
                new THREE.Vector3(0, 0, 0),
                planeSize * 0.5,
                0xffff00, // Yellow arrow points to "keep" side
                planeSize * 0.15,
                planeSize * 0.1
            );
            cutPlaneHelper.add(arrowHelper);

            // Add text showing which side
            const textDiv = document.createElement('div');
            textDiv.style.cssText = 'position: absolute; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 4px; pointer-events: none; z-index: 1000;';
            textDiv.textContent = `Arrow = Keep Side (${cutKeepSide === 1 ? '+' : '-'})`;
            document.body.appendChild(textDiv);
            setTimeout(() => textDiv.remove(), 3000);

            // Position and orient the plane
            cutPlaneHelper.position.copy(planePoint);
            cutPlaneHelper.lookAt(planePoint.clone().add(normal));

            scene.add(cutPlaneHelper);
            console.log('Cut plane preview created at:', planePoint);
        }

        function cutMeshWithPlane(plane) {
            if (!selectedObject) return;

            saveToHistory();

            const geometry = selectedObject.geometry;
            const positions = geometry.attributes.position;
            const indices = geometry.index ? geometry.index.array : null;

            // Convert plane to local space
            const localPlane = plane.clone();
            const invMatrix = new THREE.Matrix4().copy(selectedObject.matrixWorld).invert();
            localPlane.applyMatrix4(invMatrix);

            // For simplicity, we'll split triangles that cross the plane
            const newPositions = [];
            const newIndices = [];
            const newFaces = [];

            // Classify vertices as above/below/on the plane
            const vertexClassification = [];
            const threshold = 0.001;

            for (let i = 0; i < positions.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(positions, i);
                const distance = localPlane.distanceToPoint(v);

                if (Math.abs(distance) < threshold) {
                    vertexClassification[i] = 0; // On plane
                } else if (distance > 0) {
                    vertexClassification[i] = 1; // Above
                } else {
                    vertexClassification[i] = -1; // Below
                }
            }

            // Track intersection points for capping
            const capVertices = [];

            // Helper function to get edge intersection with plane
            function getEdgeIntersection(v1, v2, c1, c2) {
                if (c1 === 0) return v1.clone();
                if (c2 === 0) return v2.clone();
                if (c1 * c2 > 0) return null; // Same side, no intersection

                const d1 = localPlane.distanceToPoint(v1);
                const d2 = localPlane.distanceToPoint(v2);
                const t = d1 / (d1 - d2);

                return new THREE.Vector3().lerpVectors(v1, v2, t);
            }

            // Helper to add vertex to arrays and return index
            function addVertex(v) {
                const base = newPositions.length / 3;
                newPositions.push(v.x, v.y, v.z);
                return base;
            }

            // Process each triangle
            const faceCount = indices ? indices.length / 3 : positions.count / 3;

            for (let i = 0; i < faceCount; i++) {
                const i0 = indices ? indices[i * 3] : i * 3;
                const i1 = indices ? indices[i * 3 + 1] : i * 3 + 1;
                const i2 = indices ? indices[i * 3 + 2] : i * 3 + 2;

                const v0 = new THREE.Vector3().fromBufferAttribute(positions, i0);
                const v1 = new THREE.Vector3().fromBufferAttribute(positions, i1);
                const v2 = new THREE.Vector3().fromBufferAttribute(positions, i2);

                const c0 = vertexClassification[i0];
                const c1 = vertexClassification[i1];
                const c2 = vertexClassification[i2];

                // Organize vertices by classification
                const verts = [
                    { pos: v0, classification: c0 },
                    { pos: v1, classification: c1 },
                    { pos: v2, classification: c2 }
                ];

                const above = verts.filter(v => v.classification > 0);
                const below = verts.filter(v => v.classification < 0);
                const on = verts.filter(v => v.classification === 0);

                // Case 1: All vertices on positive side - keep entire triangle
                if (above.length === 3 || (above.length + on.length === 3)) {
                    const idx0 = addVertex(v0);
                    const idx1 = addVertex(v1);
                    const idx2 = addVertex(v2);
                    newIndices.push(idx0, idx1, idx2);
                }
                // Case 2: Triangle crosses plane - split it
                else if (above.length > 0 && below.length > 0) {
                    // Find intersection points on edges that cross the plane
                    const intersections = [];

                    // Check each edge
                    if (c0 * c1 < 0) {
                        const int = getEdgeIntersection(v0, v1, c0, c1);
                        intersections.push({ point: int, edge: [0, 1] });
                        capVertices.push(int);
                    }
                    if (c1 * c2 < 0) {
                        const int = getEdgeIntersection(v1, v2, c1, c2);
                        intersections.push({ point: int, edge: [1, 2] });
                        capVertices.push(int);
                    }
                    if (c2 * c0 < 0) {
                        const int = getEdgeIntersection(v2, v0, c2, c0);
                        intersections.push({ point: int, edge: [2, 0] });
                        capVertices.push(int);
                    }

                    // Split triangle based on how many vertices are above
                    if (above.length === 1) {
                        // One vertex above, two below: create 1 triangle above plane
                        const aboveVert = above[0].pos;
                        const int0 = intersections[0].point;
                        const int1 = intersections[1].point;

                        const idx0 = addVertex(aboveVert);
                        const idx1 = addVertex(int0);
                        const idx2 = addVertex(int1);
                        newIndices.push(idx0, idx1, idx2);
                    }
                    else if (above.length === 2) {
                        // Two vertices above, one below: create 2 triangles above plane (quad split)
                        const aboveVerts = above.map(v => v.pos);
                        const int0 = intersections[0].point;
                        const int1 = intersections[1].point;

                        // First triangle
                        const idx0 = addVertex(aboveVerts[0]);
                        const idx1 = addVertex(aboveVerts[1]);
                        const idx2 = addVertex(int0);
                        newIndices.push(idx0, idx1, idx2);

                        // Second triangle
                        const idx3 = addVertex(aboveVerts[1]);
                        const idx4 = addVertex(int1);
                        const idx5 = addVertex(int0);
                        newIndices.push(idx3, idx4, idx5);
                    }
                }
                // Case 3: All vertices below plane - discard triangle
            }

            // Create cap face if we have intersection points
            if (capVertices.length >= 3) {
                console.log('Cap vertices before deduplication:', capVertices.length);

                // DEDUPLICATE vertices - same intersection can be added multiple times
                const uniqueCapVertices = [];
                const tolerance = 0.0001;

                for (const vert of capVertices) {
                    let isDuplicate = false;
                    for (const existing of uniqueCapVertices) {
                        if (vert.distanceTo(existing) < tolerance) {
                            isDuplicate = true;
                            break;
                        }
                    }
                    if (!isDuplicate) {
                        uniqueCapVertices.push(vert);
                    }
                }

                console.log('Cap vertices after deduplication:', uniqueCapVertices.length);

                if (uniqueCapVertices.length < 3) {
                    console.warn('Not enough unique vertices for cap');
                } else {

                // Project vertices onto the plane to get 2D coordinates for triangulation
                const planeNormal = localPlane.normal;
                const origin = uniqueCapVertices[0];

                // Create two perpendicular vectors on the plane for 2D projection
                const tangent = new THREE.Vector3(1, 0, 0);
                if (Math.abs(planeNormal.dot(tangent)) > 0.9) {
                    tangent.set(0, 1, 0);
                }
                const u = new THREE.Vector3().crossVectors(planeNormal, tangent).normalize();
                const v = new THREE.Vector3().crossVectors(planeNormal, u);

                // Project to 2D
                const points2D = uniqueCapVertices.map(vert => {
                    const rel = new THREE.Vector3().subVectors(vert, origin);
                    return { x: rel.dot(u), y: rel.dot(v), vert3D: vert };
                });

                // Compute centroid
                const centroid = { x: 0, y: 0 };
                points2D.forEach(p => { centroid.x += p.x; centroid.y += p.y; });
                centroid.x /= points2D.length;
                centroid.y /= points2D.length;

                // Sort points by angle around centroid to form proper polygon
                points2D.sort((a, b) => {
                    const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);
                    const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);
                    return angleA - angleB;
                });

                // Use ear clipping for better triangulation (handles non-convex polygons)
                // For now, simple fan triangulation but only if polygon is likely convex
                const capBase = newPositions.length / 3;

                // Add all cap vertices first
                const capIndices = [];
                points2D.forEach(p => {
                    capIndices.push(addVertex(p.vert3D));
                });

                // Determine winding order ONCE for the whole cap
                // Check the first triangle to determine if we need to flip
                const v0 = points2D[0].vert3D;
                const v1 = points2D[1].vert3D;
                const v2 = points2D[2].vert3D;

                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                const firstTriangleNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

                // Cap should face outward (same direction as plane normal after cut)
                const useReversedWinding = firstTriangleNormal.dot(planeNormal) < 0;

                console.log('Cap winding determined:', useReversedWinding ? 'REVERSED' : 'NORMAL',
                           'FirstTriNormal:', firstTriangleNormal.toArray(),
                           'PlaneNormal:', planeNormal.toArray());

                // Simple fan triangulation from first vertex with consistent winding
                for (let i = 1; i < capIndices.length - 1; i++) {
                    if (useReversedWinding) {
                        newIndices.push(capIndices[0], capIndices[i + 1], capIndices[i]);
                    } else {
                        newIndices.push(capIndices[0], capIndices[i], capIndices[i + 1]);
                    }
                }

                console.log('Cap created with', capIndices.length, 'vertices and', capIndices.length - 2, 'triangles');
                }
            }

            // Convert to triangles for optimization
            const triangles = [];
            for (let i = 0; i < newIndices.length; i += 3) {
                const idx0 = newIndices[i];
                const idx1 = newIndices[i + 1];
                const idx2 = newIndices[i + 2];

                triangles.push([
                    new THREE.Vector3(
                        newPositions[idx0 * 3],
                        newPositions[idx0 * 3 + 1],
                        newPositions[idx0 * 3 + 2]
                    ),
                    new THREE.Vector3(
                        newPositions[idx1 * 3],
                        newPositions[idx1 * 3 + 1],
                        newPositions[idx1 * 3 + 2]
                    ),
                    new THREE.Vector3(
                        newPositions[idx2 * 3],
                        newPositions[idx2 * 3 + 1],
                        newPositions[idx2 * 3 + 2]
                    )
                ]);
            }

            console.log('Before optimization:', newPositions.length / 3, 'vertices,', triangles.length, 'triangles');

            // Use meshTopology.js for proper vertex welding and optimization
            // Use a tighter tolerance for vertex welding
            let newGeometry = createIndexedGeometryFromTriangles(triangles, 1e-5, THREE);

            console.log('After optimization:', newGeometry.attributes.position.count, 'vertices,',
                        newGeometry.index.count / 3, 'triangles');

            // Ensure normals are computed correctly
            newGeometry.computeVertexNormals();
            console.log('Normals recomputed');

            // Validate geometry
            const posCount = newGeometry.attributes.position.count;
            const idxCount = newGeometry.index ? newGeometry.index.count : 0;
            console.log('Final geometry validation:', { vertices: posCount, indices: idxCount, triangles: idxCount / 3 });

            // Replace old geometry
            selectedObject.geometry.dispose();
            selectedObject.geometry = newGeometry;

            // Force wireframe update
            updateWireframe(selectedObject);

            // Clear selection to avoid stale face/edge data
            clearSelectionHighlights();
            selectedFace = null;
            selectedEdge = null;
            selectedVertex = null;
            selectedVertices = [];
            selectedFaces = [];

            console.log('âœ… Cut complete, geometry updated, selection cleared');
        }
        
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            if (isOrthographic) {
                // Update orthographic camera frustum
                const frustumSize = camera.userData.frustumSize || 10;
                camera.left = frustumSize * aspect / -2;
                camera.right = frustumSize * aspect / 2;
                camera.top = frustumSize / 2;
                camera.bottom = frustumSize / -2;
            } else {
                // Update perspective camera aspect
                camera.aspect = aspect;
            }

            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);

            // Update vertex label positions
            vertexLabels.forEach(label => {
                const screenPos = label.position.clone();
                screenPos.project(camera);

                // Check if behind camera
                if (screenPos.z > 1) {
                    label.element.style.display = 'none';
                    return;
                }

                // Convert to screen coordinates
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;

                label.element.style.display = 'block';
                label.element.style.left = `${x}px`;
                label.element.style.top = `${y}px`;
            });

            // Animate edge glow if enabled in preview mode
            if (selectedObject && selectedObject.userData.animateEdges && selectedObject.userData.wireframe) {
                const time = performance.now() * 0.001; // Convert to seconds
                const speed = selectedObject.userData.animSpeed || 1.0;
                const wireframe = selectedObject.userData.wireframe;
                const baseColor = selectedObject.userData.baseEdgeColor;
                const baseGlow = selectedObject.userData.edgeGlow || 0;

                if (wireframe.material && baseColor !== undefined) {
                    // Pulse the brightness using sine wave
                    const pulse = Math.sin(time * speed) * 0.5 + 0.5; // 0 to 1
                    const glowMultiplier = 1 + (baseGlow + pulse * 0.5) * 2;

                    const glowColor = new THREE.Color(baseColor);
                    glowColor.multiplyScalar(glowMultiplier);
                    wireframe.material.color.copy(glowColor);

                    // Also pulse the line opacity slightly
                    const opacityPulse = Math.sin(time * speed * 0.5) * 0.1 + 0.9; // 0.8 to 1.0
                    wireframe.material.opacity = opacityPulse;
                }
            }

            objects.forEach(obj => {
                const mirrorInfo = obj.userData?.mirror;
                if (mirrorInfo && mirrorInfo.mesh) {
                    const mirrorMesh = mirrorInfo.mesh;
                    mirrorMesh.position.copy(obj.position);
                    mirrorMesh.quaternion.copy(obj.quaternion);
                    mirrorMesh.scale.copy(obj.scale);
                    mirrorMesh.visible = obj.visible;
                }
            });

            updateGizmoAxisLabels();

            renderer.render(scene, camera);
        }
        
        // Prevent context menu on right click
        document.addEventListener('contextmenu', event => event.preventDefault());
        
        // Initialize
        init();
    </script>
</body>
</html>












